-- phpMyAdmin SQL Dump
-- version 4.4.14
-- http://www.phpmyadmin.net
--
-- Host: 127.0.0.1
-- Generation Time: Nov 28, 2015 at 08:39 AM
-- Server version: 5.6.26
-- PHP Version: 5.6.12

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- Database: `laptrinh321`
--

-- --------------------------------------------------------

--
-- Table structure for table `baiviet`
--

CREATE TABLE IF NOT EXISTS `baiviet` (
  `idbv` int(10) unsigned NOT NULL,
  `subject` text COLLATE utf8_unicode_ci,
  `content` longtext COLLATE utf8_unicode_ci,
  `image_bv` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `parent` int(10) unsigned NOT NULL,
  `date_add` date DEFAULT NULL,
  `views` int(11) DEFAULT '0',
  `author` int(11) NOT NULL DEFAULT '1',
  `des` longtext COLLATE utf8_unicode_ci
) ENGINE=InnoDB AUTO_INCREMENT=130 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

--
-- Dumping data for table `baiviet`
--

INSERT INTO `baiviet` (`idbv`, `subject`, `content`, `image_bv`, `parent`, `date_add`, `views`, `author`, `des`) VALUES
(1, 'giới thiệu ngôn ngữ PHP - ngôn ngữ của WEB động', '<p><strong>PHP (Hypertext Preprocessor) l&agrave; ng&ocirc;n ngữ script tr&ecirc;n server được thiết kế để dễ d&agrave;ng x&acirc;y dựng c&aacute;c trang Web động. M&atilde; PHP c&oacute; thể thực thi tr&ecirc;n Webserver để tạo ra m&atilde; HTML v&agrave; xuất ra tr&igrave;nh duyệt web theo y&ecirc;u cầu của người sử dụng.</strong>PHP l&agrave;&nbsp;<a href="http://vi.wikipedia.org/wiki/Ng%C3%B4n_ng%E1%BB%AF_l%E1%BA%ADp_tr%C3%ACnh"><strong>ng&ocirc;n ngữ lập tr&igrave;nh</strong></a>&nbsp;kịch bản hay một loại&nbsp;<a href="http://vi.wikipedia.org/w/index.php?title=M%C3%A3_l%E1%BB%87nh&amp;action=edit&amp;redlink=1"><strong>m&atilde; lệnh</strong></a>&nbsp;chủ yếu được d&ugrave;ng để ph&aacute;t triển c&aacute;c&nbsp;<a href="http://vi.wikipedia.org/wiki/%E1%BB%A8ng_d%E1%BB%A5ng_web">ứng dụng</a>&nbsp;viết cho m&aacute;y chủ,&nbsp;<a href="http://vi.wikipedia.org/wiki/M%C3%A3_ngu%E1%BB%93n_m%E1%BB%9F">m&atilde; nguồn mở</a>, d&ugrave;ng cho mục đ&iacute;ch tổng qu&aacute;t. N&oacute; rất th&iacute;ch hợp với&nbsp;<a href="http://vi.wikipedia.org/wiki/Internet">web</a>&nbsp;v&agrave; c&oacute; thể dễ d&agrave;ng nh&uacute;ng v&agrave;o trang&nbsp;<a href="http://vi.wikipedia.org/wiki/HTML">HTML</a>. Do được tối ưu h&oacute;a cho c&aacute;c ứng dụng web, tốc độ nhanh, nhỏ gọn, c&uacute; ph&aacute;p giống&nbsp;<a href="http://vi.wikipedia.org/wiki/C_%28ng%C3%B4n_ng%E1%BB%AF%29">C</a>&nbsp;v&agrave;&nbsp;<a href="http://vi.wikipedia.org/wiki/Java_%28ng%C3%B4n_ng%E1%BB%AF%29">Java</a>, dễ học v&agrave; thời gian x&acirc;y dựng sản phẩm tương đối ngắn hơn so với c&aacute;c ng&ocirc;n ngữ kh&aacute;c n&ecirc;n PHP đ&atilde; nhanh ch&oacute;ng trở th&agrave;nh một ng&ocirc;n ngữ lập tr&igrave;nh web phổ biến nhất thế giới.</p>\r\n\r\n<p>Ng&ocirc;n ngữ, c&aacute;c thư viện, t&agrave;i liệu gốc của PHP được x&acirc;y dựng bởi cộng đồng v&agrave; c&oacute; sự đ&oacute;ng g&oacute;p rất lớn của&nbsp;<a href="http://vi.wikipedia.org/w/index.php?title=Zend_Inc.&amp;action=edit&amp;redlink=1">Zend Inc.</a>, c&ocirc;ng ty do c&aacute;c nh&agrave; ph&aacute;t triển cốt l&otilde;i của PHP lập n&ecirc;n nhằm tạo ra một m&ocirc;i trường chuy&ecirc;n nghiệp để đưa PHP ph&aacute;t triển ở quy m&ocirc; doanh nghiệp.</p>\r\n\r\n<p><br />\r\n<a name="more"></a></p>\r\n\r\n<h2><strong>PHP/FI</strong></h2>\r\n\r\n<p>PHP được ph&aacute;t triển từ một sản phẩm c&oacute; t&ecirc;n l&agrave; PHP/FI. PHP/FI do Rasmus Lerdorf tạo ra năm 1995, ban đầu được xem như l&agrave; một tập con đơn giản của c&aacute;c m&atilde; kịch bản Perl để theo d&otilde;i t&igrave;nh h&igrave;nh truy cập đến bản sơ yếu l&yacute; lịch của &ocirc;ng tr&ecirc;n mạng. &Ocirc;ng đ&atilde; đặt t&ecirc;n cho bộ m&atilde; kịch bản n&agrave;y l&agrave; &#39;Personal Home Page Tools&#39;. Khi cần đến c&aacute;c chức năng rộng hơn, Rasmus đ&atilde; viết ra một bộ thực thi bằng C lớn hơn để c&oacute; thể truy vấn tới c&aacute;c cơ sở dữ liệu v&agrave; gi&uacute;p cho người sử dụng ph&aacute;t triển c&aacute;c ứng dụng web đơn giản. Rasmus đ&atilde; quyết định c&ocirc;ng bố m&atilde; nguồn của PHP/FI cho mọi người xem, sử dụng cũng như sửa c&aacute;c lỗi c&oacute; trong n&oacute; đồng thời cải tiến m&atilde; nguồn.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>PHP/FI, viết tắt từ &quot;Personal Home Page/Forms Interpreter&quot;, bao gồm một số c&aacute;c chức năng cơ bản cho PHP như ta đ&atilde; biết đến ch&uacute;ng ng&agrave;y nay. N&oacute; c&oacute; c&aacute;c biến kiểu như Perl, th&ocirc;ng dịch tự động c&aacute;c biến của form v&agrave; c&uacute; ph&aacute;p HTML nh&uacute;ng. C&uacute; ph&aacute;p n&agrave;y giống như của Perl, mặc d&ugrave; hạn chế hơn nhiều, đơn giản v&agrave; c&oacute; phần thiếu nhất qu&aacute;n.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>V&agrave;o năm 1997, PHP/FI 2.0, lần viết lại thứ hai của phi&ecirc;n bản C, đ&atilde; thu h&uacute;t được h&agrave;ng ng&agrave;n người sử dụng tr&ecirc;n to&agrave;n thế giới với xấp xỉ 50.000 t&ecirc;n miền đ&atilde; được ghi nhận l&agrave; c&oacute; c&agrave;i đặt n&oacute;, chiếm khoảng 1% số t&ecirc;n miền c&oacute; tr&ecirc;n mạng Internet. Tuy đ&atilde; c&oacute; tới h&agrave;ng ngh&igrave;n người tham gia đ&oacute;ng g&oacute;p v&agrave;o việc tu chỉnh m&atilde; nguồn của dự &aacute;n n&agrave;y th&igrave; v&agrave;o thời đ&oacute; n&oacute; vẫn chủ yếu chỉ l&agrave; dự &aacute;n của một người.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>PHP/FI 2.0 được ch&iacute;nh thức c&ocirc;ng bố v&agrave;o th&aacute;ng 11 năm 1997, sau một thời gian kh&aacute; d&agrave;i chỉ được c&ocirc;ng bố dưới dạng c&aacute;c bản beta. Nhưng kh&ocirc;ng l&acirc;u sau đ&oacute;, n&oacute; đ&atilde; được thay thế bởi c&aacute;c bản alpha đầu ti&ecirc;n của PHP 3.0.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<h2><strong>PHP 3</strong></h2>\r\n\r\n<p>PHP 3.0 l&agrave; phi&ecirc;n bản đầu ti&ecirc;n cho ch&uacute;ng ta thấy một h&igrave;nh ảnh gần gũi với c&aacute;c phi&ecirc;n bản PHP m&agrave; ch&uacute;ng ta được biết ng&agrave;y nay. N&oacute; đ&atilde; được Andi Gutmans v&agrave; Zeev Suraski tạo ra năm 1997 sau khi viết lại ho&agrave;n to&agrave;n bộ m&atilde; nguồn trước đ&oacute;. L&yacute; do ch&iacute;nh m&agrave; họ đ&atilde; tạo ra phi&ecirc;n bản n&agrave;y l&agrave; do nhận họ thấy PHP/FI 2.0 hết sức yếu k&eacute;m trong việc ph&aacute;t triển c&aacute;c ứng dụng thương mại điện tử m&agrave; họ đang x&uacute;c tiến trong một dự &aacute;n của trường đại học. Trong một nỗ lực hợp t&aacute;c v&agrave; bắt đầu x&acirc;y dựng dựa tr&ecirc;n cơ sở người d&ugrave;ng đ&atilde; c&oacute; của PHP/FI, Andi, Rasmus v&agrave; Zeev đ&atilde; quyết định hợp t&aacute;c v&agrave; c&ocirc;ng bố PHP 3.0 như l&agrave; phi&ecirc;n bản thế hệ kế tiếp của PHP/FI 2.0, v&agrave; chấm dứt ph&aacute;t triển PHP/FI 2.0.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Một trong những sức mạnh lớn nhất của PHP 3.0 l&agrave; c&aacute;c t&iacute;nh năng mở rộng mạnh mẽ của n&oacute;. Ngo&agrave;i khả năng cung cấp cho người d&ugrave;ng cuối một cơ sở hạ tầng chặt chẽ d&ugrave;ng cho nhiều cơ sở dữ liệu, giao thức v&agrave; API kh&aacute;c nhau, c&aacute;c t&iacute;nh năng mở rộng của PHP 3.0 đ&atilde; thu h&uacute;t rất nhiều nh&agrave; ph&aacute;t triển tham gia v&agrave; đề xuất c&aacute;c m&ocirc; đun mở rộng mới. Ho&agrave;n to&agrave;n c&oacute; thể kết luận được rằng đ&acirc;y ch&iacute;nh l&agrave; điểm mấu chốt dẫn đến th&agrave;nh c&ocirc;ng vang dội của PHP 3.0. C&aacute;c t&iacute;nh năng kh&aacute;c được giới thiệu trong PHP 3.0 gồm c&oacute; hỗ trợ c&uacute; ph&aacute;p hướng đối tượng v&agrave; nhiều c&uacute; ph&aacute;p ng&ocirc;n ngữ nhất qu&aacute;n kh&aacute;c.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Ng&ocirc;n ngữ ho&agrave;n to&agrave;n mới đ&atilde; được c&ocirc;ng bố dưới một c&aacute;i t&ecirc;n mới, x&oacute;a bỏ mối li&ecirc;n hệ với việc sử dụng v&agrave;o mục đ&iacute;ch c&aacute; nh&acirc;n hạn hẹp m&agrave; c&aacute;i t&ecirc;n PHP/FI 2.0 gợi nhắc. N&oacute; đ&atilde; được đặt t&ecirc;n ngắn gọn l&agrave; &#39;PHP&#39;, một kiểu viết tắt hồi quy của &quot;PHP: Hypertext Preprocessor&quot;.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>V&agrave;o cuối năm 1998, PHP đ&atilde; ph&aacute;t triển được con số c&agrave;i đặt l&ecirc;n tới h&agrave;ng chục ng&agrave;n người sử dụng v&agrave; h&agrave;ng chục ng&agrave;n Web site b&aacute;o c&aacute;o l&agrave; đ&atilde; c&agrave;i n&oacute;. V&agrave;o thời k&igrave; đỉnh cao, PHP 3.0 đ&atilde; được c&agrave;i đặt cho xấp xỉ 10% số m&aacute;y chủ Web c&oacute; tr&ecirc;n mạng Internet.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>PHP 3.0 đ&atilde; ch&iacute;nh thức được c&ocirc;ng bố v&agrave;o th&aacute;ng 6 năm 1998, sau thời gian 9 th&aacute;ng được cộng đồng kiểm nghiệm.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<h2><strong>PHP 4</strong></h2>\r\n\r\n<p>V&agrave;o m&ugrave;a đ&ocirc;ng năm 1998, ngay sau khi PHP 3.0 ch&iacute;nh thức được c&ocirc;ng bố, Andi Gutmans v&agrave; Zeev Suraski đ&atilde; bắt đầu bắt tay v&agrave;o việc viết lại phần l&otilde;i của PHP. Mục đ&iacute;ch thiết kế l&agrave; nhằm cải tiến tốc độ xử l&yacute; c&aacute;c ứng dụng phức tạp, v&agrave; cải tiến t&iacute;nh m&ocirc; đun của cơ sở m&atilde; PHP. Những ứng dụng như vậy đ&atilde; chạy được tr&ecirc;n PHP 3.0 dựa tr&ecirc;n c&aacute;c t&iacute;nh năng mới v&agrave; sự hỗ trợ kh&aacute; nhiều c&aacute;c cơ sở dữ liệu v&agrave; API của b&ecirc;n thứ ba, nhưng PHP 3.0 đ&atilde; kh&ocirc;ng được thiết kế để xử l&yacute; c&aacute;c ứng dụng phức tạp như thế n&agrave;y một c&aacute;ch c&oacute; hiệu quả.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Một động cơ mới, c&oacute; t&ecirc;n &#39;Zend Engine&#39; (gh&eacute;p từ c&aacute;c chữ đầu trong t&ecirc;n của Zeev v&agrave; Andi), đ&atilde; đ&aacute;p ứng được c&aacute;c nhu cầu thiết kế n&agrave;y một c&aacute;ch th&agrave;nh c&ocirc;ng, v&agrave; lần đầu ti&ecirc;n được giới thiệu v&agrave;o giữa năm 1999. PHP 4.0, dựa tr&ecirc;n động cơ n&agrave;y, v&agrave; đi k&egrave;m với h&agrave;ng loạt c&aacute;c t&iacute;nh năng mới bổ sung, đ&atilde; ch&iacute;nh thức được c&ocirc;ng bố v&agrave;o th&aacute;ng 5 năm 2000, gần 2 năm sau khi bản PHP 3.0 ra đời. Ngo&agrave;i tốc độ xử l&yacute; được cải thiện rất nhiều, PHP 4.0 đem đến c&aacute;c t&iacute;nh năng chủ yếu kh&aacute;c gồm c&oacute; sự hỗ trợ nhiều m&aacute;y chủ Web hơn, hỗ trợ phi&ecirc;n l&agrave;m việc HTTP, tạo bộ đệm th&ocirc;ng tin đầu ra, nhiều c&aacute;ch xử l&yacute; th&ocirc;ng tin người sử dụng nhập v&agrave;o bảo mật hơn v&agrave; cung cấp một v&agrave;i c&aacute;c cấu tr&uacute;c ng&ocirc;n ngữ mới.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Với PHP 4, số nh&agrave; ph&aacute;t triển d&ugrave;ng PHP đ&atilde; l&ecirc;n đến h&agrave;ng trăm ngh&igrave;n v&agrave; h&agrave;ng triệu site đ&atilde; c&ocirc;ng bố c&agrave;i đặt PHP, chiếm khoảng 20% số t&ecirc;n miền tr&ecirc;n mạng Internet.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Nh&oacute;m ph&aacute;t triển PHP cũng đ&atilde; l&ecirc;n tới con số h&agrave;ng ngh&igrave;n người v&agrave; nhiều ngh&igrave;n người kh&aacute;c tham gia v&agrave;o c&aacute;c dự &aacute;n c&oacute; li&ecirc;n quan đến PHP như PEAR, PECL v&agrave; t&agrave;i liệu kĩ thuật cho PHP.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<h2><strong>PHP 5</strong></h2>\r\n\r\n<p>Sự th&agrave;nh c&ocirc;ng hết sức to lớn của PHP 4.0 đ&atilde; kh&ocirc;ng l&agrave;m cho nh&oacute;m ph&aacute;t triển PHP tự m&atilde;n.Cộng đồng php đ&atilde; nhanh ch&oacute;ng gi&uacute;p họ nhận ra những yếu k&eacute;m của PHP 4 đặc biệt với khả năng hỗ trợ lập tr&igrave;nh hướng đối tượng (OOP), xử l&yacute; XML, kh&ocirc;ng hỗ trợ giao thức m&aacute;y kh&aacute;ch mới của MySQL 4.1 v&agrave; 5.0, hỗ trợ dịch vụ web yếu. Những điểm n&agrave;y ch&iacute;nh l&agrave; mục đ&iacute;ch để Zeev v&agrave; Andi viết Zend Engine 2.0, l&otilde;i của PHP 5.0. Một thảo luận tr&ecirc;n Slashdot đ&atilde; cho thấy việc ph&aacute;t triển PHP 5.0 c&oacute; thể đ&atilde; bắt đầu v&agrave;o thời điểm th&aacute;ng 12 năm 2002 nhưng những b&agrave;i phỏng vấn Zeev li&ecirc;n quan đến phi&ecirc;n bản n&agrave;y th&igrave; đ&atilde; c&oacute; mặt tr&ecirc;n mạng Internet v&agrave;o khoảng th&aacute;ng 7 năm 2002. Ng&agrave;y 29 th&aacute;ng 6 năm 2003, PHP 5 Beta 1 đ&atilde; ch&iacute;nh thức được c&ocirc;ng bố để cộng đồng kiểm nghiệm. Đ&oacute; cũng l&agrave; phi&ecirc;n bản đầu ti&ecirc;n của Zend Engine 2.0. Phi&ecirc;n bản Beta 2 sau đ&oacute; đ&atilde; ra mắt v&agrave;o th&aacute;ng 10 năm 2003 với sự xuất hiện của hai t&iacute;nh năng rất được chờ đợi: Iterators, Reflection nhưng namespaces một t&iacute;nh năng g&acirc;y tranh c&atilde;i kh&aacute;c đ&atilde; bị loại khỏi m&atilde; nguồn. Ng&agrave;y 21 th&aacute;ng 12 năm 2003: PHP 5 Beta 3 đ&atilde; được c&ocirc;ng bố để kiểm tra với việc ph&acirc;n phối k&egrave;m với Tidy, bỏ hỗ trợ Windows 95, khả năng gọi c&aacute;c h&agrave;m PHP b&ecirc;n trong XSLT, sửa chữa nhiều lỗi v&agrave; th&ecirc;m kh&aacute; nhiều h&agrave;m mới. PHP 5 bản ch&iacute;nh thức đ&atilde; ra mắt ng&agrave;y 13 th&aacute;ng 7 năm 2004 sau một chuỗi kh&aacute; d&agrave;i c&aacute;c bản kiểm tra thử bao gồm Beta 4, RC 1, RC2, RC3. Mặc d&ugrave; coi đ&acirc;y l&agrave; phi&ecirc;n bản sản xuất đầu ti&ecirc;n nhưng PHP 5.0 vẫn c&ograve;n một số lỗi trong đ&oacute; đ&aacute;ng kể l&agrave; lỗi x&aacute;c thực HTTP.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Ng&agrave;y 14 th&aacute;ng 7 năm 2005, PHP 5.1 Beta 3 được PHP Team c&ocirc;ng bố đ&aacute;nh dấu sự ch&iacute;n muồi mới của PHP với sự c&oacute; mặt của PDO, một nỗ lực trong việc tạo ra một hệ thống API nhất qu&aacute;n trong việc truy cập cơ sở dữ liệu v&agrave; thực hiện c&aacute;c c&acirc;u truy vấn. Ngo&agrave;i ra, trong PHP 5.1, c&aacute;c nh&agrave; ph&aacute;t triển PHP tiếp tục c&oacute; những cải tiến trong nh&acirc;n Zend Engine 2, n&acirc;ng cấp m&ocirc; đun PCRE l&ecirc;n bản PCRE 5.0 c&ugrave;ng những t&iacute;nh năng v&agrave; cải tiến mới trong SOAP, streams v&agrave; SP</p>\r\n\r\n<p>&nbsp;PHP 6</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Hiện nay phi&ecirc;n bản tiếp theo của PHP đang được ph&aacute;t triển, PHP 6 bản sử dụng thử đ&atilde; c&oacute; thể được download tại địa chỉ http://snaps.php.net. Phi&ecirc;n bản PHP 6 được kỳ vọng sẽ lấp đầy những khiếm khuyết của PHP ở phi&ecirc;n bản hiện tại, v&iacute; dụ: hỗ trợ namespace (hiện tại c&aacute;c nh&agrave; ph&aacute;t triển vẫn chưa c&ocirc;ng bố r&otilde; r&agrave;ng về vấn đề n&agrave;y); hỗ trợ Unicode; sử dụng PDO l&agrave;m API chuẩn cho việc truy cập cơ sở dữ liệu, c&aacute;c API cũ sẽ bị đưa ra th&agrave;nh thư viện PECL...</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<h2><strong>Sự hưởng ứng PHP ở Việt&nbsp;Nam</strong></h2>\r\n\r\n<p>Mặc d&ugrave; đ&acirc;y PHP 5 được coi l&agrave; đ&atilde; sẵn s&agrave;ng cho doanh nghiệp nhưng sự chấp nhận PHP vẫn tiến triển kh&aacute; chậm chạp đặc biệt l&agrave; ở Việt&nbsp;Nam. Nhưng những nỗ lực đầu ti&ecirc;n để phổ biến PHP trong đ&oacute; c&oacute; dự &aacute;n x&acirc;y dựng Quy tắc viết m&atilde; PHP tiếng Việt đ&atilde; được x&uacute;c tiến. Ng&agrave;y 24 th&aacute;ng 10 năm 2004, nh&oacute;m PHPVietnam đ&atilde; đề xuất x&acirc;y dựng PHPVietnam Mailing List đầu ti&ecirc;n tr&ecirc;n Google Groups tại địa chỉ: http://groups-beta.google.com/group/phpvietnam. Tại đ&acirc;y cũng đ&atilde; diễn ra những thảo luận để x&acirc;y dựng diễn đ&agrave;n cho cộng đồng PHP Việt&nbsp;Nam.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<h2><strong>Đ&oacute;ng g&oacute;p của người Việt cho cộng đồng PHP thế giới</strong></h2>\r\n\r\n<p>Người Việt chưa đ&oacute;ng g&oacute;p được g&igrave; nhiều. Chủ yếu sự tham gia của người Việt l&agrave; th&ocirc;ng qua việc dịch c&aacute;c tập tin ng&ocirc;n ngữ v&agrave; dựa tr&ecirc;n những ứng dụng PHP sẵn c&oacute; với c&aacute;c sửa đổi để tạo n&ecirc;n c&aacute;c hệ thống th&ocirc;ng tin thuần Việt như NukeViet của nh&oacute;m NukeViet.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Đ&oacute;ng g&oacute;p lớn nhất ghi nhận đến hiện nay l&agrave; sự xuất hiện của PHP Designer 2006 do Michael Pham (quốc tịch Việt&nbsp;Nam&nbsp;v&agrave; Đan Mạch) x&acirc;y dựng. Địa chỉ: http://www.mpsoftware.dk/ hoặc http://www.mpsoftware.eu/</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Ngo&agrave;i ra c&oacute; nhiều m&atilde; nguồn mở viết bằng PHP được người Việt Nam sử dụng nhiều, chẳng hạn như m&atilde; nguồn Xtremedia l&agrave; một hệ thống web giải tr&iacute; được gọi tắt l&agrave; &quot;web nhạc&quot;, do t&aacute;c giả L&ecirc; Thanh Minh Qu&acirc;n (biệt danh tr&ecirc;n mạng l&agrave; redphoenix89) viết v&agrave; ph&aacute;t triển. N&oacute; được ưa chuộng v&igrave; m&atilde; nguồn đơn giản, giao diện bắt mắt, tốc độ nhanh, dung lượng nhẹ (file n&eacute;n của to&agrave;n source chỉ c&oacute; 112kb - bản 1.1) v&agrave; đặc biệt l&agrave; ho&agrave;n to&agrave;n miễn ph&iacute;. Nhưng k&egrave;m theo đ&oacute; l&agrave; rất nhiều lỗi chưa được sửa.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Một số m&atilde; nguồn kh&aacute;c l&agrave; SosoVN của t&aacute;c giả Nguyễn T&ocirc;n Viễn, hay RCMS của Nguyễn Thanh Giang An đều l&agrave; dạng CMS, tuy nhi&ecirc;n c&aacute;c CMS n&agrave;y chỉ ph&aacute;t h&agrave;nh bản thương mại v&agrave; do đ&oacute; &iacute;t được ph&aacute;t triển &amp; sử dụng.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><br />\r\nCộng đồng người Việt hiện nay cũng cho ra đời kh&aacute; nhiều script miễn ph&iacute; PHP để gi&uacute;p ph&aacute;t triển PHP ở Việt&nbsp;Nam.</p>\r\n\r\n<p><a href="http://4.bp.blogspot.com/-RfsB75pyQcw/VhEzIbw_tRI/AAAAAAAAAH8/097a9XG1Wpk/s1600/Screenshot%2B%252817%2529.png"><img src="http://4.bp.blogspot.com/-RfsB75pyQcw/VhEzIbw_tRI/AAAAAAAAAH8/097a9XG1Wpk/s320/Screenshot%2B%252817%2529.png" style="height:179px; width:320px" /></a></p>\r\n\r\n<p><br />\r\n<br />\r\nĐể c&agrave;i đặt PHP, c&oacute; thể c&agrave;i đặt từng g&oacute;i ri&ecirc;ng lẻ (PHP, Apache, Mysql). Tuy nhi&ecirc;n em sử dụng bản c&agrave;i đặt dạng g&oacute;i t&iacute;ch hợp. việc c&agrave;i đặt g&oacute;i phần mềm t&iacute;ch hợp sẽ tiện lợi cho c&ocirc;ng việc sau n&agrave;y hơn rất nhiều.G&oacute;i phần mềm m&agrave; em chọn l&agrave; : xampp-win32-1.7.3 phi&ecirc;n bản d&agrave;nh cho window.</p>\r\n', '/admin/images_cm/php.png', 39, '2015-11-01', 19, 1, NULL),
(2, 'tổng quan về lập trình PHP', '<p><strong>Ở phần trước ch&uacute;ng ta đ&atilde; t&igrave;m hiểu về c&aacute;ch thức cấu h&igrave;nh v&agrave; c&agrave;i đặt PHP. Tiếp theo ch&uacute;ng ta sẽ nghi&ecirc;n cứu về cấu tr&uacute;c cơ bản trong PHP. Về tổng quan PHP c&oacute; c&uacute; ph&aacute;p kh&aacute; tương đồng với 1 số ng&ocirc;n ngữ như C, java. Tuy nhi&ecirc;n, tự bản th&acirc;n ch&uacute;ng cũng c&oacute; những điểm rất ri&ecirc;ng biệt.</strong><br />\r\n<a name="more"></a></p>\r\n\r\n<h2><strong>2.1- Cấu tr&uacute;c cơ bản:</strong>&nbsp;</h2>\r\n\r\n<p>PHP cũng c&oacute; thẻ bắt đầu v&agrave; kết th&uacute;c giống với ng&ocirc;n ngữ HTML. Chỉ kh&aacute;c, đối với PHP ch&uacute;ng ta c&oacute; nhiều c&aacute;ch để thể hiện.</p>\r\n\r\n<p><strong>C&aacute;ch 1 :&nbsp;</strong>C&uacute; ph&aacute;p ch&iacute;nh:</p>\r\n\r\n<p>&lt;?php M&atilde; lệnh PHP ?&gt;</p>\r\n\r\n<p><strong>C&aacute;ch 2:&nbsp;</strong>C&uacute; ph&aacute;p ngắn gọn</p>\r\n\r\n<p>&lt;? M&atilde; lệnh PHP ?&gt;</p>\r\n\r\n<p><strong>C&aacute;ch 3:</strong>&nbsp;C&uacute; ph&aacute;p giống với ASP.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&lt;% M&atilde; lệnh PHP %&gt;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>C&aacute;ch 4:&nbsp;</strong>C&uacute; ph&aacute;p bắt đầu bằng script</p>\r\n\r\n<p>&lt;script language=php&gt;</p>\r\n\r\n<p>.....</p>\r\n\r\n<p>&lt;/script&gt;</p>\r\n\r\n<p>Mặc d&ugrave; c&oacute; 4 c&aacute;ch thể hiện. Nhưng đối với 1 lập tr&igrave;nh vi&ecirc;n c&oacute; kinh nghiệm th&igrave; việc sử dụng c&aacute;ch 1 vẫn l&agrave; lựa chon tối ưu.</p>\r\n\r\n<p>Trong PHP để kết th&uacute;c 1 d&ograve;ng lệnh ch&uacute;ng ta sử dụng dấu &quot;;&quot;</p>\r\n\r\n<p>Để ch&uacute; th&iacute;ch 1 đoạn dữ liệu n&agrave;o đ&oacute; trong PHP ta sử dụng dấu &quot;//&quot; cho từng d&ograve;ng. Hoặc d&ugrave;ng cặp thẻ &quot;/*&hellip;&hellip;..*/&quot; cho từng cụm m&atilde; lệnh.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<h2><strong>2.2- Xuất gi&aacute; trị ra tr&igrave;nh duyệt:</strong></h2>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Để xuất dữ liệu ra tr&igrave;nh duyệt ch&uacute;ng ta c&oacute; những d&ograve;ng c&uacute; ph&aacute;p sau :<br />\r\n+ Echo &quot;Th&ocirc;ng tin&quot;;<br />\r\n+ Printf &quot;Th&ocirc;ng tin&quot;;<br />\r\n<br />\r\nTh&ocirc;ng tin bao gồm : biến, chuỗi, hoặc lệnh HTML &hellip;.<br />\r\nNễu giữa hai chuỗi muốn li&ecirc;n kết với nhau ta sử dụng dấu &quot;.&quot;</p>\r\n', '/admin/images_cm/php.png', 39, '2015-11-01', 0, 1, NULL),
(3, '[PHP] Khái niệm biến, hằng, chuỗi và các kiểu dữ liệu trong lập trình PHP', '<h2><em>a) Biến trong PHP.</em></h2>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Biến được xem l&agrave; v&ugrave;ng nhớ dữ liệu tạm thời. V&agrave; gi&aacute; trị c&oacute; thể thay đổi được. Biến được bắt đầu bằng k&yacute; hiệu &quot;$&quot;. V&agrave; theo sau ch&uacute;ng l&agrave; 1 từ, 1 cụm từ nhưng phải viết liền hoặc c&oacute; gạch dưới.</p>\r\n\r\n<p>1 biến được xem l&agrave; hợp lệ khi n&oacute; thỏa c&aacute;c yếu tố :</p>\r\n\r\n<p>+ T&ecirc;n của biến phải bắt đầu bằng dấu gạch dưới v&agrave; theo sau l&agrave; c&aacute;c k&yacute; tự, số hay dấu gạch dưới.</p>\r\n\r\n<p>+ T&ecirc;n của biến kh&ocirc;ng được ph&eacute;p tr&ugrave;ng với c&aacute;c từ kh&oacute;a của PHP.</p>\r\n\r\n<p><a name="more"></a></p>\r\n\r\n<p>Trong PHP để sử dụng 1 biến ch&uacute;ng ta thường phải khai b&aacute;o trước, tuy nhi&ecirc;n đối với c&aacute;c lập tr&igrave;nh vi&ecirc;n khi sử dụng họ thường xử l&yacute; c&ugrave;ng một l&uacute;c c&aacute;c c&ocirc;ng việc, nghĩa l&agrave; vừa kh&aacute;i b&aacute;o vừa g&aacute;n dữ liệu cho biến.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Bản th&acirc;n biến cũng c&oacute; thể g&atilde;n cho c&aacute;c kiểu dữ liệu kh&aacute;c. V&agrave; t&ugrave;y theo &yacute; định của người lập tr&igrave;nh mong muốn tr&ecirc;n ch&uacute;ng.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<h2><em>b) Kh&aacute;i niệm về hằng trong PHP.</em></h2>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Nếu biến l&agrave; c&aacute;i c&oacute; thể thay đổi được th&igrave; ngược lại hằng l&agrave; c&aacute;i ch&uacute;ng ta kh&ocirc;ng thể thay đổi được. Hằng trong PHP được định nghĩa bởi h&agrave;m define theo c&uacute; ph&aacute;p: define (string t&ecirc;n_hằng, gi&aacute;_trị_hằng ).</p>\r\n\r\n<p>Cũng giống với biến hằng được xem l&agrave; hợp lệ th&igrave; ch&uacute;ng phải đ&aacute;p ứng 1 số yếu tố :</p>\r\n\r\n<p>+ Hằng kh&ocirc;ng c&oacute; dấu &quot;$&quot; ở trước t&ecirc;n.</p>\r\n\r\n<p>+ Hằng c&oacute; thể truy cập bất cứ vị tr&iacute; n&agrave;o trong m&atilde; lệnh</p>\r\n\r\n<p>+ Hằng chỉ được ph&eacute;p g&aacute;n gi&aacute; trị duy nhất 1 lần.</p>\r\n\r\n<p>+ Hằng thường viết bằng chữ in để ph&acirc;n biệt với biến</p>\r\n\r\n<h2><em>c) Kh&aacute;i niệm về chuỗi:</em></h2>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Chuỗi l&agrave; một nh&oacute;m c&aacute;c kỹ tự, số, khoảng trắng, dấu ngắt được đặt trong c&aacute;c dấu nh&aacute;y.</p>\r\n\r\n<p>V&iacute; dụ:</p>\r\n\r\n<p>&lsquo;Huy&rsquo;</p>\r\n\r\n<p>&quot;welcome to&nbsp;VietNam&quot;</p>\r\n\r\n<p>Để tạo 1 biễn chuỗi, ch&uacute;ng ta phải g&aacute;n gi&aacute; trị chuỗi cho 1 biến hợp lệ.</p>\r\n\r\n<p>V&iacute; dụ:</p>\r\n\r\n<p>$fisrt_name= &quot;Nguyen&quot;;</p>\r\n\r\n<p>$last_name= &lsquo;Van A&rsquo;;</p>\r\n\r\n<p>Để li&ecirc;n kết 1 chuỗi v&agrave; 1 biến ch&uacute;ng ta thường sử dụng dấu &quot;.&quot;</p>\r\n\r\n<h2><em>d) Kiểu dữ liệu trong PHP</em></h2>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>C&aacute;c kiểu dữ liệu kh&aacute;c nhau chiếm c&aacute;c lượng bộ nhớ kh&aacute;c nhau v&agrave; c&oacute; thể được xử l&yacute; theo c&aacute;ch kh&aacute;c nhau khi ch&uacute;ng được theo t&aacute;c trong 1 script.</p>\r\n\r\n<p>Trong PHP ch&uacute;ng ta c&oacute; 6 kiểu dữ liệu ch&iacute;nh như sau :</p>\r\n\r\n<table border="1" cellpadding="0" cellspacing="0">\r\n	<tbody>\r\n		<tr>\r\n			<td style="width:197px">\r\n			<p>Kiểu dữ liệu</p>\r\n			</td>\r\n			<td style="width:197px">\r\n			<p>V&iacute; dụ</p>\r\n			</td>\r\n			<td style="width:197px">\r\n			<p>M&ocirc; tả</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td style="width:197px">\r\n			<p>Integer</p>\r\n			</td>\r\n			<td style="width:197px">\r\n			<p>10</p>\r\n			</td>\r\n			<td style="width:197px">\r\n			<p>Một số nguy&ecirc;n</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td style="width:197px">\r\n			<p>Double</p>\r\n			</td>\r\n			<td style="width:197px">\r\n			<p>5,123</p>\r\n			</td>\r\n			<td style="width:197px">\r\n			<p>Kiểu số thực</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td style="width:197px">\r\n			<p>String</p>\r\n			</td>\r\n			<td style="width:197px">\r\n			<p>&ldquo;hello world&rdquo;</p>\r\n			</td>\r\n			<td style="width:197px">\r\n			<p>Kiểu chuỗi</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td style="width:197px">\r\n			<p>Boolean</p>\r\n			</td>\r\n			<td style="width:197px">\r\n			<p>True or false</p>\r\n			</td>\r\n			<td style="width:197px">\r\n			<p>Gi&aacute; trị true or false</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td style="width:197px">\r\n			<p>Ofject</p>\r\n			</td>\r\n			<td colspan="2" style="width:394px">\r\n			<p>Hướng đối tượng trong PHP</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td style="width:197px">\r\n			<p>Array</p>\r\n			</td>\r\n			<td colspan="2" style="width:394px">\r\n			<p>Mảng trong PHP</p>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Ch&uacute;ng ta c&oacute; thể sử dụng h&agrave;m dựng sẵn&nbsp;gettype()&nbsp;của PHP4 để kiểm tra kiểu của bất kỳ biến.</p>\r\n\r\n<p><em>Sau b&agrave;i n&agrave;y c&aacute;c bạn đ&atilde; c&oacute; những kh&aacute;i niệm đầu ti&ecirc;n về PHP, c&aacute;c c&uacute; ph&aacute;p, c&aacute;c kiểu dữ liệu, v&agrave; c&aacute;ch l&agrave;m việc với m&ocirc;i trường PHP như thế n&agrave;o. Ở b&agrave;i sau, ch&uacute;ng ta sẽ tiếp tục tiếp cận với c&aacute;c thuật to&aacute;n v&agrave; c&uacute; ph&aacute;p PHP một c&aacute;ch r&otilde; r&agrave;ng v&agrave; quen thuộc trong c&aacute;c ng&ocirc;n ngữ lập tr&igrave;nh.</em></p>\r\n', '/admin/images_cm/php.png', 39, '2015-11-01', 2, 1, NULL),
(5, 'toán tử trong PHP - gán, so sánh, kết hợp, logic', '<h2>to&aacute;n tử g&aacute;n</h2>\r\n\r\n<p>Ch&uacute;ng ta đ&atilde; từng tiếp x&uacute;c với to&aacute;n tử n&agrave;y bởi việc khởi tạo 1 biến. N&oacute; gồm k&yacute; tự đơn =. To&aacute;n tử g&aacute;n lấy gi&aacute; trị của to&aacute;n hạng b&ecirc;n phải g&aacute;n n&oacute; v&agrave;o to&aacute;n hạng b&ecirc;n tr&aacute;i.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>V&iacute; dụ:</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>$name = &quot;Johny Nguyen&quot;;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<h2>to&aacute;n tử số học</h2>\r\n\r\n<p>L&agrave; dạng ph&eacute;p t&iacute;nh giản đơn cộng, trừ, nh&acirc;n, chia trong số học. Ngo&agrave;i ra c&ograve;n c&oacute; ph&eacute;p chia lấy dư (%). Được sử dụng để lấy ra đơn vị dư của 1 ph&eacute;p to&aacute;n.</p>\r\n\r\n<p><a href="http://3.bp.blogspot.com/-LbmgCJ-YXKc/VhKHvj3DsII/AAAAAAAAAJA/0PcntED1nwk/s1600/image012.gif"><img src="http://3.bp.blogspot.com/-LbmgCJ-YXKc/VhKHvj3DsII/AAAAAAAAAJA/0PcntED1nwk/s640/image012.gif" style="height:185px; width:640px" /></a></p>\r\n\r\n<h2>to&aacute;n tử so s&aacute;nh</h2>\r\n\r\n<p>L&agrave; to&aacute;n tử được sử dụng để thực hiện c&aacute;c ph&eacute;p to&aacute;n so s&aacute;nh giữa hai số hạng. Chi tiết, xem bảng b&ecirc;n dưới.</p>\r\n\r\n<p><a href="http://4.bp.blogspot.com/-gsT0GUbtPoE/VhKH9mgDFKI/AAAAAAAAAJI/nCPnEwvrvAo/s1600/image013.gif"><img src="http://4.bp.blogspot.com/-gsT0GUbtPoE/VhKH9mgDFKI/AAAAAAAAAJI/nCPnEwvrvAo/s640/image013.gif" style="height:254px; width:640px" /></a></p>\r\n\r\n<h2>to&aacute;n tử logic</h2>\r\n\r\n<p>To&aacute;n tử logic l&agrave; c&aacute;c tổ hợp c&aacute;c gi&aacute; trị boolean.</p>\r\n\r\n<p>V&iacute; dụ:&nbsp;to&aacute;n tử or trở về true nếu to&aacute;n tử tr&aacute;i hoặc to&aacute;n tử phải l&agrave; true.</p>\r\n\r\n<p>True || false &agrave; true.</p>\r\n\r\n<p>Ta c&oacute; bảng c&aacute;c to&aacute;n tử như sau:</p>\r\n\r\n<p><a href="http://3.bp.blogspot.com/-sptPy8xki_M/VhKIgQ0YvwI/AAAAAAAAAJQ/WPOydeUANAM/s1600/image014.gif"><img src="http://3.bp.blogspot.com/-sptPy8xki_M/VhKIgQ0YvwI/AAAAAAAAAJQ/WPOydeUANAM/s640/image014.gif" style="height:272px; width:640px" /></a></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<h2>to&aacute;n tử kết hợp</h2>\r\n\r\n<p>Khi tạo m&atilde; PHP, ch&uacute;ng ta sẽ thường nhận thấy cần phải tăng hoặc giảm lượng biến một số nguy&ecirc;n n&agrave;o đ&oacute;. Bạn sẽ thường thực hiện điều n&agrave;y khi ch&uacute;ng ta đếm 1 gi&aacute; trị n&agrave;o đ&oacute; trong v&ograve;ng lặp.</p>\r\n\r\n<p><a href="http://3.bp.blogspot.com/-DkZf4fhPuJk/VhKI0f2aMjI/AAAAAAAAAJY/YaJ6Vz-b-YU/s1600/image015.gif"><img src="http://3.bp.blogspot.com/-DkZf4fhPuJk/VhKI0f2aMjI/AAAAAAAAAJY/YaJ6Vz-b-YU/s640/image015.gif" style="height:338px; width:640px" /></a></p>\r\n', '/admin/images_cm/php.png', 39, '2015-11-01', 0, 1, NULL),
(6, 'các biểu thức cơ bản trong PHP', '<h2>biểu thức điều kiện</h2>\r\n\r\n<p>L&agrave; biểu thức d&ugrave;ng kiểm tra 1 sự kiện. Nếu ch&uacute;ng thỏa điều kiện đ&oacute; th&igrave; sẽ thực thi một h&agrave;nh động. Ngược lại sẽ l&agrave; một h&agrave;nh động kh&aacute;c.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>If(Điều kiện)</p>\r\n\r\n<p>{</p>\r\n\r\n<p>h&agrave;nh động</p>\r\n\r\n<p>}</p>\r\n\r\n<p><a href="http://3.bp.blogspot.com/-6a63R-mzqd8/VhKLAl7snjI/AAAAAAAAAJk/Pf5zZUQ_JxI/s1600/image016.gif"><img src="http://3.bp.blogspot.com/-6a63R-mzqd8/VhKLAl7snjI/AAAAAAAAAJk/Pf5zZUQ_JxI/s640/image016.gif" style="height:288px; width:640px" /></a></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<h2>v&ograve;ng lặp trong PHP</h2>\r\n\r\n<p>Ph&eacute;p lặp n&agrave;y y&ecirc;u cầu phải thỏa m&atilde;n điều kiện th&igrave; mới thực thi được v&ograve;ng lặp</p>\r\n\r\n<p><strong>C&uacute; ph&aacute;p:</strong></p>\r\n\r\n<p>While(điều kiện)</p>\r\n\r\n<p>{</p>\r\n\r\n<p>H&agrave;nh động &ndash; thực thi</p>\r\n\r\n<p>}</p>\r\n\r\n<p>V&iacute; dụ:</p>\r\n\r\n<p><a href="http://1.bp.blogspot.com/-yyLZ7P01mSM/VhKLVxddMJI/AAAAAAAAAJs/FsArHGee1Wo/s1600/image017.gif"><img src="http://1.bp.blogspot.com/-yyLZ7P01mSM/VhKLVxddMJI/AAAAAAAAAJs/FsArHGee1Wo/s640/image017.gif" style="height:240px; width:640px" /></a></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>C&uacute; ph&aacute;p:</strong></p>\r\n\r\n<p>Do</p>\r\n\r\n<p>{</p>\r\n\r\n<p>H&agrave;nh động thực thi</p>\r\n\r\n<p>}while</p>\r\n\r\n<p>Ph&eacute;p lặp n&agrave;y sẽ thực thi h&agrave;nh động &iacute;t nhất l&agrave; một lần. Sau đ&oacute; mới tiến h&agrave;nh kiểm tra điều kiện.</p>\r\n\r\n<p><a href="http://4.bp.blogspot.com/-l-NbxeSGnaQ/VhKLlOVjtaI/AAAAAAAAAJ0/b16YD7qzXm8/s1600/image018.gif"><img src="http://4.bp.blogspot.com/-l-NbxeSGnaQ/VhKLlOVjtaI/AAAAAAAAAJ0/b16YD7qzXm8/s640/image018.gif" style="height:258px; width:640px" /></a></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>C&uacute; ph&aacute;p:</strong></p>\r\n\r\n<p>For( gi&aacute; trị ; điều kiện ; biến tăng hoặc giảm)</p>\r\n\r\n<p>{ H&agrave;nh động }</p>\r\n\r\n<p>Ph&eacute;p lặp n&agrave;y l&agrave; ph&eacute;p to&aacute;n gộp c&aacute;c tham số. Gi&uacute;p người lập tr&igrave;nh giảm thiểu thời gian phải khai b&aacute;o biến v&agrave; c&aacute;c tham số khi thực thi việc lặp dữ liệu.</p>\r\n\r\n<p><a href="http://2.bp.blogspot.com/-PmviyXkZcYw/VhKLzWkbJfI/AAAAAAAAAJ8/W6DEUmNUp-Q/s1600/image019.gif"><img src="http://2.bp.blogspot.com/-PmviyXkZcYw/VhKLzWkbJfI/AAAAAAAAAJ8/W6DEUmNUp-Q/s640/image019.gif" style="height:226px; width:640px" /></a></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<h2>biểu thức switch - case</h2>\r\n\r\n<p>L&agrave; biểu thức sử dụng để giảm thiểu qu&aacute; tr&igrave;nh xử l&yacute; dữ liệu nếu c&oacute; qu&aacute; nhiều ph&eacute;p to&aacute;n if else.</p>\r\n\r\n<p><strong>C&uacute; ph&aacute;p:</strong></p>\r\n\r\n<p>Switch(biến)</p>\r\n\r\n<p>{</p>\r\n\r\n<p>Case gi&aacute; trị 1: H&agrave;nh động; Break;</p>\r\n\r\n<p>&hellip;&hellip;&hellip;&hellip;</p>\r\n\r\n<p>Case gi&aacute; trị N: H&agrave;nh động; Break;</p>\r\n\r\n<p>Default: H&agrave;nh động; Break;</p>\r\n\r\n<p>}</p>\r\n\r\n<p><em>V&iacute; dụ:</em></p>\r\n\r\n<p><a href="http://2.bp.blogspot.com/-cPwhm0MHlM4/VhKMH127LNI/AAAAAAAAAKE/jTZUJZ9Kggs/s1600/image020.gif"><img src="http://2.bp.blogspot.com/-cPwhm0MHlM4/VhKMH127LNI/AAAAAAAAAKE/jTZUJZ9Kggs/s640/image020.gif" style="height:256px; width:640px" /></a></p>\r\n\r\n<p><strong>Tổng kết:</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Kết th&uacute;c b&agrave;i học n&agrave;y, c&aacute;c bạn &iacute;t nhiều đ&atilde; nắm được những thuộc t&iacute;nh cơ bản của c&aacute;c ph&eacute;p to&aacute;n học trong PHP, ngo&agrave;i ra ch&uacute;ng ta cũng từng bước hiểu được c&uacute; ph&aacute;p của từng biểu thức.</p>\r\n\r\n<p><br />\r\nĐối với c&aacute;c v&ograve;ng lặp, ch&uacute;ng ta cần hiểu v&agrave; vận ch&uacute;ng một c&aacute;ch linh hoạt v&agrave; mềm dẻo, ph&acirc;n biệt được while v&agrave; do&hellip;while. Sử dụng h&agrave;m switch trong trường hợp c&oacute; qu&aacute; nhiều gi&aacute; trị if&hellip;else trả về.</p>\r\n', '/admin/images_cm/php.png', 39, '2015-11-01', 3, 1, NULL),
(7, 'lập trình trên file trong PHP', '<p><strong>Một trong những t&aacute;c vụ đặc biệt của PHP đ&oacute; l&agrave; cho ph&eacute;p xử l&yacute; dữ liệu trực tiếp th&ocirc;ng qua qu&aacute; tr&igrave;nh nhận v&agrave; đọc nội dung tr&ecirc;n 1 file dữ liệu. Điều n&agrave;y gi&uacute;p cho PHP trở n&ecirc;n tinh tế v&agrave; dễ t&ugrave;y biến hơn khi xử l&yacute; 1 lượng dữ liệu c&oacute; quy m&ocirc; lớn. Việc thao t&aacute;c mở, đọc, ghi, đ&oacute;ng file n&agrave;y cũng c&oacute; &yacute; nghĩa tuần tự như bạn đang l&agrave;m việc trực tiếp tr&ecirc;n 1 file dữ liệu thực thụ.</strong></p>\r\n\r\n<h2>&nbsp;</h2>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>đ&oacute;ng mở 1 file trong PHP</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Để mở 1 file ta sử dụng c&uacute; ph&aacute;p sau: fopen(&quot;Đường dẫn&quot;, thuộc t&iacute;nh).<br />\r\nTrong đ&oacute; Đường dẫn ch&iacute;nh l&agrave; đường dẫn tới file cần mở.<br />\r\nThuộc t&iacute;nh bao gồm c&aacute;c quyền hạn cho ph&eacute;p thao t&aacute;c tr&ecirc;n file đ&oacute; như thế n&agrave;o.</p>\r\n\r\n<p>C&aacute;c thuộc t&iacute;nh cơ bản :</p>\r\n\r\n<p><a href="http://1.bp.blogspot.com/-VFwOj0PiQ_E/VhKPv7-ezRI/AAAAAAAAAKQ/JiY74r_zkH4/s1600/image025.gif"><img src="http://1.bp.blogspot.com/-VFwOj0PiQ_E/VhKPv7-ezRI/AAAAAAAAAKQ/JiY74r_zkH4/s640/image025.gif" style="height:412px; width:640px" /></a></p>\r\n\r\n<p>V&iacute; dụ:</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&lt;?php<br />\r\n$fp=fopen(&quot;test.txt&quot;,r)or exit(&quot;khong tim thay file can mo&quot;);<br />\r\n?&gt;</p>\r\n\r\n<p>Tương tự như thế, để đ&oacute;ng 1 file ta c&oacute; c&uacute; ph&aacute;p như sau: fclose(file vừa mở)</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>V&iacute; dụ:</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&lt;?php<br />\r\n$fp=fopen(&quot;test.txt&quot;,r)or exit(&quot;khong tim thay file can mo&quot;);<br />\r\nfclose($fp);<br />\r\n?&gt;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Việc mở v&agrave; đ&oacute;ng n&agrave;y kh&ocirc;ng c&oacute; &yacute; nghĩa l&agrave; ch&uacute;ng đ&atilde; được đọc. Muốn đọc được nội dung của file ch&uacute;ng ta lại tiếp tục với thao t&aacute;c lấy dữ liệu từ file nữa.</p>\r\n\r\n<h2>đọc 1 file trong PHP</h2>\r\n\r\n<p>PHP cho ta nhiều sự lựa chọn trong việc đọc 1 file. C&oacute; nhiều h&igrave;nh thức hỗ trợ nhưng hiện nay 2 h&igrave;nh thức phổ biến nhất vẫn l&agrave; đọc file theo từng d&ograve;ng v&agrave; đọc file theo từng k&yacute; tự.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>- Đọc file theo từng d&ograve;ng:</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>C&uacute; ph&aacute;p : fgets(file vừa mở).</p>\r\n\r\n<p>V&iacute; dụ:</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&lt;?php<br />\r\n$fp=fopen(&quot;test.txt&quot;,r)or exit(&quot;khong tim thay file can mo&quot;);<br />\r\necho fgets($fp);<br />\r\nfclose($fp);<br />\r\n?&gt;</p>\r\n\r\n<p>- Đọc file theo từng k&yacute; tự:</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>C&uacute; ph&aacute;p : fgetc(file vừa mở).</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>V&iacute; dụ:</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&lt;?php<br />\r\n$fp=fopen(&quot;test.txt&quot;,r)or exit(&quot;khong tim thay file can mo&quot;);<br />\r\necho fgetc($fp);<br />\r\nfclose($fp);<br />\r\n<br />\r\n?&gt;</p>\r\n\r\n<p>Quy tr&igrave;nh đọc sẽ diễn ra theo từng y&ecirc;u cầu của c&uacute; ph&aacute;p sử dụng. Nhưng sẽ c&oacute; sự r&agrave;ng buộc bởi việc kiểm tra đ&atilde; đến cuối file chưa ?.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Ở đ&acirc;y ch&uacute;ng ta d&ugrave;ng c&uacute; ph&aacute;p sau:&nbsp;feof(file vừa mở)</p>\r\n\r\n<p>V&iacute; dụ:</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&lt;?php<br />\r\n$fp=fopen(&quot;test.txt&quot;,r)or exit(&quot;khong tim thay file can mo&quot;);<br />\r\nwhile(!feof($fp))<br />\r\n{<br />\r\necho fgets($fp);<br />\r\n}<br />\r\nfclose($fp);<br />\r\n<br />\r\n?&gt;</p>\r\n\r\n<h2>ghi file trong PHP</h2>\r\n\r\n<p>PHP cung cấp cho ta 1 c&uacute; ph&aacute;p nhỏ để ghi dữ liệu v&agrave;o 1file<br />\r\nC&uacute; ph&aacute;p cơ bản :&nbsp;fwrite(&quot;file vừa mở&quot;, &quot;Nội dung cần ghi v&agrave;o file&quot;)</p>\r\n\r\n<p>V&iacute; dụ:</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&lt;?php<br />\r\n$fp=fopen(&quot;test.txt&quot;,a)or exit(&quot;khong tim thay file can mo&quot;);<br />\r\n$news=&quot;Trung Tam Tin hoc Viet Chuyenn&quot;;<br />\r\nfwrite($fp,$news);<br />\r\nfclose($fp);<br />\r\n?&gt;</p>\r\n\r\n<p><em>Tổng kết:</em></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><em>Việc sử dụng file một c&aacute;ch th&agrave;nh thạo sẽ gi&uacute;p bạn dễ d&agrave;ng vận h&agrave;nh c&aacute;c ứng dụng mang quy m&ocirc; vừa v&agrave; nhỏ như: website nhiều ng&ocirc;n ngữ, bộ đếm,&hellip;v&agrave; cả những c&ocirc;ng nghệ web mới như XML một c&aacute;ch dễ d&agrave;ng. Qua b&agrave;i học n&agrave;y ch&uacute;ng ta cũng hiểu được nguy&ecirc;n l&yacute; hoạt động, tr&igrave;nh tự xử l&yacute; 1 file dữ liệu khi ch&uacute;ng được triệu gọi trong t&agrave;i liệu PHP.&nbsp;</em></p>\r\n', '/admin/images_cm/php.png', 39, '2015-11-01', 3, 1, NULL),
(8, 'mảng trong PHP - khai báo và các hàm hổ trợ sẵn trên mảng PHP', '<h2>1. định nghĩa mảng trong PHP</h2>\r\n\r\n<p>c&uacute; ph&aacute;p:&nbsp;$t&ecirc;n_biến = array (&quot;gi&aacute; trị 1&quot;, &quot;gi&aacute; trị 2&quot;, &quot;gi&aacute; trị n&quot;,...);<br />\r\nmảng trong PHP n&oacute; t&iacute;nh từ 0 -&gt; n-1.<br />\r\nv&iacute; dụ: $a=array(1,2,3,4,5);<br />\r\nth&igrave; khi muốn in ra gi&aacute; trị 3 th&igrave; d&ugrave;ng lệnh echo $a[2];<br />\r\nngo&agrave;i c&aacute;ch khai b&aacute;o mảng ở tr&ecirc;n, PHP c&ograve;n hổ trợ c&aacute;ch khai b&aacute;o mảng sau:<br />\r\n$a[]=1;<br />\r\n$a[]=2;<br />\r\n$a[]=3;<br />\r\n.......<br />\r\n<a name="more"></a><br />\r\nnhư vậy, c&aacute;ch khai b&aacute;o thứ 2 thường d&ugrave;ng trong việc th&ecirc;m gi&aacute; trị v&agrave;o mảng, c&ograve;n c&aacute;ch 1 l&agrave; khai b&aacute;o mảng với c&aacute;c gi&aacute; trị ban đầu<br />\r\ncũng giống như c&aacute;ch 1, muốn in ra gi&aacute; trị 3 th&igrave; echo $a[2];<br />\r\n&nbsp;</p>\r\n\r\n<h2>2. mảng kết hợp</h2>\r\n\r\n<p>v&iacute; dụ mảng kết hợp sau th&igrave; c&aacute;c bạn sẽ r&otilde; n&oacute; l&agrave; như thế n&agrave;o:<br />\r\n$a=array(name =&gt; &quot;tran khanh toan&quot;, job =&gt; &quot;student&quot;, age =&gt; 20);<br />\r\nmuốn in ra tran khanh toan, student hay tuổi l&agrave; 20 th&igrave; d&ugrave;ng lệnh sau:<br />\r\necho $a[name];<br />\r\necho $a[job];<br />\r\necho $a[age];<br />\r\n&nbsp;v&agrave; lưu &yacute; l&agrave; ở đ&acirc;y kh&ocirc;ng thể d&ugrave;ng c&aacute;ch truy xuất dữ liệu mảng theo c&aacute;ch th&ocirc;ng thường echo $a[0];echo $a[1];... được.<br />\r\n&nbsp;</p>\r\n\r\n<h2>&nbsp;3.ph&eacute;p lặp trong mảng</h2>\r\n\r\n<p>&nbsp;a. đối với mảng th&ocirc;ng thường<br />\r\n&nbsp;foreach ( $array as $temp)<br />\r\n&nbsp;{<br />\r\n&nbsp; &nbsp;h&agrave;nh động;<br />\r\n&nbsp;}<br />\r\n&nbsp;v&iacute; dụ ta đ&atilde; c&oacute; mảng sau:<br />\r\n&nbsp;$a=array(1,3,5,7,9,2,4,6,8,10);<br />\r\n&nbsp;mu&ocirc;n in tất cả c&aacute;c gi&aacute; trị của mảng ra m&agrave;n h&igrave;nh v&agrave; c&aacute;ch nhau bởi 1 khoảng trẳng th&igrave; ta l&agrave;m như sau:<br />\r\n&nbsp;foreach($a as $temp) echo $temp.&quot; &quot;;<br />\r\n&nbsp;b. đối với mảng kết hợp<br />\r\n&nbsp;ph&eacute;p lặp tương tự như tr&ecirc;n nhưng c&oacute; hơi kh&aacute;c 1 ch&uacute;t<br />\r\n&nbsp;foreach ($array as $key =&gt; $value)<br />\r\n&nbsp;{<br />\r\n&nbsp; &nbsp;h&agrave;nh động;<br />\r\n&nbsp;}<br />\r\n&nbsp;v&iacute; dụ ta c&oacute; mảng sau:<br />\r\n&nbsp;$a=array(name =&gt; &quot;tran khanh toan&quot;, age =&gt; 20, job =&gt; &quot;student&quot;);<br />\r\n&nbsp;để in tất cả c&aacute;c gi&aacute; trị của mảng tr&ecirc;n ta thực hiện lệnh sau:<br />\r\n&nbsp;foreach($a as $key =&gt; $value)<br />\r\n&nbsp;{<br />\r\n&nbsp; &nbsp; echo $key.&quot;:&quot;.$value;<br />\r\n&nbsp;}<br />\r\n&nbsp;</p>\r\n\r\n<h2>&nbsp;4. một số h&agrave;m hổ trợ sẵn trong PHP</h2>\r\n\r\n<p>&nbsp;- h&agrave;m gộp mảng: $a=array_merge($mang1,$mang2);<br />\r\n&nbsp;- h&agrave;m t&aacute;ch mảng: array_slice($mang,vi tr&iacute;, số lượng);<br />\r\n&nbsp;- h&agrave;m sắp xếp mảng theo thứ tự tăng dần: sort($mang);<br />\r\n&nbsp;- h&agrave;m kiểm tra phần tử c&oacute; tồn tại trong mảng hay kh&ocirc;ng: in_array(gi&aacute; trị,$mang);</p>\r\n', '/admin/images_cm/php.png', 39, '2015-11-01', 1, 1, NULL),
(10, 'xử lý FORM trong PHP', '<pre class="brush:xml;">\r\n\r\n&lt;form action=&quot;check.php&quot; method=&quot;post&quot; name=&quot;form example&quot;&gt;\r\nuser name: &lt;input name=&quot;username&quot; type=&quot;text&quot; /&gt;\r\npass word: &lt;input name=&quot;password&quot; type=&quot;password&quot; /&gt;\r\n&lt;input type=&quot;submit&quot; value=&quot;ok&quot; /&gt;\r\n&lt;/form&gt;</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>user name: pass word:</p>\r\n\r\n<p>PHP cho ph&eacute;p ta lấy dữ dữ liệu từ form qua c&uacute; ph&aacute;p: $_GET[&#39;gi&aacute; trị&#39;] v&agrave; $_POST[&#39;gi&aacute; trị&#39;], t&ugrave;y theo phương thức gởi dữ liệu của form l&agrave; get hay post. phương thức GET d&ugrave;ng để lấy dữ liệu từ form nhập liệu tuy nhi&ecirc;n nhiệm vụ ch&iacute;nh của n&oacute; vẫn l&agrave; lấy nội dung trang dữ liệu từ web server phương thức POST lấy dữ liệu từ form v&agrave; chủ yếu l&agrave; chuyển ch&uacute;ng l&ecirc;n web server v&iacute; dụ với form nhập liệu ở tr&ecirc;n, trong trang check.php c&oacute; nhiệm vụ xử l&yacute; gi&aacute; trị form gởi tới v&agrave; in ra m&agrave;n h&igrave;nh username v&agrave; pass đ&atilde; nhập, th&igrave; trang check.php sẽ được code như sau:</p>\r\n\r\n<pre class="brush:xml;">\r\n&lt;? php\r\n$name=$_POST[&#39;username&#39;];\r\n$pass=$_POST[&#39;password&#39;];\r\necho &quot;user name : &quot;.$name.&quot;pass word : &quot;.$pass;\r\n?&gt;</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/php.png', 39, '2015-11-01', 9, 1, NULL),
(11, 'Đọc và ghi file trong lập trình C/C++', '<p>Đọc file: L&agrave; c&aacute;ch thức bạn d&ugrave;ng ng&ocirc;n ngữ lập tr&igrave;nh duyệt v&agrave; lấy được nội dung của file đ&oacute; ra, c&ograve;n phần c&ograve;n lại xử l&yacute; nội dung đ&oacute; như thế n&agrave;o l&agrave; t&ugrave;y bạn. hi</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Ghi file: L&agrave; c&ocirc;ng việc bạn ghi một nội dung n&agrave;o đ&oacute; lưu v&agrave;o file.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>B&agrave;i v&iacute; dụ cho phần n&agrave;y m&igrave;nh sẽ ghi file trước sau đ&oacute; đọc file vừa ghi. Ch&uacute;ng ta sẽ lưu th&ocirc;ng tin mảng một chiều v&agrave;o trong file. Bạn h&igrave;nh dung trước khi ghi phải c&oacute; nội dung n&ecirc;n ta nhập mảng trước.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>void nhap(int a[], int n)</strong></p>\r\n\r\n<p><strong>{</strong></p>\r\n\r\n<p><strong>for(int i=1; i&lt;=n; i++)</strong></p>\r\n\r\n<p><strong>{</strong></p>\r\n\r\n<p><strong>printf(&quot;Nhap pt a[%d]: &quot;,i);</strong></p>\r\n\r\n<p><strong>scanf(&quot;%d&quot;, &amp;a[i]);</strong></p>\r\n\r\n<p><strong>}</strong></p>\r\n\r\n<p><strong>}</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Ghi file trong C</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Sau khi nhập th&igrave; mảng a[] đ&atilde; c&oacute; gi&aacute; trị l&uacute;c n&agrave;y ch&uacute;ng ta sẻ ghi v&agrave;o trong file, giả sử l&agrave; file bcdonline.txt.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>void ghifile(int a[],int n)</strong></p>\r\n\r\n<p><strong>{</strong></p>\r\n\r\n<p><strong>FILE *f;</strong></p>\r\n\r\n<p><strong>f=fopen(&quot;bcdonline.text&quot;,&quot;wt&quot;);</strong></p>\r\n\r\n<p><strong>fprintf(f,&quot;%d&quot;,n);</strong></p>\r\n\r\n<p><strong>for(int i=1;i&lt;=n;i++)</strong></p>\r\n\r\n<p><strong>fprintf(f,&quot;%3d&quot;,a[i]);</strong></p>\r\n\r\n<p><strong>fclose(f);</strong></p>\r\n\r\n<p><strong>}</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Trước ti&ecirc;n để l&agrave;m việc với file bạn cần khai b&aacute;o biến con trỏ FILE bạn nhớ l&agrave; phải viết hoa ho&agrave;n to&agrave;n từ n&agrave;y.</p>\r\n\r\n<p>Sau đ&oacute; bạn mở bằng lệnh bằng fopen(), trong đ&oacute; tham số &ldquo;wt&rdquo; cho ph&eacute;p bạn ghi file.</p>\r\n\r\n<p>fprintf(): sẽ gi&uacute;p bạn ghi v&agrave;o file như bạn khai b&aacute;o, bạn h&igrave;nh dung thay v&igrave; hiện tr&ecirc;n m&agrave;n h&igrave;nh bằng printf() th&igrave; ở đ&acirc;y ta hiện l&ecirc;n file bằng c&aacute;ch fprintf().</p>\r\n\r\n<p>Đọc file trong C</p>\r\n\r\n<p>Sau khi đ&atilde; c&oacute; file rồi th&igrave; ch&uacute;ng ta tiến h&agrave;nh đọc file l&ecirc;n v&agrave; xử l&yacute;. C&ocirc;ng việc bạn code như sau:</p>\r\n\r\n<table border="0" cellpadding="0" cellspacing="0">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<p>&nbsp;</p>\r\n\r\n			<p><code>void docfile(int a[],int &amp;n)</code></p>\r\n\r\n			<p><code>{</code></p>\r\n\r\n			<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>FILE *f;</code></p>\r\n\r\n			<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>f=fopen(</code><code>&quot;bcdonline.text&quot;</code><code>,</code><code>&quot;rt&quot;</code><code>);</code></p>\r\n\r\n			<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>fscanf(f,</code><code>&quot;%d&quot;</code><code>,&amp;n);</code></p>\r\n\r\n			<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>for</code><code>(int i=1;i&lt;=n;i++)</code></p>\r\n\r\n			<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>fscanf(f,</code><code>&quot;%d&quot;</code><code>,&amp;a[i]);</code></p>\r\n\r\n			<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>fclose(f);</code></p>\r\n\r\n			<p><code>}</code></p>\r\n\r\n			<p>&nbsp;</p>\r\n			&nbsp;\r\n\r\n			<ul>\r\n				<li><code>Cũng như n&oacute;i ở tr&ecirc;n c&oacute; c&aacute;c phần xử l&yacute; đặt trưng khi tương t&aacute;c với FILE.</code></li>\r\n				<li><code>Tham số &ldquo;rt&rdquo; gi&uacute;p bạn đọc dữ liệu từ file</code></li>\r\n				<li><code>Đọc file với lệnh fscanf();</code></li>\r\n				<li><code>Sau đ&oacute; đ&oacute;ng file fclose();</code></li>\r\n			</ul>\r\n\r\n			<p><code>Để kiểm tra bạn đ&atilde; đọc được file hay chưa ch&uacute;ng ta tiến h&agrave;nh xử l&yacute; dữ liệu đ&atilde; đọc được bằng c&aacute;ch xuất n&oacute; ra m&agrave;n h&igrave;nh.</code></p>\r\n\r\n			<p><code><code>void xuat(int a[],int n)</code></code></p>\r\n\r\n			<p><code><code>{</code></code></p>\r\n\r\n			<p><code><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>printf(</code><code>&quot;\nKet Qua Doc File:\n\n&quot;</code><code>);</code></code></p>\r\n\r\n			<p><code><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>for</code><code>(int i=1;i&lt;=n;i++)</code></code></p>\r\n\r\n			<p><code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>printf(</code><code>&quot;%3d&quot;</code><code>,a[i]);</code></code></p>\r\n\r\n			<p><code><code>}</code></code></p>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n', '/admin/images_cm/c.png', 37, '2015-11-01', 2, 1, NULL),
(12, 'một số chú ý đáng nhớ trong lâp trình c về chuỗi và file', '<p><strong>một số ch&uacute; &yacute; đ&aacute;ng nhớ trong l&acirc;p tr&igrave;nh c về chuỗi v&agrave; file</strong></p>\r\n\r\n<ol>\r\n	<li>fread(biến địa chỉ, bộ nhớ, số cấu tr&uacute;c cần đọc, file);&nbsp;//trả về số cấu tr&uacute;c &nbsp;đọc được, nếu hết file c&oacute; nghĩa l&agrave; trả về 0.</li>\r\n	<li>fwrite(biến đại chỉ, bộ nhớ, số cấu tr&uacute;c cần ghi, file);//trả về số cấu tr&uacute;c ghi được, trả về 0 nếu ghi kh&ocirc;ng được hay l&ecirc;n file thất bại.<br />\r\n	/* c&aacute;c cấu tr&uacute;c c&oacute; thể mảng, 1 biến b&igrave;nh thường hay biến dữ liệu kiểu cấu tr&uacute;c, thay thế được c&aacute;c v&ograve;ng for trong việc đọ hay ghi th&ocirc;ng thường */</li>\r\n	<li>fscanf(file, kiểu, biến địa chỉ);&nbsp;//trả về gi&aacute; trị EOF nếu qu&eacute;t đến cờ hiệu kết th&uacute;c file EOF (-1).</li>\r\n	<li>feof(file);&nbsp;//trả về gi&aacute; trị l&agrave; vị tr&iacute; của con trỏ nếu con trỏ file đang đứng ở vị tr&iacute; cờ hiệu kết th&uacute;c file. chưa kết th&uacute;c file th&igrave; trả về 0.</li>\r\n	<li>getc(file);//nếu qu&eacute;t đến cờ hiệu kết th&uacute;c file th&igrave; trả về gi&aacute; trị char tương ứng l&agrave; EOF hay (-1).</li>\r\n	<li>fopen(&quot;t&ecirc;n file/ c&oacute; thể l&agrave; đường dẫn file&quot;,&quot;kiểu mở&quot;);&nbsp;//trả về địa chỉ FILE tr&ecirc;n bộ nhớ nếu th&agrave;nh c&ocirc;ng, v&agrave; trả về gi&aacute; trị NULL nếu thất bại.</li>\r\n	<li>fgets(chuỗi nhận, số k&iacute; tự, file)&nbsp;trả v&ecirc; địa chỉ của chuỗi s nếu get được th&agrave;nh c&ocirc;ng, trả về NULL hay 0 nếu kh&ocirc;ng get được, địa chỉ của &ocirc; nhớ của chuỗi lu&ocirc;n l&agrave; s&ocirc; dương.</li>\r\n	<li>strstr(chuỗi s1, chuỗi s2); &nbsp;trả về địa chỉ &ocirc; nhớ chứa chuỗi, l&agrave; chuỗi con của s1 bắt đầu từ vị v&iacute; xuất hiện đầu ti&ecirc;n của chuỗi s2 trong chuỗi s1, nếu kh&ocirc;ng c&oacute; chuỗi s2 trong s1 th&igrave; chuỗi để copy kh&ocirc;ng c&oacute;, trả về gi&aacute; trị 0 hay NULL</li>\r\n</ol>\r\n', '/admin/images_cm/c.png', 37, '2015-11-01', 0, 1, NULL);
INSERT INTO `baiviet` (`idbv`, `subject`, `content`, `image_bv`, `parent`, `date_add`, `views`, `author`, `des`) VALUES
(13, '[một số chú ý] kiểu FILE trong ngôn ngữ c', '<p><strong>kiểu file trong lập tr&igrave;nh c</strong><br />\r\n<br />\r\n&nbsp;</p>\r\n\r\n<ul>\r\n	<li>fread(biến địa chỉ, bộ nhớ, số cấu tr&uacute;c cần đọc, file);&nbsp;//trả về số cấu tr&uacute;c &nbsp;đọc được, nếu hết file c&oacute; nghĩa l&agrave; trả về 0.</li>\r\n	<li>fwrite(biến đại chỉ, bộ nhớ, số cấu tr&uacute;c cần ghi, file);//trả về số cấu tr&uacute;c ghi được, trả về 0 nếu ghi kh&ocirc;ng được hay l&ecirc;n file thất bại.<br />\r\n	/* c&aacute;c cấu tr&uacute;c c&oacute; thể mảng, 1 biến b&igrave;nh thường hay biến dữ liệu kiểu cấu tr&uacute;c, thay thế được c&aacute;c v&ograve;ng for trong việc đọ hay ghi th&ocirc;ng thường */</li>\r\n	<li>fscanf(file, kiểu, biến địa chỉ);&nbsp;//trả về gi&aacute; trị EOF nếu qu&eacute;t đến cờ hiệu kết th&uacute;c file EOF (-1).</li>\r\n	<li>feof(file);&nbsp;//trả về gi&aacute; trị l&agrave; vị tr&iacute; của con trỏ nếu con trỏ file đang đứng ở vị tr&iacute; cờ hiệu kết th&uacute;c file. chưa kết th&uacute;c file th&igrave; trả về 0.</li>\r\n	<li>getc(file);//nếu qu&eacute;t đến cờ hiệu kết th&uacute;c file th&igrave; trả về gi&aacute; trị char tương ứng l&agrave; EOF hay (-1).</li>\r\n	<li>fopen(&quot;t&ecirc;n file/ c&oacute; thể l&agrave; đường dẫn file&quot;,&quot;kiểu mở&quot;);&nbsp;//trả về địa chỉ FILE tr&ecirc;n bộ nhớ nếu th&agrave;nh c&ocirc;ng, v&agrave; trả về gi&aacute; trị NULL nếu thất bại.</li>\r\n</ul>\r\n', '/admin/images_cm/c.png', 37, '2015-11-01', 0, 1, NULL),
(14, 'KIỂU FILE TRONG LẬP TRÌNH C', '<p><strong>file</strong>&nbsp;l&agrave; 1 tập hợp th&ocirc;ng tin được lưu dưới 1 c&aacute;i t&ecirc;n chung *.txt, *.exe<br />\r\nkhai b&aacute;o:&nbsp;file *t&ecirc;n biến;&nbsp;ở đ&acirc;y l&agrave; biến con trỏ<br />\r\nfile *open(char *t&ecirc;n file,char *kiểu mở);<br />\r\nkiểu mở l&agrave; 1 trong c&aacute;c chuổi sau đ&acirc;y:<br />\r\n&quot;rb&quot;:read only<br />\r\n&quot;wb&quot;:write<br />\r\n&quot;ab&quot;:th&ecirc;m v&agrave;o cuối file<br />\r\n&quot;r+b&quot;:đọc v&agrave; ghi<br />\r\n&quot;w+b&quot;:tạo file mới để ghi v&agrave; đọc<br />\r\n&quot;a+b&quot;:mowrvaf th&ecirc;m v&agrave;o cuối file<br />\r\nv&iacute; dụ:<br />\r\nf=open(&quot;t1.txt&quot;,&quot;w+b&quot;);<br />\r\nđ&oacute;ng tập tin&nbsp;fclose(f);<br />\r\nfcloseall(f);<br />\r\nkiểm tra đọc đến cuối file chưa.<br />\r\nd&ugrave;ng h&agrave;m:<br />\r\nfeof(f)=0 nếu chưa v&agrave; &nbsp;=1 nếu đ&atilde; hết;<br />\r\nđọc&nbsp;ghi số nguy&ecirc;n l&ecirc;n file<br />\r\nputw(k,f);//ghi số nguy&ecirc;n k l&ecirc;n file file f<br />\r\ngetw(f);trả về 1 số nguy&ecirc;n đọc được từ file f<br />\r\nđọc&nbsp;ghi 1 mẫu tin l&ecirc;n file<br />\r\nfread(*p,int size,int n,f);//đọc n mẫu tin c&oacute; k&iacute;ch thước size, kết quả lưu v&agrave;o biến con trỏ p<br />\r\nv&iacute; dụ:<br />\r\nint k;<br />\r\nfread(&amp;k,2,1,f);<br />\r\nif(!feof(f)) printf(&quot;k=%d&quot;,k);<br />\r\nfwrite(*p,int size,n,f);//ghi n mẫu tin c&oacute; k&iacute;ch thước size từ địa chỉ p l&ecirc;n file f<br />\r\ndi chuyển con trỏ định vị nội dung file<br />\r\nrewind(f);//về đầu tập tin<br />\r\nfseek(f,k,vtri);<br />\r\nvtri:(nơi xuất ph&aacute;t) cụ thể l&agrave;:<br />\r\nseek_set(hay 0):từ đầu file<br />\r\nseek_cur(hay 1):từ vị tr&iacute; hiện tại<br />\r\nseek_end(hay 2):cuối file<br />\r\n<strong><em>&yacute; nghĩa:&nbsp;</em></strong><br />\r\ndời con trỏ định vị nội dung đi k bytetinhs từ vtri<br />\r\nk&gt;0:hướng di chuyển về cuối tập tin<br />\r\nk&lt;0:hướng di chuyển về đầu tập tin<br />\r\nftell(f): trả về vị số thứ tự byte nơi con trỏ đang đứng<br />\r\n&aacute;p dụng t&iacute;nh số phần tử của file<br />\r\nfseek(f,0,seek_end);<br />\r\nlong n=ftell(f);<br />\r\n&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-01', 0, 1, NULL),
(15, 'cấu trúc của 1 chương trình c', '<p>c&oacute; lẽ 1 trong những c&aacute;ch tốt nhất để học 1 ng&ocirc;n ngữ lập tr&igrave;nh l&agrave; bằng 1 chương tr&igrave;nh . vậy đ&acirc;y l&agrave; chương tr&igrave;nh đầu ti&ecirc;n của ch&uacute;ng ta:<br />\r\n///chương tr&igrave;nh c<br />\r\n#include&lt;stdio.h&gt;<br />\r\n#include&lt;conio.h&gt;<br />\r\nvoid main()<br />\r\n{<br />\r\nprintf(&quot;hello world &quot;);<br />\r\n_getch();<br />\r\n}<br />\r\nchương tr&igrave;nh tr&ecirc;n đ&acirc;y l&agrave; chương tr&igrave;nh đầu ti&ecirc;n m&agrave; hầu hết người mới học ngon ngữ lập tr&igrave;nh c phải l&agrave;m, n&oacute; bao gồm những phần cơ bản của 1 chương tr&igrave;nh c cần c&oacute;:<br />\r\n&nbsp;</p>\r\n\r\n<ul>\r\n	<li>///chương tr&igrave;nh c: đ&acirc;y l&agrave; ch&uacute; th&iacute;ch , tất cả c&aacute;c d&ograve;ng bắt đầu bằng dấu /// l&agrave; ch&uacute; th&iacute;ch v&agrave; kh&ocirc;ng ảnh hưởng g&igrave; đến chương tr&igrave;nh của ch&uacute;ng ta hết. c&oacute; thể khai b&aacute;o ch&uacute; th&iacute;ch bằng&nbsp;/* ch&uacute; thchs ở đ&acirc;y */</li>\r\n	<li>#include&lt;stdio.h&gt;:đ&acirc;y l&agrave; d&ograve;ng lệnh khai b&aacute;o thư viện, để sử dụng được c&aacute;c lệnh trong trong chương tr&igrave;nh th&igrave; ch&uacute;ng ta phải khai b&aacute;o thư viện, v&iacute; dụ ở đ&acirc;y lệnh&nbsp;printfnằm trong thư viện&nbsp;stdio.h</li>\r\n	<li>void main(){}: nội dung của chương tr&igrave;nh nằm trong dấu&nbsp;{}, c&oacute; thể l&agrave;&nbsp;void main()hay&nbsp;int main(),&nbsp;v&agrave; 1 số kiểu khai b&aacute;o nội dung của chương tr&igrave;nh, ch&uacute;ng ta sẽ đề cấp đến n&oacute; trong c&aacute;c phần sau. b&ecirc;n trong nội dung của chương tr&igrave;nh sẽ l&agrave; c&aacute;c lệnh, ch&uacute;ng ta sẽ học ơ c&aacute;c ph&agrave;n sau.&nbsp;</li>\r\n</ul>\r\n', '/admin/images_cm/c.png', 37, '2015-11-01', 0, 1, NULL),
(16, 'các toán tử trong lập trình c', '<ol>\r\n	<li><strong>to&aacute;n tử g&aacute;n:</strong></li>\r\n</ol>\r\n\r\n<p>d&ugrave;ng để g&aacute;n 1 gi&aacute; trị n&agrave;o đ&oacute; cho biến.</p>\r\n\r\n<p>v&iacute; dụ:&nbsp;a = 5;</p>\r\n\r\n<p>g&aacute;n gi&aacute; trij5 cho biến a. vế tr&aacute;i l&agrave; biến, c&ograve;n vế phải c&oacute; thể l&agrave; hằng bất k&igrave; h&acirc;y biến hay biểu thức.</p>\r\n\r\n<p>to&aacute;n tử g&aacute;n lu&ocirc;n lu&ocirc;n được hiện từ tr&aacute;i sang phải v&agrave; kh&ocirc;ng bao giờ c&oacute; th&uacute; tự ngược lại.</p>\r\n\r\n<p>v&iacute; dụ:</p>\r\n\r\n<p>a = b;</p>\r\n\r\n<p>a=5;</p>\r\n\r\n<p>a=5-2;</p>\r\n\r\n<p>a=b*9;</p>\r\n\r\n<p>2.<strong>c&aacute;c to&aacute;n tử số học;</strong></p>\r\n\r\n<p><strong>+&nbsp;</strong>cộng</p>\r\n\r\n<p>- trừ</p>\r\n\r\n<p>* nh&acirc;n</p>\r\n\r\n<p>/ chia</p>\r\n\r\n<p>% chia lấy dư</p>\r\n\r\n<p>thứ tự thực hện cũng giống như trong to&aacute;n học. v&iacute; dụ ph&eacute;p chia l&aacute;y dư như sau;</p>\r\n\r\n<p>11%3=2</p>\r\n\r\n<p>11%5=1</p>\r\n\r\n<p><strong>3.c&aacute;c ph&eacute;p to&aacute;n phức hợp;</strong></p>\r\n\r\n<p>a+=5; tương đương với a=a+5;</p>\r\n\r\n<p>a-=5; tương đương với a=a-5;</p>\r\n\r\n<p>a*=5 tương đương với a=a*5;</p>\r\n\r\n<p>a/=5; tương đương với a=a/5;</p>\r\n\r\n<p>a%=5; tương đương với a=a % 5;</p>\r\n\r\n<p><strong>4. to&aacute;n tở tăng v&agrave; giảm:</strong></p>\r\n\r\n<p>++a, a++ : tăng a 1 đơn vị</p>\r\n\r\n<p>--a, a-- : giảm a 1 đơn vị.</p>\r\n\r\n<p>c&aacute;c dấu ++,--, đặt v&agrave;o đ&acirc;u n&oacute; cũng c&oacute; chung 1 &yacute; nghĩa nhưng ch&uacute;ng c&oacute; sự kh&aacute;c nhau:</p>\r\n\r\n<p>nếu đặt ++ trước biến th&igrave; n&oacute; sẽ tăng biến trước khi l&agrave;m nhiệm vụ kh&aacute;c trong biểu thức chẳng hạn, c&ograve;n&nbsp;++ sau biến th&igrave; sẽ tăng biến saukhi biến l&agrave;m xong nhiệm vụ trong biểu thức.</p>\r\n\r\n<p>v&iacute; dụ để dễ hiểu về ấn đề n&agrave;y:</p>\r\n\r\n<p>b=4;</p>\r\n\r\n<p>a=++b; ///th&igrave; b=5, a=5</p>\r\n\r\n<p>a=b++;///th&igrave; b=5 nhưng a mới chỉ bằng 4</p>\r\n\r\n<p><strong>&nbsp;5.c&aacute;c to&aacute;n tử quan hệ:</strong></p>\r\n\r\n<p>== Bằng</p>\r\n\r\n<p>&nbsp;!= Kh&aacute;c&nbsp;</p>\r\n\r\n<p>&gt; Lớn hơn</p>\r\n\r\n<p>&nbsp;&lt; Nhỏ hơn</p>\r\n\r\n<p>&nbsp;&gt; = Lớn hơn hoặc bằng</p>\r\n\r\n<p>&nbsp;&lt; = Nhỏ hơn hoặc bằng</p>\r\n\r\n<p>&nbsp;V&iacute; dụ: &nbsp;</p>\r\n\r\n<p>(7 == 5) sẽ trả gi&aacute; trị false (6 &gt;= 6) sẽ trả gi&aacute; trị true tất nhi&ecirc;n thay v&igrave; sử dụng c&aacute;c số, ch&uacute;ng ta c&oacute; thể sử dụng bất cứ biểu thức n&agrave;o. Cho a=2, b=3 v&agrave; c=6 (a*b &gt;= c) sẽ trả gi&aacute; trị true. (b+4 &lt; a*c) sẽ trả gi&aacute; trị false&nbsp;</p>\r\n\r\n<p><strong>6.to&aacute;n tử logic</strong></p>\r\n\r\n<p><strong>!</strong>&nbsp;not</p>\r\n\r\n<p>&amp;&amp; and v&agrave;</p>\r\n\r\n<p>|| or hoặc</p>\r\n\r\n<p>v&iacute; dụ:</p>\r\n\r\n<p>!(2==2) trả về false</p>\r\n\r\n<p><strong>7. &nbsp;to&aacute;n tử điều kiện</strong></p>\r\n\r\n<p>điều kiện ? gi&aacute; trị 1 nếu đk đ&uacute;ng : gi&aacute; trị 2 nếu dk kiện sai;</p>\r\n\r\n<p>v&iacute; dụ: 7==5 ? 3:4; trả về 4 v&igrave; đk sai</p>\r\n\r\n<p>7==5 ? 4 : 3 trả về 3 v&igrave; 7 kh&ocirc;ng bằng 5.&nbsp;</p>\r\n\r\n<p>5&gt;3 ? a : b trả về a, v&igrave; 5 lớn hơn 3.&nbsp;</p>\r\n\r\n<p><strong>8.c&aacute;c to&aacute;n tử thao t&aacute;c tr&ecirc;n bit</strong></p>\r\n\r\n<p>&amp; AND Logical AND&nbsp;</p>\r\n\r\n<p>| OR Logical OR&nbsp;</p>\r\n\r\n<p>^ XOR Logical exclusive OR&nbsp;</p>\r\n\r\n<p>~ NOT Đảo ngược bit&nbsp;</p>\r\n\r\n<p>&lt;&lt; SHL Dịch bit sang tr&aacute;i&nbsp;</p>\r\n\r\n<p>&gt;&gt; SHR Dịch bit sang phải&nbsp;</p>\r\n\r\n<p>v&iacute; dụ;</p>\r\n\r\n<p>&amp; v&agrave; | th&igrave; dễ hiểu, t&ocirc;i kh&ocirc;ng n&oacute;i th&ecirc;m.</p>\r\n\r\n<p>a^b=1 nếu a kh&aacute;c b</p>\r\n\r\n<p>a^b=0 nếu a = b</p>\r\n\r\n<p>k=m&lt;&lt;n tương ứng với k=m*2^n</p>\r\n\r\n<p>k=m&gt;&gt;n tương ứng với k=m/2^n</p>\r\n\r\n<p>cho m=[00001101]</p>\r\n\r\n<p>th&igrave; ~m=[11110010] đ&acirc;y l&agrave; phếp đảo bit.</p>\r\n\r\n<p><strong>9.&eacute;p kiểu dữ liệu của biến</strong></p>\r\n\r\n<p>&nbsp;đặt trước biểu thức cần chuyển đổi t&ecirc;n kiểu dữ liệu được bọc trong cặp ngoặc đơn (), v&iacute; dụ:&nbsp;</p>\r\n\r\n<p>int i;</p>\r\n\r\n<p>&nbsp;float f = 3.14;</p>\r\n\r\n<p>&nbsp;i = (int) f;</p>\r\n\r\n<p>Đoạn m&atilde; tr&ecirc;n chuyển số thập ph&acirc;n 3.14 sang một số nguy&ecirc;n (3).</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-01', 0, 1, NULL),
(17, 'Cấu trúc điều kiện: if và else trong c', '<p><strong>.Cấu tr&uacute;c điều kiện: if &nbsp;v&agrave; else&nbsp;</strong><br />\r\nCấu tr&uacute;c n&agrave;y được d&ugrave;ng khi một lệnh hay một khối lệnh chỉ được thực hiện khi một điều kiện n&agrave;o đ&oacute; thoả m&atilde;n. Dạng của n&oacute; như sau:<br />\r\nif (điều kiện) lệnh khi đk đ&uacute;ng;<br />\r\nV&iacute; dụ, đoạn m&atilde; sau đ&acirc;y sẽ viết&nbsp;x is 100&nbsp;chỉ khi biến &nbsp;x chứa gi&aacute; trị 100<br />\r\nif (x==100) printf(&quot;x &iacute; 100);<br />\r\nch&uacute;ng ta c&oacute; thể chỉ định một khối lệnh bằng c&aacute;ch sử dụng một cặp ngoặc nhọn { }:<br />\r\nv&iacute; dụ<br />\r\nif(x==100) { printf(&quot;x is&quot;); printf(&quot;x&quot;); }<br />\r\nCh&uacute;ng ta cũng c&oacute; thể chỉ định điều g&igrave; sẽ xảy ra nếu điều kiện kh&ocirc;ng được thoả m&atilde;n bằng c&aacute;ch sửu dụng từ kho&aacute; else. N&oacute; được sử dụng c&ugrave;ng với if như sau:<br />\r\nif (điều kiện) lệnh khi dk đ&uacute;ng;<br />\r\nelse lệnh khi điều kiện sai;<br />\r\nv&iacute; dj:<br />\r\nif(x==100) printf(&quot;x is 100&quot;);<br />\r\nelse printf(&quot;x not is 100&quot;);</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-01', 0, 1, NULL),
(18, 'các cấu trúc lặp, while , do-while trong c', '<p>Mục đ&iacute;ch của c&aacute;c v&ograve;ng lặp l&agrave; lặp lại một thao t&aacute;c với một số lần nhất định hoặc trong khi một điều kiện n&agrave;o đ&oacute; c&ograve;n thoả m&atilde;n<br />\r\n<strong>1. v&ograve;ng lặp while&nbsp;</strong><br />\r\ndạng của n&oacute; như sau: while (điều kiện) lệnh thực thi khi&nbsp;điều&nbsp;&nbsp;kiện đ&uacute;ng;<br />\r\nV&iacute; dụ, ch&uacute;ng ta sẽ viết một chương tr&igrave;nh đếm ngược sử dụng v&agrave;o lặp while:<br />\r\n#include&lt;stdio.h&gt;<br />\r\n#include&lt;conio.h&gt;<br />\r\nvoid main()<br />\r\n{<br />\r\nint n;<br />\r\nprintf(&quot;nhap n&quot;);<br />\r\nscanf_s(&quot;%d&quot;,&amp;n);<br />\r\nwhile (n&gt;0){ printf(&quot;%d&quot;,n); --n;}<br />\r\n_getch();<br />\r\n}<br />\r\nKhi chương tr&igrave;nh chạy người sử dụng được y&ecirc;u cầu nhập v&agrave;o một số để đếm ngược. Sau đ&oacute;, khi v&ograve;ng lặp while bắt đầu nếu số m&agrave; người d&ugrave;ng nhập v&agrave;o thoả m&atilde;n điều kiện điều kiện n&gt;0 khối lệnh sẽ được thực hiện một số lần kh&ocirc;ng x&aacute;c định chừng n&agrave;o điều kiện (n&gt;0) c&ograve;n được thoả m&atilde;n.<br />\r\nCh&uacute;ng ta cần phải nhớ rằng v&ograve;ng lặp phải kết th&uacute;c ở một điểm n&agrave;o đ&oacute;, v&igrave; vậy b&ecirc;n trong v&ograve;ng lặp ch&uacute;ng ta phải cung cấp một phương thức n&agrave;o đ&oacute; để buộc (điều kiện)&nbsp;&nbsp;trở th&agrave;nh sai nếu kh&ocirc;ng th&igrave; n&oacute; sẽ lặp lại m&atilde;i m&atilde;i. Trong v&iacute; dụ tr&ecirc;n v&ograve;ng lặp phải c&oacute; lệnh --n;<br />\r\n<strong>2. v&ograve;ng lặp do while&nbsp;</strong><br />\r\nc&uacute; ph&aacute;p:&nbsp;do&nbsp;<em>lệnh thức thi&nbsp;</em>while (điều kiện);<br />\r\nChức năng của n&oacute; l&agrave; ho&agrave;n to&agrave;n giống v&ograve;ng lặp while chỉ trừ c&oacute; một điều l&agrave; &iacute;t nhất c&oacute; 1 lần lệnh được thực hiện d&ugrave; điều kiện c&oacute; l&agrave; sai đi chăng nữa.<br />\r\n&nbsp;V&iacute; dụ, chương tr&igrave;nh dưới đ&acirc;y sẽ viết ra bất k&igrave; số n&agrave;o m&agrave; bạn nhập v&agrave;o cho đến khi bạn nhập số 0.<br />\r\n#include&lt;stdio.h&gt;<br />\r\n#include&lt;conio.h&gt;<br />\r\nvoid main()<br />\r\n{<br />\r\nunsigned long n;<br />\r\ndo {<br />\r\nprintf(&quot;nhap n:&quot;);<br />\r\nscanf_s(&quot;%lu&quot;, &amp;n);<br />\r\nprintf(&quot;\n ban da nhap: %lu \n&quot;, n);<br />\r\n} while (n != 0);<br />\r\n_getch();<br />\r\n}<br />\r\nV&ograve;ng lặp do-while thường được d&ugrave;ng khi điều kiện để kết th&uacute;c v&ograve;ng lặp nằm trong v&ograve;ng lặp, như trong v&iacute; dụ tr&ecirc;n, số m&agrave; người d&ugrave;ng nhập v&agrave;o l&agrave; điều kiện kiểm tra để kết th&uacute;c v&ograve;ng lặp. Nếu bạn kh&ocirc;ng nhập số 0 trong v&iacute; dụ tr&ecirc;n th&igrave; v&ograve;ng lặp sẽ kh&ocirc;ng bao giờ chấm dứt.<br />\r\n<strong>3. v&ograve;ng lặp for</strong><br />\r\nc&uacute; ph&aacute;p:&nbsp;for (&nbsp;<em>đặt một gi&aacute; kh&iacute; ban đầu cho biến điều khiển; điều kiện; thay đổi tr&ecirc;n biến</em>&nbsp;) lệnh thực hiện;<br />\r\nSau đ&acirc;y l&agrave; một v&iacute; dụ đếm ngược sử dụng v&ograve;ng for.&nbsp;<br />\r\n#include&lt;stdio.h&gt;<br />\r\n#include&lt;conio.h&gt;<br />\r\nvoid main()<br />\r\n{<br />\r\nint n;<br />\r\nfor (n = 10; n &gt; 0; n--) printf(&quot;%d&quot;, n);<br />\r\n_getch();<br />\r\n}<br />\r\nPhần khởi tạo v&agrave; lệnh tăng kh&ocirc;ng bắt buộc phải c&oacute;. Ch&uacute;ng c&oacute; thể được bỏ qua nhưng vẫn phải c&oacute; dấu chấm phẩy ngăn c&aacute;ch giữa c&aacute;c phần. V&igrave; vậy, ch&uacute;ng ta c&oacute; thể viết&nbsp;for (;n&lt;10;)&nbsp;hoặc&nbsp;for (;n&lt;10;n++).<br />\r\n#include&lt;stdio.h&gt;<br />\r\n#include&lt;conio.h&gt;<br />\r\nvoid main()<br />\r\n{<br />\r\nint n=10;<br />\r\nfor (; n&gt;0; n--) printf(&quot;%d&quot;, n);<br />\r\n_getch();<br />\r\n}<br />\r\nBằng c&aacute;ch sử dụng dấu phẩy, ch&uacute;ng ta c&oacute; thể d&ugrave;ng nhiều lệnh trong bất k&igrave; trường n&agrave;o trong v&ograve;ng for, như l&agrave; trong phần khởi tạo. V&iacute; dụ ch&uacute;ng ta c&oacute; thể khởi tạo một l&uacute;c nhiều biến trong v&ograve;ng lặp:&nbsp;<br />\r\n<br />\r\nfor ( n=0, i=100 ; n!=i ; n++, i-- ) { &nbsp; // c&aacute;i g&igrave; ở đ&acirc;y cũng được... }<br />\r\n&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-01', 0, 1, NULL),
(19, 'Các lệnh rẽ nhánh và lệnh nhảy trong c', '<p><strong>1.lệnh break</strong><br />\r\nSử dụng break ch&uacute;ng ta c&oacute; thể tho&aacute;t khỏi v&ograve;ng lặp ngay cả khi điều kiện để n&oacute; kết th&uacute;c chưa được thoả m&atilde;n. Lệnh n&agrave;y c&oacute; thể được d&ugrave;ng để kết th&uacute;c một &nbsp;v&ograve;ng lặp kh&ocirc;ng x&aacute;c định hay buộc n&oacute; phải kết th&uacute;c giữa chừng thay v&igrave; kết th&uacute;c một c&aacute;ch b&igrave;nh thường. V&iacute; dụ, ch&uacute;ng ta sẽ dừng việc đếm ngược trước khi n&oacute; kết th&uacute;c:<br />\r\n#include&lt;stdio.h&gt;<br />\r\n#include&lt;conio.h&gt;<br />\r\nvoid main()<br />\r\n{<br />\r\nint n=10;<br />\r\nfor (; n &gt;0 ; n--) {<br />\r\nprintf(&quot; %d &quot;, n);<br />\r\nif (n == 3){<br />\r\nprintf(&quot;stop&quot;); break;<br />\r\n}<br />\r\n<br />\r\n}<br />\r\n_getch();<br />\r\n}<br />\r\n<strong>2.Lệnh continue:</strong><br />\r\nLệnh continue l&agrave;m cho chương tr&igrave;nh bỏ qua phần c&ograve;n lại của v&ograve;ng lặp v&agrave; nhảy sang lần lặp tiếp theo. V&iacute; dụ ch&uacute;ng ta sẽ bỏ qua số 5 trong phần đếm ngược:<br />\r\n#include&lt;stdio.h&gt;<br />\r\n#include&lt;conio.h&gt;<br />\r\nvoid main()<br />\r\n{<br />\r\nint n=10;<br />\r\nfor (; n &gt;0 ; n--) {<br />\r\nif (n == 5) continue;<br />\r\nprintf(&quot; %d &quot;, n);<br />\r\n}<br />\r\n_getch();<br />\r\n}<br />\r\n<strong>3.Lệnh goto.&nbsp;</strong><br />\r\nLệnh n&agrave;y cho ph&eacute;p nhảy v&ocirc; điều kiện tới bất k&igrave; điểm n&agrave;o trong chương tr&igrave;nh. N&oacute;i chung bạn n&ecirc;n tr&aacute;nh d&ugrave;ng n&oacute; trong chương tr&igrave;nh C. Tuy nhi&ecirc;n ch&uacute;ng ta vẫn c&oacute; một v&iacute; dụ d&ugrave;ng lệnh goto để đếm ngược:<br />\r\n#include&lt;stdio.h&gt;<br />\r\n#include&lt;conio.h&gt;<br />\r\nvoid main()<br />\r\n{<br />\r\nint n=10;<br />\r\nup:;<br />\r\nprintf(&quot; %d &quot;, n);<br />\r\nn--;<br />\r\nif (n &gt; 0) goto up;<br />\r\n_getch();<br />\r\n}<br />\r\n&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-01', 0, 1, NULL),
(20, 'Cấu trúc lựa chọn: switch trong c', '<p>c&uacute; ph&aacute;p của lệnh switch hơi đặc biệt một ch&uacute;t. Mục đ&iacute;ch của n&oacute; l&agrave; kiểm tra một v&agrave;i gi&aacute; trị hằng cho một biểu thức, tương tự với những g&igrave; ch&uacute;ng ta l&agrave;m ở đầu b&agrave;i n&agrave;y khi li&ecirc;n kết một v&agrave;i lệnh if v&agrave; else if với nhau. Dạng thức của n&oacute; như sau:<br />\r\nswitch(biến cần kiểm tra)<br />\r\n{<br />\r\ncase&nbsp;<em>gi&aacute; trị 1&nbsp;</em>: lẹnh thực hiện; break;<br />\r\ncase&nbsp;<em>gi&aacute; trị 2</em>: lệnh thực hiện; break;<br />\r\n.........................................................<br />\r\ncase&nbsp;<em>gi&aacute; trị n&nbsp;</em>: lệnh thực hiện; break;<br />\r\ndefault:&nbsp;<em>lệnh thực hiện mặc định;&nbsp;</em>break;<br />\r\n}<br />\r\nN&oacute; hoạt động theo c&aacute;ch sau: switch t&iacute;nh biểu thức v&agrave; kiểm tra xem n&oacute; c&oacute; bằng c&aacute;c gi&aacute; trị sau&nbsp;case&nbsp;hay kh&ocirc;ng, nếu bằng th&igrave; thực hiện lệnh, nếu kh&ocirc;ng t&igrave;m thấy gi&aacute; trị cần t&igrave;m th&igrave; thực hiện l&ecirc;nh mặc định.<br />\r\nv&iacute; dụ;<br />\r\n#include&lt;stdio.h&gt;<br />\r\n#include&lt;conio.h&gt;<br />\r\nvoid main()<br />\r\n{<br />\r\nint n = 10;<br />\r\nswitch (n)<br />\r\n{<br />\r\ncase 1:printf(&quot;ok&quot;); break;<br />\r\ncase 2:printf(&quot;ok&quot;); break;<br />\r\ndefault:printf(&quot;no&quot;);<br />\r\nbreak;<br />\r\n}<br />\r\n_getch();<br />\r\n}<br />\r\nT&ocirc;i đ&atilde; n&oacute;i ở tr&ecirc;n rằng cấu tr&uacute;c của lệnh switch hơi đặc biệt. Ch&uacute; &yacute; sự tồn tại của lệnh break ở cuối mỗi khối lệnh. Điều n&agrave;y l&agrave; cần thiết<br />\r\n&nbsp;c&oacute; thể được d&ugrave;ng khi bạn muốn thực hiện một khối lệnh cho nhiều trường hợp kh&aacute;c nhau, v&iacute; dụ<br />\r\n#include&lt;stdio.h&gt;<br />\r\n#include&lt;conio.h&gt;<br />\r\nvoid main()<br />\r\n{<br />\r\nint n = 10;<br />\r\nswitch (n)<br />\r\n{<br />\r\ncase 1:<br />\r\ncase 2:<br />\r\ncase 3:<br />\r\ncase 4:<br />\r\ncase 5: printf(&quot;so nho hon 5&quot;); break;<br />\r\ndefault: printf(&quot;so lon hon 5&quot;);<br />\r\nbreak;<br />\r\n}<br />\r\n_getch();<br />\r\n}<br />\r\nCh&uacute; &yacute; rằng lệnh&nbsp;switch&nbsp;chỉ c&oacute; thể được d&ugrave;ng để so s&aacute;nh một biểu thức với c&aacute;c hằng. V&igrave; vậy ch&uacute;ng ta kh&ocirc;ng thể đặt c&aacute;c biến&nbsp;(case (n*2):) hay c&aacute;c khoảng&nbsp;(case (1..3):)v&igrave; ch&uacute;ng kh&ocirc;ng phải l&agrave; c&aacute;c hằng hợp lệ. &nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-01', 76, 1, NULL),
(21, 'hàm trong ngôn ngữ lập trình c', '<p>&nbsp;</p>\r\n\r\n<p>H&agrave;m l&agrave; một khối lệnh được thực hiện khi n&oacute; được gọi từ một điểm kh&aacute;c của chương tr&igrave;nh. Dạng thức của n&oacute; như sau:<br />\r\ntype name ( argument1, argument2, ...) statement&nbsp;<br />\r\ntrong đ&oacute;: type l&agrave; kiểu dữ liệu được trả về của h&agrave;m name l&agrave; t&ecirc;n gọi của h&agrave;m. arguments l&agrave; c&aacute;c tham số (c&oacute; nhiều bao nhi&ecirc;u cũng được tuỳ theo nhu cầu). Một tham số bao gồm t&ecirc;n kiểu dữ liệu sau đ&oacute; l&agrave; t&ecirc;n của tham số giống như khi khai b&aacute;o biến (v&iacute; dụ int x) v&agrave; đ&oacute;ng vai tr&ograve; b&ecirc;n trong h&agrave;m như bất k&igrave; biến n&agrave;o kh&aacute;c. Ch&uacute;ng d&ugrave;ng để truyền tham số cho h&agrave;m khi n&oacute; được gọi. C&aacute;c tham số kh&aacute;c nhau được ngăn c&aacute;ch bởi c&aacute;c dấu phẩy. statement l&agrave; th&acirc;n của h&agrave;m. N&oacute; c&oacute; thể l&agrave; một lệnh đơn hay một khối lệnh.&nbsp;<br />\r\n<br />\r\nDưới đ&acirc;y l&agrave; v&iacute; dụ đầu ti&ecirc;n về h&agrave;m:<br />\r\n#include&lt;stdio.h&gt;<br />\r\n#include&lt;conio.h&gt;<br />\r\nint tich(int a, int b)<br />\r\n{<br />\r\nint t;<br />\r\nt = a*b;<br />\r\nreturn(t);<br />\r\n}<br />\r\nvoid main()<br />\r\n{<br />\r\nint a, b,s;<br />\r\nprintf(&quot;nhap vao 2 so muon tinh tich\n&quot;);<br />\r\nscanf_s(&quot;%d%d&quot;, &amp;a, &amp;b);<br />\r\ns = tich(a, b);<br />\r\nprintf(&quot;tich =%d&quot;, s);<br />\r\n_getch();<br />\r\n}<br />\r\nĐể c&oacute; thể hiểu được đoạn m&atilde; n&agrave;y, trước hết h&atilde;y nhớ lại những điều đ&atilde; n&oacute;i ở b&agrave;i đầu ti&ecirc;n: một chương tr&igrave;nh C lu&ocirc;n bắt đầu thực hiện từ h&agrave;m&nbsp;main.&nbsp;V&igrave; vậy ch&uacute;ng ta bắt đầu từ đ&acirc;y.<br />\r\nCh&uacute;ng ta c&oacute; thể thấy h&agrave;m main bắt đầu bằng việc khai b&aacute;o biến,nhập dữ liệu, &nbsp;sau đ&oacute; l&agrave; một lời gọi tới h&agrave;m .&nbsp;&nbsp;Nếu để &yacute; ch&uacute;ng ta sẽ thấy sự tương tự giữa cấu tr&uacute;c của lời gọi h&agrave;m với khai b&aacute;o của h&agrave;m.&nbsp;lệnh&nbsp;return (t)&nbsp;ch&iacute;nh l&agrave; gi&aacute; trị được trả về của h&agrave;m.<br />\r\nBạn cần nhớ rằng phạm vi hoạt động của c&aacute;c biến khai b&aacute;o trong một h&agrave;m hay bất k&igrave; một khối lệnh n&agrave;o kh&aacute;c chỉ l&agrave; h&agrave;m đ&oacute; hay khối lệnh đ&oacute; v&agrave; kh&ocirc;ng thể sử dụng b&ecirc;n ngo&agrave;i ch&uacute;ng. V&iacute; dụ, trong chương tr&igrave;nh v&iacute; dụ tr&ecirc;n, bạn kh&ocirc;ng thể sử dụng trực tiếp c&aacute;c biến a, b&nbsp;v&igrave; ch&uacute;ng l&agrave; c&aacute;c biến cục bộ của h&agrave;m&nbsp;<br />\r\nTuy nhi&ecirc;n bạn c&oacute; thể khai b&aacute;o c&aacute;c biến to&agrave;n cục để c&oacute; thể sử dụng ch&uacute;ng ở bất k&igrave; đ&acirc;u, b&ecirc;n trong hay b&ecirc;n ngo&agrave;i bất k&igrave; h&agrave;m n&agrave;o. Để l&agrave;m việc n&agrave;y bạn cần khai b&aacute;o ch&uacute;ng b&ecirc;n ngo&agrave;i mọi h&agrave;m hay c&aacute;c khối lệnh, c&oacute; nghĩa l&agrave; ngay trong th&acirc;n chương tr&igrave;nh.&nbsp;<br />\r\n#include&lt;stdio.h&gt;<br />\r\n#include&lt;conio.h&gt;<br />\r\nint a, b, t, s;<br />\r\nint tich(int a,int b)<br />\r\n{<br />\r\n<br />\r\nt = a*b;<br />\r\nreturn(t);<br />\r\n}<br />\r\nvoid main()<br />\r\n{<br />\r\nprintf(&quot;nhap vao 2 so muon tinh tich\n&quot;);<br />\r\nscanf_s(&quot;%d%d&quot;, &amp;a, &amp;b);<br />\r\ns = tich(a, b);<br />\r\nprintf(&quot;tich =%d&quot;, s);<br />\r\n_getch();<br />\r\n<br />\r\n}<br />\r\n&nbsp;</p>\r\n\r\n<p>&nbsp;c&aacute;c c&aacute;ch kh&aacute;c nhau m&agrave; một h&agrave;m c&oacute; thể được gọi.&nbsp;</p>\r\n\r\n<p>1. tich(a,b); &nbsp; với a,b l&agrave; biến đ&atilde; c&oacute; gi&aacute; trị</p>\r\n\r\n<p>2.tich(12,7); &nbsp;ta thay trực tiếp gi&aacute; trị v&agrave; h&agrave;m.</p>\r\n\r\n<p>h&agrave;m c&oacute; thể đươc gọi ra ngay trong lệnh xuất của ng&ocirc;n ngữ c++. hay trong c&aacute;c ph&eacute;p t&iacute;nh to&aacute;n như l&agrave; 1 số b&igrave;nh thường.</p>\r\n\r\n<ul>\r\n	<li><strong>c&aacute;c h&agrave;m kh&ocirc;ng kiểu, c&aacute;ch sử dụng void:</strong></li>\r\n</ul>\r\n\r\n<p>Nếu bạn c&ograve;n nhớ c&uacute; ph&aacute;p của một lời khai b&aacute;o h&agrave;m: &nbsp;</p>\r\n\r\n<p>type name ( argument1, argument2 ...) statement&nbsp;</p>\r\n\r\n<p>bạn sẽ thấy r&otilde; r&agrave;ng rằng n&oacute; bắt đầu với một t&ecirc;n kiểu, đ&oacute; l&agrave; kiểu dữ liệu sẽ được h&agrave;m trả về bởi lệnh return. Nhưng nếu ch&uacute;ng ta kh&ocirc;ng muốn trả về gi&aacute; trị n&agrave;o th&igrave; sao ?&nbsp;</p>\r\n\r\n<p>H&atilde;y tưởng tượng rằng ch&uacute;ng ta muốn tạo ra một h&agrave;m chỉ để hiển thị một th&ocirc;ng b&aacute;o l&ecirc;n m&agrave;n h&igrave;nh. N&oacute; kh&ocirc;ng cần trả về một gi&aacute; trị n&agrave;o cả, hơn nữa cũng kh&ocirc;ng cần nhận tham số n&agrave;o hết. V&igrave; vậy người ta đ&atilde; nghĩ ra kiểu dữ liệu void trong ng&ocirc;n ngữ C. H&atilde;y xem x&eacute;t chương tr&igrave;nh sau:</p>\r\n\r\n<p>#include&lt;stdio.h&gt;</p>\r\n\r\n<p>#include&lt;conio.h&gt;</p>\r\n\r\n<p>void in(void)</p>\r\n\r\n<p>{</p>\r\n\r\n<p>printf(&quot;in ra man hinh&quot;);</p>\r\n\r\n<p>}</p>\r\n\r\n<p>void main()</p>\r\n\r\n<p>{</p>\r\n\r\n<p>in();</p>\r\n\r\n<p>_getch();</p>\r\n\r\n<p>}</p>\r\n\r\n<p>Từ kho&aacute; void trong phần danh s&aacute;ch tham số c&oacute; nghĩa l&agrave; h&agrave;m n&agrave;y kh&ocirc;ng nhận một tham số n&agrave;o. Tuy nhi&ecirc;n trong C kh&ocirc;ng cần thiết phải sử dụng void để l&agrave;m điều n&agrave;y. Bạn chỉ đơn giản sử dụng cặp ngoặc đơn ( ) l&agrave; xong</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>1.Truyền tham số theo tham số gi&aacute; trị hay tham số biến</strong><br />\r\nCho đến nay, trong tất cả c&aacute;c h&agrave;m ch&uacute;ng ta đ&atilde; biết, tất cả c&aacute;c tham số truyền cho h&agrave;m đều được truyền theo gi&aacute; trị. Điều n&agrave;y c&oacute; nghĩa l&agrave; khi ch&uacute;ng ta gọi h&agrave;m với c&aacute;c tham số, những g&igrave; ch&uacute;ng ta truyền cho h&agrave;m l&agrave; c&aacute;c gi&aacute; trị chứ kh&ocirc;ng phải bản th&acirc;n c&aacute;c biến. V&iacute; dụ, giả sử ch&uacute;ng ta gọi h&agrave;m&nbsp;tich&nbsp;như sau:<br />\r\nint x=5, y=3, z;&nbsp;<br />\r\nz=tich(x,y);<br />\r\nTrong trường hợp n&agrave;y khi ch&uacute;ng ta gọi h&agrave;m addition th&igrave; c&aacute;c gi&aacute; trị 5 and 3 được truyền cho h&agrave;m, kh&ocirc;ng phải l&agrave; bản th&acirc;n c&aacute;c biến.<br />\r\n#include&lt;stdio.h&gt;<br />\r\n#include&lt;conio.h&gt;<br />\r\nvoid nhandoi(int&amp;a, int&amp;b)<br />\r\n{<br />\r\na *= 2;<br />\r\nb *= 2;<br />\r\n}<br />\r\nvoid main()<br />\r\n{<br />\r\nint x, y;<br />\r\nprintf(&quot;nhap vao a,b:\n&quot;);<br />\r\nscanf_s(&quot;%d%d&quot;, &amp;x, &amp;y);<br />\r\nnhandoi(x, y);<br />\r\nprintf(&quot; %d &nbsp;%d &quot;, x, y);<br />\r\n_getch();<br />\r\n}<br />\r\nĐiều đầu ti&ecirc;n l&agrave;m bạn ch&uacute; &yacute; l&agrave; trong khai b&aacute;o của duplicate theo sau t&ecirc;n kiểu của mỗi tham số đều l&agrave; dấu v&agrave; (&amp;), để b&aacute;o hiệu rằng c&aacute;c tham số n&agrave;y được truyền theo tham số biến chứ kh&ocirc;ng phải tham số gi&aacute; trị.<br />\r\n<br />\r\nKhi truyền tham số dưới dạng tham số biến ch&uacute;ng ta đang truyền bản th&acirc;n biến đ&oacute; v&agrave; bất k&igrave; sự thay đổi n&agrave;o m&agrave; ch&uacute;ng ta thực hiện với tham số đ&oacute; b&ecirc;n trong h&agrave;m sẽ ảnh hưởng trực tiếp đến biến đ&oacute;.<br />\r\nTruyền tham số dưới dạng tham số biến cho ph&eacute;p một h&agrave;m trả về nhiều hơn một gi&aacute; trị. V&iacute; dụ, đ&acirc;y l&agrave; một h&agrave;m trả về số liền trước v&agrave; liền sau của tham số đầu ti&ecirc;n<br />\r\n#include&lt;stdio.h&gt;<br />\r\n#include&lt;conio.h&gt;<br />\r\nvoid tinh(int x, int&amp;next, int&amp;prev)<br />\r\n{<br />\r\nnext = x + 1;<br />\r\nprev = x - 1;<br />\r\n}<br />\r\nvoid main()<br />\r\n{<br />\r\nint x,y,z;<br />\r\nprintf(&quot;nhap vao 1 so&quot;);<br />\r\nscanf_s(&quot;%d&quot;, &amp;x);<br />\r\ntinh(x, y, z);<br />\r\nprintf(&quot;%d %d %d&quot;, z,x,y);<br />\r\n_getch();<br />\r\n}<br />\r\n<strong>2.Gi&aacute; trị mặc định của tham số</strong><br />\r\nKhi định nghĩa một h&agrave;m ch&uacute;ng ta c&oacute; thể chỉ định những gi&aacute; trị mặc định sẽ được truyền cho c&aacute;c đối số trong trường hợp ch&uacute;ng bị bỏ qua khi h&agrave;m được gọi. Để l&agrave;m việc n&agrave;y đơn giản chỉ cần g&aacute;n một gi&aacute; trị cho đối số khi khai b&aacute;o h&agrave;m. Nếu gi&aacute; trị của tham số đ&oacute; vẫn được chỉ định khi gọi h&agrave;m th&igrave; gi&aacute; trị mặc định sẽ bị bỏ qua. V&iacute; dụ<br />\r\n#include&lt;stdio.h&gt;<br />\r\n#include&lt;conio.h&gt;<br />\r\nint tinh(int x,int y=2)<br />\r\n{<br />\r\nint chia;<br />\r\nchia = x / y;<br />\r\nreturn(chia);<br />\r\n}<br />\r\nvoid main()<br />\r\n{<br />\r\nprintf(&quot;thieu 1 tham so =%d \n&quot;, tinh(12));<br />\r\nprintf(&quot;du tham so=%d\n&quot;, tinh(20, 4));<br />\r\n_getch();<br />\r\n}<br />\r\nc&oacute; hai tham số, bởi vậy gi&aacute; trị mặc định sẽ được bỏ qua. Kết quả của h&agrave;m sẽ l&agrave; 5 (20/4)<br />\r\n<strong>3.Qu&aacute; tải c&aacute;c h&agrave;m</strong><br />\r\nHai h&agrave;m c&oacute; thể c&oacute; cũng t&ecirc;n nếu khai b&aacute;o tham số của ch&uacute;ng kh&aacute;c nhau, điều n&agrave;y c&oacute; nghĩa l&agrave; bạn c&oacute; thể đặt c&ugrave;ng một t&ecirc;n cho nhiều h&agrave;m nếu ch&uacute;ng c&oacute; số tham số kh&aacute;c nhau hay kiểu dữ liệu của c&aacute;c tham số kh&aacute;c nhau (hay thậm ch&iacute; l&agrave; kiểu dữ liệu trả về kh&aacute;c nhau).<br />\r\n<strong>4.đệ quy</strong><br />\r\nC&aacute;c h&agrave;m c&oacute; thể gọi ch&iacute;nh n&oacute;. Điều n&agrave;y c&oacute; thể c&oacute; &iacute;ch với một số t&aacute;c vụ như l&agrave; một số phương ph&aacute;p sắp xếp hay t&iacute;nh giai thừa của một số. V&iacute; dụ, để t&iacute;nh giai thừa của một số (n), c&ocirc;ng thức to&aacute;n học của n&oacute; như sau:<br />\r\nn! = n * (n-1) * (n-2) * (n-3) ... * 1&nbsp;<br />\r\nv&agrave; một h&agrave;m đệ qui để t&iacute;nh to&aacute;n sẽ như sau:<br />\r\n#include&lt;stdio.h&gt;<br />\r\n#include&lt;conio.h&gt;<br />\r\nunsigned long giaithua(unsigned long x)<br />\r\n{<br />\r\nif (x&gt;1) return(x*giaithua(x-1));<br />\r\nelse return(1);<br />\r\n<br />\r\n}<br />\r\nvoid main()<br />\r\n{<br />\r\nunsigned long a;<br />\r\nprintf(&quot;nhap vao so can tinh giai thua\n&quot;);<br />\r\nscanf_s(&quot;%lu&quot;, &amp;a);<br />\r\nprintf(&quot;%lu! = %lu&quot;, a, giaithua(a));<br />\r\n_getch();<br />\r\n}<br />\r\n<strong>5.Khai b&aacute;o mẫu cho h&agrave;m</strong><br />\r\nCho đến giờ ch&uacute;ng ta ho&agrave;n to&agrave;n phải định nghĩa h&agrave;m trước lệnh gọi đầu ti&ecirc;n đến n&oacute;, m&agrave; thường l&agrave; trong main, v&igrave; vậy h&agrave;m main lu&ocirc;n phải nằm cuối chương tr&igrave;nh. Nếu bạn thử lặp lại một v&agrave;i v&iacute; dụ về h&agrave;m trước đ&acirc;y nhưng thử đặt h&agrave;m main trước bất k&igrave; một h&agrave;m được gọi từ n&oacute;, bạn gần như chắc chắn sẽ nhận được th&ocirc;ng b&aacute;o lỗi. Nguy&ecirc;n nh&acirc;n l&agrave; một h&agrave;m phải được khai b&aacute;o trước khi n&oacute; được gọi như nhưnggx g&igrave; ch&uacute;ng ta đ&atilde; l&agrave;m trng tất cả c&aacute;c v&iacute; dụ<br />\r\nNhưng c&oacute; một c&aacute;ch kh&aacute;c để tr&aacute;nh phải viết tất cả m&atilde; chương tr&igrave;nh trước khi ch&uacute;ng c&oacute; thể được d&ugrave;ng trong main hay bất k&igrave; một h&agrave;m n&agrave;o kh&aacute;c. Đ&oacute; ch&iacute;nh l&agrave; khai b&aacute;o mẫu cho h&agrave;m. C&aacute;ch n&agrave;y bao gồm việc khai b&aacute;o h&agrave;m một c&aacute;ch ngắn gọn nhưng đủ để cho tr&igrave;nh dịch c&oacute; thể biết c&aacute;c tham số v&agrave; kiểu dữ liệu trả về của h&agrave;m.<br />\r\nDạng của n&oacute; như sau:<br />\r\n<em>type name ( argument_type1, argument_type2, ...);&nbsp;</em></p>\r\n\r\n<p>Đ&acirc;y ch&iacute;nh l&agrave; phần đầu của định nghĩa h&agrave;m, ngoại trừ:</p>\r\n\r\n<ul>\r\n	<li>N&oacute; kh&ocirc;ng c&oacute; bất k&igrave; lệnh n&agrave;o cho h&agrave;m. Điều n&agrave;y c&oacute; nghĩa l&agrave; n&oacute; kh&ocirc;ng bao gồm th&acirc;n h&agrave;m với tất cả c&aacute;c lệnh thường được bọc trong cặp ngoặc nhọn { }</li>\r\n	<li>N&oacute; kết th&uacute;c bằng dấu chấm phẩy (;).&nbsp;</li>\r\n	<li>Trong phần liệt k&ecirc; c&aacute;c tham số chỉ cần viết kiểu của ch&uacute;ng l&agrave; đủ. Việc viết t&ecirc;n của c&aacute;c tham số trong phần khai b&aacute;o mẫu l&agrave; kh&ocirc;ng bắt buộc</li>\r\n</ul>\r\n\r\n<p>V&iacute; dụ:<br />\r\n#include&lt;stdio.h&gt;<br />\r\n#include&lt;conio.h&gt;<br />\r\nunsigned long giaithua(unsigned long);<br />\r\nvoid main()<br />\r\n{<br />\r\nunsigned long a;<br />\r\nprintf(&quot;nhap vao so can tinh giai thua\n&quot;);<br />\r\nscanf_s(&quot;%lu&quot;, &amp;a);<br />\r\nprintf(&quot;%lu! = %lu&quot;, a, giaithua(a));<br />\r\n_getch();<br />\r\n}<br />\r\nunsigned long giaithua(unsigned long x)<br />\r\n{<br />\r\nif (x&gt;1) return(x*giaithua(x - 1));<br />\r\nelse return(1);<br />\r\n<br />\r\n}<br />\r\nV&iacute; dụ n&agrave;y r&otilde; r&agrave;ng kh&ocirc;ng phải l&agrave; một v&iacute; dụ về sự hiệu quả. T&ocirc;i chắc chắn rằng c&aacute;c bạn c&oacute; thể nhận được kết quả như tr&ecirc;n chỉ với một nửa số d&ograve;ng lệnh. Tuy nhi&ecirc;n n&oacute; gi&uacute;p cho ch&uacute;ng ta thấy được việc khai b&aacute;o mẫu c&aacute;c h&agrave;m l&agrave; như thế n&agrave;o<br />\r\nRất nhiều lập tr&igrave;nh vi&ecirc;n kinh nghiệm khuy&ecirc;n rằng tất cả c&aacute;c h&agrave;m n&ecirc;n được khai b&aacute;o mẫu. Đ&oacute; cũng l&agrave; lời khuy&ecirc;n của t&ocirc;i, nhất l&agrave; trong trường hợp c&oacute; nhiều h&agrave;m hoặc ch&uacute;ng rất d&agrave;i, khi đ&oacute; việc khai b&aacute;o tất cả c&aacute;c h&agrave;m ở c&ugrave;ng một chỗ cho ph&eacute;p ch&uacute;ng ta biết phải gọi c&aacute;c h&agrave;m như thế n&agrave;o, v&igrave; vậy tiết kiệm được thời gian</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-01', 1, 1, NULL),
(22, 'mảng một 1 chiều trong lập trình', '<p>Mảng l&agrave; một d&atilde;y c&aacute;c phần tử c&oacute; c&ugrave;ng kiểu được đặt li&ecirc;n tiếp trong bộ nhớ v&agrave; c&oacute; thể truy xuất đến từng phần tử bằng c&aacute;ch th&ecirc;m một chỉ số v&agrave;o sau t&ecirc;n của mảngĐiều n&agrave;y c&oacute; nghĩa l&agrave;, v&iacute; dụ, ch&uacute;ng ta c&oacute; thể lưu 5 gi&aacute; trị kiểu int m&agrave; kh&ocirc;ng cần phải khai b&aacute;o 5 biến kh&aacute;c nhau.V&iacute; dụ, một mảng chứa 5 gi&aacute; trị nguy&ecirc;n kiểu int c&oacute; t&ecirc;n l&agrave;&nbsp;A&nbsp;kiểuint</p>\r\n\r\n<table border="1" cellpadding="0" cellspacing="0">\r\n	<tbody>\r\n		<tr>\r\n			<td style="width:128px">0</td>\r\n			<td style="width:128px">1</td>\r\n			<td style="width:128px">2</td>\r\n			<td style="width:128px">3</td>\r\n			<td style="width:128px">4</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>trong đ&oacute; mỗi một &ocirc; trống biểu diễn một phần tử của mảng, trong trường hợp n&agrave;y l&agrave; c&aacute;c gi&aacute; trị nguy&ecirc;n kiểu int. Ch&uacute;ng được đ&aacute;nh số từ 0 đến 4 v&igrave; phần tử đầu ti&ecirc;n của mảng lu&ocirc;n l&agrave; 0 bất kể độ d&agrave;i của n&oacute; l&agrave; bao nhi&ecirc;u</p>\r\n\r\n<p>Như bất k&igrave; biến n&agrave;o kh&aacute;c, một mảng phải được khai b&aacute;o trước khi c&oacute; thể sử dụng. Một khai b&aacute;o điển h&igrave;nh cho một mảng trong C như sau:&nbsp;</p>\r\n\r\n<p><em>type name [elements];</em></p>\r\n\r\n<p>trong đ&oacute; type l&agrave; một kiểu dữ liệu hợp lệ (int, float...), name l&agrave; một t&ecirc;n biến hợp lệ v&agrave; trường elements chỉ định mảng đ&oacute; sẽ chứa bao nhi&ecirc;u phần tử &nbsp;</p>\r\n\r\n<p>V&igrave; vậy, để khai b&aacute;o&nbsp;A&nbsp;như đ&atilde; tr&igrave;nh b&agrave;y ở tr&ecirc;n ch&uacute;ng ta chỉ cần một d&ograve;ng đơn giản như sau</p>\r\n\r\n<p>int A[5];</p>\r\n\r\n<p>Ch&uacute; &yacute;: Trường elements &nbsp;b&ecirc;n trong cặp ngoặc [] phải l&agrave; một gi&aacute; trị hằng khi khai b&aacute;o một mảng, v&igrave; mảng l&agrave; một khối nhớ tĩnh c&oacute; k&iacute;ch cỡ x&aacute;c định v&agrave; tr&igrave;nh bi&ecirc;n dịch phải c&oacute; khả năng x&aacute;c định xem cần bao nhi&ecirc;u bộ nhớ để cấp ph&aacute;t cho mảng trước khi c&aacute;c lệnh c&oacute; thể được thực hiện</p>\r\n\r\n<p><strong>1.Khởi tạo một mảng</strong></p>\r\n\r\n<p>Khi khai b&aacute;o một mảng với tầm hoạt động địa phương (trong một h&agrave;m), theo mặc định n&oacute; sẽ kh&ocirc;ng được khởi tạo, v&igrave; vậy nội dung của n&oacute; l&agrave; kh&ocirc;ng x&aacute;c định cho đến khi ch&uacute;ng ra lưu c&aacute;c gi&aacute; trị l&ecirc;n đ&oacute;.&nbsp;</p>\r\n\r\n<p>Nếu ch&uacute;ng ta khai b&aacute;o một mảng to&agrave;n cục (b&ecirc;n ngo&agrave;i tất cả c&aacute;c h&agrave;m) n&oacute; sẽ được khởi tạo v&agrave; tất cả c&aacute;c phần tử được đặt bằng 0</p>\r\n\r\n<p>Nhưng th&ecirc;m v&agrave;o đ&oacute;, khi ch&uacute;ng ta khai b&aacute;o một mảng, ch&uacute;ng ta c&oacute; thể g&aacute;n c&aacute;c gi&aacute; trị khởi tạo cho từng phần tử của n&oacute;.&nbsp;&nbsp;V&iacute; dụ:&nbsp;</p>\r\n\r\n<p>int A [5] = { 16, 2, 77, 40, 12071 };</p>\r\n\r\n<p>lệnh tr&ecirc;n sẽ khai b&aacute;o một mảng như sau</p>\r\n\r\n<table border="1" cellpadding="0" cellspacing="0">\r\n	<tbody>\r\n		<tr>\r\n			<td style="width:128px">\r\n			<p>16</p>\r\n			</td>\r\n			<td style="width:128px">\r\n			<p>2</p>\r\n			</td>\r\n			<td style="width:128px">\r\n			<p>77</p>\r\n			</td>\r\n			<td style="width:128px">\r\n			<p>40</p>\r\n			</td>\r\n			<td style="width:128px">\r\n			<p>12071</p>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>Số phần tử trong mảng m&agrave; ch&uacute;ng ta khởi tạo với cặp ngoặc nhọn { } phải bằng số phần tử của mảng đ&atilde; được khai b&aacute;o với cặp ngoặc vu&ocirc;ng [ ]. Bởi v&igrave; điều n&agrave;y c&oacute; thể được coi l&agrave; một sự lặp lại kh&ocirc;ng cần thiết n&ecirc;n C cho ph&eacute;p để trống giữa cặp ngoặc vu&ocirc;ng, k&iacute;ch thước của mảng được x&aacute;c định bằng số gi&aacute; trị giữa cặp ngoặc nhọn.&nbsp;</p>\r\n\r\n<p><strong>2.Truy xuất đến c&aacute;c phần tử của mảng</strong></p>\r\n\r\n<p>Ở bất k&igrave; điểm n&agrave;o của chương tr&igrave;nh trong tầm hoạt động của mảng, ch&uacute;ng ta c&oacute; thể truy xuất từng phần tử của mảng để đọc hay chỉnh sửa như l&agrave; đối với một biến b&igrave;nh thường.&nbsp;</p>\r\n\r\n<p>V&iacute; dụ, để lưu gi&aacute; trị 75 v&agrave;o phần tử thứ ba của billy ta viết như sau:</p>\r\n\r\n<p>billy[2] = 75;&nbsp;</p>\r\n\r\n<p>v&agrave;, v&iacute; dụ, để g&aacute;n gi&aacute; trị của phần tử thứ 3 của billy cho biến a, ch&uacute;ng ta viết</p>\r\n\r\n<p>a = billy[2];&nbsp;</p>\r\n\r\n<p>V&igrave; vậy, x&eacute;t về mọi phương diện, biểu thức billy[2] giống như bất k&igrave; một biến kiểu int. &nbsp;</p>\r\n\r\n<p>Ch&uacute; &yacute; rằng phần tử thứ ba của billy l&agrave; billy[2], v&igrave; mảng bắt đầu từ chỉ số 0. V&igrave; vậy, phần tử cuối c&ugrave;ng sẽ l&agrave; billy[4]. V&igrave; vậy nếu ch&uacute;ng ta viết billy[5], ch&uacute;ng ta sẽ truy xuất đến phần tử thứ 6 của mảng v&agrave; vượt qu&aacute; giới hạn của mảngTrong C, việc vượt qu&aacute; giới hạn chỉ số của mảng l&agrave; ho&agrave;n to&agrave;n hợp lệ, tuy nhi&ecirc;n n&oacute; c&oacute; thể g&acirc;y ra những vấn đề thực sự kh&oacute; ph&aacute;t hiện bởi v&igrave; ch&uacute;ng kh&ocirc;ng tạo ra những lỗi trong qu&aacute; tr&igrave;nh dịch nhưng ch&uacute;ng c&oacute; thể tạo ra những kết quả kh&ocirc;ng mong muốn trong qu&aacute; tr&igrave;nh thực hiện. Nguy&ecirc;n nh&acirc;n của việc n&agrave;y sẽ được n&oacute;i đến kĩ hơn khi ch&uacute;ng ta bắt đầu sử dụng con trỏ. &nbsp;</p>\r\n\r\n<p>Cần phải nhấn mạnh rằng ch&uacute;ng ta sử dụng cặp ngoặc vu&ocirc;ng cho hai t&aacute;c vụ: đầu ti&ecirc;n l&agrave; đặt k&iacute;ch thước cho mảng khi khai b&aacute;o ch&uacute;ng v&agrave; thứ hai, để chỉ định chỉ số cho một phần tử cụ thể của mảng khi xem x&eacute;t đến n&oacute;</p>\r\n\r\n<p>int billy[5]; &nbsp; &nbsp; &nbsp; &nbsp; // khai b&aacute;o một mảng mới.&nbsp;</p>\r\n\r\n<p>billy[2] = 75; &nbsp; &nbsp; &nbsp; &nbsp;// truy xuất đến một phần tử của mảng.</p>\r\n\r\n<p><strong>v&iacute; dụ về mảng đơn giản như sau:</strong><br />\r\n#include&lt;stdio.h&gt;<br />\r\n#include&lt;conio.h&gt;<br />\r\nint mang[5];<br />\r\nvoid main()<br />\r\n{<br />\r\nint i;<br />\r\nfor (i = 0; i &lt;= 4; i++)<br />\r\n{<br />\r\nprintf(&quot;nhap phan tu mang[%d]=&quot;, i);<br />\r\nscanf_s(&quot;%d&quot;, &amp;mang[i]);<br />\r\nprintf(&quot;\n&quot;);<br />\r\n}<br />\r\nprintf(&quot;mang ban da nhap la:\n&quot;);<br />\r\nfor (i = 0; i &lt;= 4; i++)<br />\r\n{<br />\r\nprintf(&quot; %d &quot;, mang[i]);<br />\r\n}<br />\r\n<br />\r\n}</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-01', 1, 1, NULL),
(23, 'mảng nhiều chiều, đa chiều trong c', '<p>Mảng nhiều chiều c&oacute; thể được coi như mảng của mảng, v&iacute; dụ, một mảng hai chiều c&oacute; thể được tưởng tược như l&agrave; một bảng hai chiều gồm c&aacute;c phần tử c&oacute; kiểu dữ liệu cụ thể v&agrave; giống nhau</p>\r\n\r\n<table border="1" cellpadding="0" cellspacing="0">\r\n	<tbody>\r\n		<tr>\r\n			<td style="width:128px">0</td>\r\n			<td style="width:128px">1</td>\r\n			<td style="width:128px">2</td>\r\n			<td style="width:128px">3</td>\r\n			<td style="width:128px">4</td>\r\n		</tr>\r\n		<tr>\r\n			<td style="width:128px">0</td>\r\n			<td style="width:128px">1</td>\r\n			<td style="width:128px">2</td>\r\n			<td style="width:128px">3</td>\r\n			<td style="width:128px">\r\n			<p>4</p>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>Mảng nhiều chiều kh&ocirc;ng bị giới hạn bởi hai chỉ số (hai chiều), Ch&uacute;ng c&oacute; thể chứa bao nhiều chỉ số t&ugrave;y th&iacute;ch mặc d&ugrave; &iacute;t kh&iacute; cần phải d&ugrave;ng đến mảng lớn hơn 3 chiều. H&atilde;y thử xem x&eacute;t lượng bộ nhớ m&agrave; một mảng c&oacute; nhiều chỉ số cần đến.</p>\r\n\r\n<p>char century [100][365][24][60][60];&nbsp;</p>\r\n\r\n<p>Mảng nhiều chiều thực ra l&agrave; một kh&aacute;i niệm trừu tượng v&igrave; ch&uacute;ng ta c&oacute; thể c&oacute; kết quả tương tự với mảng một chiều bằng một thao t&aacute;c đơn giản giữa c&aacute;c chỉ số của n&oacute;:&nbsp;</p>\r\n\r\n<p>int jimmy [3][5]; &nbsp; tương đương với int jimmy [15]; &nbsp; (3 * 5 = 15)</p>\r\n\r\n<p><strong>v&iacute; dụ sau đ&acirc;y khai b&aacute;o, nhập gi&aacute; trị v&agrave;o mảng v&agrave; in ra m&agrave;n h&igrave;nh mảng vừa nhập;</strong></p>\r\n\r\n<table border="1" cellpadding="0" cellspacing="0">\r\n	<tbody>\r\n		<tr>\r\n			<td style="width:128px">\r\n			<p>1</p>\r\n			</td>\r\n			<td style="width:128px">\r\n			<p>2</p>\r\n			</td>\r\n			<td style="width:128px">\r\n			<p>3</p>\r\n			</td>\r\n			<td style="width:128px">\r\n			<p>4</p>\r\n			</td>\r\n			<td style="width:128px">\r\n			<p>5</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td style="width:128px">\r\n			<p>6</p>\r\n			</td>\r\n			<td style="width:128px">\r\n			<p>7</p>\r\n			</td>\r\n			<td style="width:128px">\r\n			<p>8</p>\r\n			</td>\r\n			<td style="width:128px">\r\n			<p>9</p>\r\n			</td>\r\n			<td style="width:128px">\r\n			<p>10</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td style="width:128px">\r\n			<p>11</p>\r\n			</td>\r\n			<td style="width:128px">\r\n			<p>12</p>\r\n			</td>\r\n			<td style="width:128px">\r\n			<p>13</p>\r\n			</td>\r\n			<td style="width:128px">\r\n			<p>14</p>\r\n			</td>\r\n			<td style="width:128px">\r\n			<p>15</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td style="width:128px">\r\n			<p>16</p>\r\n			</td>\r\n			<td style="width:128px">\r\n			<p>17</p>\r\n			</td>\r\n			<td style="width:128px">\r\n			<p>18</p>\r\n			</td>\r\n			<td style="width:128px">\r\n			<p>19</p>\r\n			</td>\r\n			<td style="width:128px">\r\n			<p>20</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td style="width:128px">\r\n			<p>21</p>\r\n			</td>\r\n			<td style="width:128px">\r\n			<p>22</p>\r\n			</td>\r\n			<td style="width:128px">\r\n			<p>23</p>\r\n			</td>\r\n			<td style="width:128px">\r\n			<p>24</p>\r\n			</td>\r\n			<td style="width:128px">\r\n			<p>25</p>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>#include&lt;stdio.h&gt;</p>\r\n\r\n<p>#include&lt;conio.h&gt;</p>\r\n\r\n<p>int mang[5][5];</p>\r\n\r\n<p>void main()</p>\r\n\r\n<p>{</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>int i, j;</p>\r\n\r\n<p>for (i = 0; i &lt;= 4; i++)</p>\r\n\r\n<p>for (j = 0; j &lt;= 4; j++)</p>\r\n\r\n<p>{</p>\r\n\r\n<p>printf(&quot;mang[%d][%d]=&quot;, i, j);</p>\r\n\r\n<p>scanf_s(&quot;%d&quot;, &amp;mang[i][j]);</p>\r\n\r\n<p>printf(&quot;\n&quot;);</p>\r\n\r\n<p>}</p>\r\n\r\n<p>printf(&quot;mang ban da nhap la:\n&quot;);</p>\r\n\r\n<p>for (i = 0; i &lt;= 4; i++)</p>\r\n\r\n<p>{</p>\r\n\r\n<p>for (j = 0; j &lt;= 4; j++)</p>\r\n\r\n<p>{</p>\r\n\r\n<p>printf(&quot;%4d&quot;, mang[i][j]);</p>\r\n\r\n<p>}</p>\r\n\r\n<p>printf(&quot;\n&quot;);</p>\r\n\r\n<p>}</p>\r\n\r\n<p>_getch();</p>\r\n\r\n<p>}</p>\r\n\r\n<p><strong>*d&ugrave;ng mảng l&agrave;m tham số</strong></p>\r\n\r\n<p>V&agrave;o một l&uacute;c n&agrave;o đ&oacute; c&oacute; thể ch&uacute;ng ta cần phải truyền một mảng tới một h&agrave;m như l&agrave; một tham số. Trong C, việc truyền theo tham số gi&aacute; trị một khối nhớ l&agrave; kh&ocirc;ng hợp lệ, ngay cả khi n&oacute; được tổ chức th&agrave;nh một mảng. Tuy nhi&ecirc;n ch&uacute;ng ta lại được ph&eacute;p truyền địa chỉ của n&oacute;, việc n&agrave;y cũng tạo ra kết quả thực tế giống thao t&aacute;c ở tr&ecirc;n nhưng lại nhanh hơn nhiều v&agrave; hiệu quả hơn</p>\r\n\r\n<p>Để c&oacute; thể nhận mảng l&agrave; tham số th&igrave; điều duy nhất ch&uacute;ng ta phải l&agrave;m khi khai b&aacute;o h&agrave;m l&agrave; chỉ định trong phần tham số kiểu dữ liệu cơ bản của mảng, t&ecirc;n mảng v&agrave; cặp ngoặc vu&ocirc;ng trống. V&iacute; dụ, h&agrave;m sau</p>\r\n\r\n<p>void procedure (int arg[])&nbsp;</p>\r\n\r\n<p>nhận v&agrave;o một tham số c&oacute; kiểu &quot;mảng của char&quot; v&agrave; c&oacute; t&ecirc;n arg. Để truyền tham số cho h&agrave;m n&agrave;y một mảng được khai b&aacute;o</p>\r\n\r\n<p>int myarray [40];&nbsp;</p>\r\n\r\n<p>chỉ cần gọi h&agrave;m như sau:&nbsp;</p>\r\n\r\n<p>procedure (myarray);&nbsp;</p>\r\n\r\n<p>Dưới đ&acirc;y l&agrave; một v&iacute; dụ cụ thể&nbsp;</p>\r\n\r\n<p>#include&lt;stdio.h&gt;<br />\r\n#include&lt;conio.h&gt;<br />\r\nvoid in_mang(int arg[])<br />\r\n{<br />\r\nfor (int n = 0; n &lt;= 4; n++)<br />\r\n{<br />\r\nprintf(&quot;%3d&quot;, arg[n]);<br />\r\n}<br />\r\n}<br />\r\nint mang[5];<br />\r\nvoid main()<br />\r\n{<br />\r\nint i;<br />\r\nfor (i = 0; i &lt;= 4; i++)<br />\r\n{<br />\r\nprintf(&quot;mang[%d]=&quot;,i);<br />\r\nscanf_s(&quot;%d&quot;, &amp;mang[i]);<br />\r\nprintf(&quot;\n&quot;);<br />\r\n}<br />\r\nin_mang(mang);<br />\r\n_getch();<br />\r\n}<br />\r\nNhư bạn c&oacute; thể thấy, tham số đầu ti&ecirc;n (int arg[]) chấp nhận mọi mảng c&oacute; kiểu cơ bản l&agrave; int<br />\r\nTrong phần khai b&aacute;o h&agrave;m ch&uacute;ng ta cũng c&oacute; thể d&ugrave;ng tham số l&agrave; c&aacute;c mảng nhiều chiều<br />\r\nv&iacute; dụ, một h&agrave;m với tham số l&agrave; mảng nhiều chiều c&oacute; thể như sau:<br />\r\nvoid procedure (int myarray[][3][4])&nbsp;<br />\r\nch&uacute; &yacute; rằng cặp ngoặc vu&ocirc;ng đầu ti&ecirc;n để trống nhưng c&aacute;c cặp ngoặc sau th&igrave; kh&ocirc;ng. Bạn lu&ocirc;n lu&ocirc;n phải l&agrave;m vậy v&igrave; tr&igrave;nh bi&ecirc;n dịch C phải c&oacute; khả năng x&aacute;c định độ lớn của c&aacute;c chiều th&ecirc;m v&agrave;o của mảng.<br />\r\nDưới đ&acirc;y l&agrave; một v&iacute; dụ cụ thể<br />\r\n#include&lt;stdio.h&gt;<br />\r\n#include&lt;conio.h&gt;<br />\r\nvoid in_mang(int a[][5],int h)<br />\r\n{<br />\r\nfor (int i = 0; i &lt;= h-1; i++)<br />\r\n{<br />\r\nfor (int j = 0; j &lt;= 4;j++)<br />\r\n{<br />\r\nprintf(&quot;%4d&quot;, a[i][j]);<br />\r\n}<br />\r\nprintf(&quot;\n&quot;);<br />\r\n}<br />\r\n}<br />\r\nint mang1[3][5];<br />\r\nint mang2[4][5];<br />\r\nvoid main()<br />\r\n{<br />\r\nfor (int i = 0; i &lt;= 3; i++)<br />\r\n{<br />\r\nfor (int j = 0; j &lt;= 4; j++)<br />\r\n{<br />\r\nprintf(&quot;mang1[%d][%d]=&quot;, i, j);<br />\r\nscanf_s(&quot;%d&quot;, &amp;mang1[i][j]);<br />\r\nprintf(&quot;\n&quot;);<br />\r\n}<br />\r\n}<br />\r\nfor (int a = 0; a &lt;= 3; a++)<br />\r\n{<br />\r\nfor (int b = 0; b &lt;= 4; b++)<br />\r\n{<br />\r\nprintf(&quot;mang2[%d][%d]=&quot;, a, b);<br />\r\nscanf_s(&quot;%d&quot;, &amp;mang2[a][b]);<br />\r\nprintf(&quot;\n&quot;);<br />\r\n}<br />\r\n}<br />\r\nprintf(&quot;mang 1 la:\n&quot;);<br />\r\nin_mang(mang1, 3);<br />\r\nprintf(&quot;mang 2 la:\n&quot;);<br />\r\nin_mang(mang2, 4);<br />\r\n_getch();<br />\r\n<br />\r\n}</p>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-01', 7, 1, NULL);
INSERT INTO `baiviet` (`idbv`, `subject`, `content`, `image_bv`, `parent`, `date_add`, `views`, `author`, `des`) VALUES
(24, 'lớp class trong lập trình c++', '<p>&nbsp;</p>\r\n\r\n<p>Một lớp bao gồm c&aacute;c th&agrave;nh phần dữ liệu (thuộc t&iacute;nh) v&agrave; c&aacute;c phương thức (h&agrave;m th&agrave;nh phần).<br />\r\nLớp trong C++ thực chất l&agrave; một kiểu dữ liệu do người sử dụng định nghĩa.<br />\r\nTrong C++, d&ugrave;ng từ kh&oacute;a class để chỉ điểm bắt đầu của một lớp sẽ được c&agrave;i đặt.<br />\r\nLớp l&agrave; một m&ocirc; tả trừu tượng của nh&oacute;m c&aacute;c đối tượng c&ugrave;ng bản chất, ngược lại mỗi một đối tượng l&agrave; một thể hiện cụ thể cho những m&ocirc; tả trừu tượng đ&oacute;.<br />\r\nLớp l&agrave; c&aacute;i ta thiết kế v&agrave; lập tr&igrave;nh<br />\r\n<a name="more"></a><br />\r\nĐối tượng l&agrave; c&aacute;i ta tạo (từ một lớp) tại thời gian chạy.<br />\r\nclass &lt;t&ecirc;n_lớp&gt;&nbsp;<br />\r\n{<br />\r\n//Th&agrave;nh phần dữ liệu<br />\r\n<br />\r\n//Th&agrave;nh phần xử l&yacute;<br />\r\n};<br />\r\nclass &lt;t&ecirc;n_lớp&gt; {<br />\r\n&nbsp; private:<br />\r\n&nbsp; &nbsp;&lt;khai b&aacute;o th&agrave;nh phần ri&ecirc;ng trong từng đối tượng&gt;<br />\r\n&nbsp; protected:<br />\r\n&nbsp; &nbsp;&lt;khai b&aacute;o th&agrave;nh phần ri&ecirc;ng trong từng đối tượng, c&oacute; thể truy cập từ lớp dẫn xuất &gt;<br />\r\n&nbsp; public:<br />\r\n&nbsp; &nbsp; &lt;khai b&aacute;o th&agrave;nh phần c&ocirc;ng cộng&gt;<br />\r\n};<br />\r\nThuộc t&iacute;nh: C&aacute;c thuộc t&iacute;nh được khai b&aacute;o giống như khai b&aacute;o biến trong C<br />\r\nPhương thức: C&aacute;c phương thức được khai b&aacute;o giống như khai b&aacute;o h&agrave;m trong C. C&oacute; hai c&aacute;ch định nghĩa thi h&agrave;nh của một phương thức<br />\r\nĐịnh nghĩa thi h&agrave;nh trong lớp<br />\r\nĐịnh nghĩa thi h&agrave;nh ngo&agrave;i lớp<br />\r\ncơ chế tạo lập c&aacute;c lớp<br />\r\nX&aacute;c định c&aacute;c thuộc t&iacute;nh (dữ liệu)<br />\r\nNhững g&igrave; m&agrave; ta biết về đối tượng &ndash; giống như một struct<br />\r\nX&aacute;c định c&aacute;c phương thức (h&igrave;nh vi)<br />\r\nNhững g&igrave; m&agrave; đối tượng c&oacute; thể l&agrave;m<br />\r\nX&aacute;c định c&aacute;c quyền truy xuất<br />\r\nSẽ tr&igrave;nh b&agrave;y sau<br />\r\nĐịnh nghĩa c&aacute;c h&agrave;m th&agrave;nh phần ở b&ecirc;n ngo&agrave;i khai b&aacute;o lớp:<br />\r\n&lt;t&ecirc;n kiểu gi&aacute; trị trả về&gt; &lt;t&ecirc;n lớp&gt;::&lt;t&ecirc;n h&agrave;m&gt; (&lt;danh s&aacute;ch tham số&gt;)&nbsp;<br />\r\n{<br />\r\n&lt;nội dung &gt;<br />\r\n}<br />\r\nV&iacute; dụ:<br />\r\nvoid point::display() {&nbsp;<br />\r\n//&hellip;&hellip;..<br />\r\n}<br />\r\n&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-01', 1, 1, NULL),
(25, 'tạo lập đối tượng trong c++', '<p>*tạo lập đối tượng<br />\r\nKhai b&aacute;o v&agrave; tạo đối tượng:<br />\r\n&lt;t&ecirc;n lớp&gt; &nbsp;&lt;t&ecirc;n đối tượng&gt;;<br />\r\nGọi h&agrave;m th&agrave;nh phần của lớp<br />\r\n&lt;t&ecirc;n đối tượng&gt;.&lt;t&ecirc;n h&agrave;m th&agrave;nh phần&gt; (&lt;danh s&aacute;ch c&aacute;c tham số nếu c&oacute;&gt;);<br />\r\n&lt;t&ecirc;n con trỏ đối tượng&gt;&lt;t&ecirc;n h&agrave;m th&agrave;nh phần&gt; (&lt;danh s&aacute;ch c&aacute;c tham số nếu c&oacute;&gt;);<br />\r\n<a name="more"></a><br />\r\nclass &nbsp;Time {<br />\r\n&nbsp; public:&nbsp;<br />\r\nvoid Set (int &nbsp;hours , int &nbsp;minutes , int &nbsp;seconds);<br />\r\nvoid &nbsp;Increment ( );<br />\r\nvoid &nbsp;Write ( ) &nbsp;const;<br />\r\nTime (int &nbsp;initHrs, int &nbsp;initMins, &nbsp;int &nbsp;initSecs ); //constructor&nbsp;<br />\r\nTime ( );&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//default constructor<br />\r\n&nbsp; private:<br />\r\nint &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hrs; &nbsp; &nbsp; &nbsp;&nbsp;<br />\r\nint &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mins;<br />\r\nint &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; secs;<br />\r\n} ;<br />\r\nX&acirc;y dựng lớp Điểm (Point) trong h&igrave;nh học 2D<br />\r\nThuộc t&iacute;nh<br />\r\nTung độ<br />\r\nHo&agrave;nh độ<br />\r\nThao t&aacute;c (phương thức)<br />\r\nKhởi tạo<br />\r\nDi chuyển<br />\r\nIn ra m&agrave;n h&igrave;nh<br />\r\n&hellip;<br />\r\n/*point.cpp*/<br />\r\n#include &lt;iostream.h&gt;<br />\r\n#include &lt;conio.h&gt;<br />\r\nclass point {<br />\r\n&nbsp;&nbsp; /*khai b&aacute;o c&aacute;c th&agrave;nh phần dữ &nbsp;liệu ri&ecirc;ng*/<br />\r\n&nbsp;&nbsp; private:<br />\r\n&nbsp; &nbsp;&nbsp; int x,y;<br />\r\n&nbsp; &nbsp;/*khai b&aacute;o c&aacute;c h&agrave;m th&agrave;nh phần c&ocirc;ng cộng*/<br />\r\n&nbsp;&nbsp; public:&nbsp;<br />\r\n&nbsp; &nbsp;&nbsp; void init(int ox, int oy);<br />\r\n&nbsp; &nbsp;&nbsp; void move(int dx, int dy);<br />\r\n&nbsp; &nbsp;&nbsp; void display();<br />\r\n&nbsp; &nbsp; };<br />\r\nvoid point::init(int ox, int oy) {<br />\r\n&nbsp;&nbsp; cout&lt;&lt;&quot;Ham thanh phan init\n&quot;;<br />\r\n&nbsp; &nbsp; &nbsp;x = ox; y = oy;&nbsp;<br />\r\n/*x,y l&agrave; c&aacute;c th&agrave;nh phần của đối tượng gọi h&agrave;m th&agrave;nh phần*/<br />\r\n&nbsp; }<br />\r\nvoid point::move(int dx, int dy) {<br />\r\n&nbsp;&nbsp; cout&lt;&lt;&quot;Ham thanh phan move\n&quot;;<br />\r\n&nbsp; &nbsp;x += dx; y += dy;<br />\r\n&nbsp; }<br />\r\nvoid point::display() {<br />\r\n&nbsp;&nbsp; cout&lt;&lt;&quot;Ham thanh phan display\n&quot;;<br />\r\n&nbsp;&nbsp; cout&lt;&lt;&quot;Toa do: &quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot;\n&quot;;<br />\r\n&nbsp; }<br />\r\nvoid main() {<br />\r\n&nbsp;&nbsp; point p;<br />\r\n&nbsp;&nbsp; p.init(2,4); /*gọi h&agrave;m th&agrave;nh phần từ đối tượng*/<br />\r\n&nbsp;&nbsp; p.display();<br />\r\n&nbsp;&nbsp; p.move(1,2);<br />\r\n&nbsp;&nbsp; p.display();<br />\r\n&nbsp; }</p>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-01', 5, 1, NULL),
(26, 'cơ bản về thư viện string - STL C++', '<p>&nbsp;</p>\r\n\r\n<p>khai b&aacute;o thư viện string STL<br />\r\n#include&lt;string&gt;<br />\r\nusing namespace std;<br />\r\nstring s;<br />\r\n+,+= : ph&eacute;p nối chuỗi.<br />\r\ns=&quot;tran khanh toan&quot; : ph&eacute;p g&aacute;n chuỗi<br />\r\n==,!=,&gt;=,&gt;,&lt;,&lt;= : c&aacute;c ph&eacute;p so s&aacute;nh chuỗi<br />\r\n[] : ph&eacute;p lấy chỉ số để duyệt c&aacute;c k&yacute; tự của chuỗi<br />\r\ns.length() : lấy chiều d&agrave;i của chuỗi<br />\r\ncout&lt;&lt; v&agrave; cin&gt;&gt; trong iostream để xuất chuỗi ra m&agrave;n h&igrave;nh, ri&ecirc;ng cin th&igrave; chỉ lấy chuỗi đến khi gặp khoản trắng th&igrave; dừng<br />\r\n<a name="more"></a><br />\r\ns.front() : trả về tham chiếu đến phần tử đầu ti&ecirc;n của chuỗi. v&iacute; dụ cout&lt;&lt;s.front(); //t<br />\r\ns.back() : trả về tham chiếu đến ph&agrave;n tử cuối c&ugrave;ng của chuỗi. v&iacute; dụ cout&lt;&lt;s.back(); //n<br />\r\ns.size() : dung lượng cảu chuỗi s;<br />\r\ns.max_size() : trả về dung lượng tối đa của chuỗi.<br />\r\ns.empty() : trả về 1 (true) nếu chuỗi rỗng, trả về 0(false) nếu chuỗi kh&ocirc;ng rỗng.<br />\r\ngetline(cin,s); : nhập v&agrave;o chuỗi string<br />\r\ns.substr(vị tr&iacute; bắt đầu, số k&yacute; tự); trả về tham chiếu đến chuỗi sub string ch&eacute;p được.<br />\r\ns.insert(int vị tr&iacute;, mảng k&yacute; tự kiểu char hoặc chuỗi string); ch&egrave;n mảng k&yacute; tự kiểu char hoặc chuỗi string v&agrave;o chuỗi string s;<br />\r\ns.insert(int vị tr&iacute;, int n,char k&yacute; tự); ch&egrave;n n lần k&yacute; tự v&agrave;o chuỗi string s bắt đầu từ vị tr&iacute; x&aacute;c định trong c&uacute; ph&aacute;p.<br />\r\ns.erase(int i vị tr&iacute; bắt đầu, int n số k&yacute; tự cần x&oacute;a); x&oacute;a n k&yacute; tự từ vị tr&iacute; i.<br />\r\ns.compare(chuỗi string hoặc mảng k&yacute; tự char); trả về 1 nếu s lớn hơn v&agrave; trả về -1 nếu s nhỏ hơn, trả về 0 nếu bằng nhau.<br />\r\ns.compare(int i vị tr&iacute; bắt đầu, int vị tr&iacute; kết thuc của substr(s), so s&aacute;nh với chuỗi string hoặc mảng k&yacute; tự); trả về như tr&ecirc;n<br />\r\ns.compare(int i vị tr&iacute; bắt đầu, vị tr&iacute; kết th&uacute;c của substr(s), string s2,vị tr&iacute; bắt đầu, vị tr&iacute; kết th&uacute;c của substr(s2)); trả về như tr&ecirc;n<br />\r\ns.find(char hoặc string hoặc char *, int pos=0); t&igrave;m k&yacute; tự, string hoặc mảng k&yacute; tự trong chuỗi s, bắt đầu từ vị tr&iacute; pos, pos được khai b&aacute;o mặc nhi&ecirc;n, nếu kh&ocirc;ng th&ecirc;m vị tr&iacute; pos v&agrave;o th&igrave; pos mặc định =0<br />\r\ns.rfind(char hoặc string hoặc char *); t&igrave;m ngược sự xuất hiện của string hoặc char trong string s; trả về vị tr&iacute; đầu ti&ecirc;n xuất hiện của chuỗi được t&igrave;m thấy, kh&ocirc;ng t&igrave;m thấy trả về -1<br />\r\ns.replace(int pos, int n,char * hoặc string); thay thế chuỗi substr(s) vị tr&iacute; pos n k&yacute; tự th&agrave;nh chuỗi string đưa v&agrave;o.<br />\r\n&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-01', 12, 1, NULL),
(27, 'cơ bản thư viện vector STL C++', '<p>khai b&aacute;o thư viện<br />\r\n#include&lt;vector&gt;<br />\r\nusing namespace std;<br />\r\nvector &lt;int&gt; a; khai b&aacute;o 1 vector kiểu int.kh&ocirc;ng cần khai b&aacute;o số phần tử của vector, n&oacute; sẽ tự n&acirc;ng bộ nhớ l&ecirc;n. hoặc nếu mu&ocirc;n c&oacute; thể khai bao như sau<br />\r\nvetor &lt;int&gt; a(10); khai b&aacute;o 1 vector c&oacute; 10 phần tử.mặc d&ugrave; khai b&aacute;o 10 phần tử như vậy nhưng n&oacute; ho&agrave;n to&agrave;n c&oacute; thể tự n&acirc;ng l&ecirc;n khi ta sử dụng hơn.<br />\r\n*c&aacute;c kiểu khai bai b&aacute;o mặc định gi&aacute; trị ban đầu cho vector:<br />\r\nvector &lt;int&gt; a(10,2); khai b&aacute;o vector c&oacute; 10 phần tử v&agrave; c&aacute;c phần tủ c&oacute; gi&aacute; trị ban đầu l&agrave; 2;<br />\r\nvector &lt;int&gt; a(vector b); tạo vector a l&agrave; bản sao của vactor b<br />\r\nvector &lt;int&gt; a(vector b.begin(),b.begin()+5); sao ch&eacute;p v&agrave;o vector a 5 phần tử dầu ti&ecirc;n của vector b;<br />\r\n[] : ph&eacute;p lấy chỉ số ho&agrave;n to&agrave;n giống với mảng<br />\r\n<a name="more"></a><br />\r\na.size(); trả về k&iacute;ch thước của vector, gồm bao nhi&ecirc;u phần tử.<br />\r\na.resize(); định lại k&iacute;ch thước của vector.<br />\r\na.front(); trả về th&acirc;m chiếu đến phần tử đầu ti&ecirc;n.<br />\r\na.back(); trả về tham chiếu đến phần tử cuối c&ugrave;ng.<br />\r\na.push_back(int x); tọa th&ecirc;m 1 phần tử c&oacute; gi&aacute; trị int x v&agrave; nối n&oacute; v&agrave;o cuối vector a tức lầ vector a c&oacute; th&ecirc;m 1 phần tử c&oacute; gi&aacute; trị x được th&ecirc;m v&agrave;o cuối c&ugrave;ng.<br />\r\na.pop_back(); x&oacute;a phần tử cuối c&ugrave;ng<br />\r\na.clear(); x&oacute;a to&agrave;n bộ c&aacute;c phần tử vector;<br />\r\na.erase(a.begin()+4); x&oacute;a phần tử c&oacute; chỉ số l&agrave; 4 hay vị tr&iacute; thứ 5 như ta t&iacute;nh thong thường<br />\r\na.erase(a.begin()+2,a.begin()+5); x&oacute;a c&aacute;c phần tử c&oacute; chỉ số l&agrave; 2 đến phần tử c&oacute; chỉ số l&agrave; 5<br />\r\na.insert(a.begin()+3,200); ch&egrave;n 200 v&agrave;o vị tr&iacute; c&oacute; chỉ số l&agrave; 3.<br />\r\na.insert(a.begin()+3,2,400); ch&egrave;n 2 lần số 400 v&agrave;o vector từ vị tr&iacute; c&oacute; chỉ số l&agrave; 3.<br />\r\nint b[]={1,3,5,7,9};<br />\r\na.insert(a.begin()+3,b,b+4); ch&egrave;n 4 phần tử sủ mảng b v&agrave;o a từ vị tr&iacute; c&oacute; chỉ số l&agrave; 3.<br />\r\na.insert(a.begin()+4,c.begin(),c.end()); ch&egrave;n lu&ocirc;n mảng c v&agrave;o mảng a t&iacute;nh từ vị tri c&oacute; chỉ số l&agrave; 4;<br />\r\na.empty(); trả về true nếu mảng rỗng v&agrave; false nếu mảng kh&ocirc;ng rỗng<br />\r\na.swap(b); ho&aacute;n đổi 2 container với nhau, giống như ho&aacute;n đổi 2 &nbsp;số th&ocirc;ng thường.</p>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-01', 426, 1, NULL),
(31, 'Các Hàm Xử Lý Chuỗi Hay Sử Dụng', '<h2>addcslashes ($str, $char_list)</h2>\r\n\r\n<p>H&agrave;m n&agrave;y sẽ th&ecirc;m dấu gạch ch&eacute;o () đằng trước những k&yacute; tự trong chuỗi $str m&agrave; ta liệt k&ecirc; ở $char_list.</p>\r\n\r\n<table border="0" cellpadding="0" cellspacing="0">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<p>1</p>\r\n\r\n			<p>2</p>\r\n\r\n			<p>3</p>\r\n\r\n			<p>4</p>\r\n\r\n			<p>5</p>\r\n\r\n			<p>6</p>\r\n\r\n			<p>7</p>\r\n\r\n			<p>8</p>\r\n			</td>\r\n			<td>\r\n			<p><code>// a..z l&agrave; gồm c&aacute;c từ từ a =&gt; z</code></p>\r\n\r\n			<p><code>echo</code> <code>(</code><code>addcslashes</code><code>(</code><code>&#39;freetuts.net FREETUTS.NET&#39;</code><code>,&nbsp;</code><code>&#39;a..z&#39;</code><code>));</code></p>\r\n\r\n			<p><code>// kết quả: f\ree	u	s.\ne	</code></p>\r\n\r\n			<p><code>&nbsp;</code>&nbsp;</p>\r\n\r\n			<p><code>echo</code> <code>&#39;&lt;br /&gt;&#39;</code><code>;</code></p>\r\n\r\n			<p><code>&nbsp;</code>&nbsp;</p>\r\n\r\n			<p><code>// a..zA..Z l&agrave; gồm c&aacute;c từ từ a =&gt; z v&agrave; A =&gt; Z</code></p>\r\n\r\n			<p><code>echo</code> <code>(</code><code>addcslashes</code><code>(</code><code>&#39;freetuts.net FREETUTS.NET&#39;</code><code>,&nbsp;</code><code>&#39;a..zA..Z&#39;</code><code>));</code></p>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p><strong>addslashes ( $str )</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>H&agrave;m n&agrave;y sẽ th&ecirc;m dấu g&aacute;ch ch&eacute;o trước những k&yacute; tự (&lsquo;, &ldquo;, ) trong chuỗi $str.</p>\r\n\r\n<table border="0" cellpadding="0" cellspacing="0">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<p>1</p>\r\n\r\n			<p>2</p>\r\n			</td>\r\n			<td>\r\n			<p><code>echo</code> <code>addslashes</code> <code>(</code><code>&quot;Freetuts&#39;s a website learning online&quot;</code><code>);</code></p>\r\n\r\n			<p><code>// Kết quả l&agrave; Freetuts&#39;s a website learning online</code></p>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p><strong>stripslashes ($str)</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>H&agrave;m n&agrave;y ngược với h&agrave;m addslashes, n&oacute; x&oacute;a c&aacute;c k&yacute; tự  trong chuỗi $str.</p>\r\n\r\n<table border="0" cellpadding="0" cellspacing="0">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<p>1</p>\r\n\r\n			<p>2</p>\r\n			</td>\r\n			<td>\r\n			<p><code>echo</code> <code>stripslashes</code><code>(</code><code>&quot;Mot so ham &#39;xu ly chuoi&#39; trong PHP&quot;</code><code>);</code></p>\r\n\r\n			<p><code>// Kết quả Mot so ham &#39;xu ly chuoi&#39; trong PHP</code></p>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p><strong>crc32 ( $str )</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>H&agrave;m n&agrave;y sẽ chuyển chuỗi $str th&agrave;nh một d&atilde;y số nguy&ecirc;n (c&oacute; thể &acirc;m hoặc dương t&ugrave;y theo hệ điều h&agrave;nh).</p>\r\n\r\n<table border="0" cellpadding="0" cellspacing="0">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<p>1</p>\r\n\r\n			<p>2</p>\r\n			</td>\r\n			<td>\r\n			<p><code>echo</code> <code>crc32 (</code><code>&#39;freetuts.net&#39;</code><code>);</code></p>\r\n\r\n			<p><code>// kết quả: -838644060</code></p>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p><strong>explode ( $delimiter , $string)</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>H&agrave;m n&agrave;y sẽ chuyển một chuỗi&nbsp;<strong>$string</strong>&nbsp;th&agrave;nh một mảng c&aacute;c phần tử với k&yacute; tự t&aacute;ch mảng l&agrave; $<strong>delimiter.</strong><br />\r\n&nbsp;</p>\r\n\r\n<table border="0" cellpadding="0" cellspacing="0">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<p>1</p>\r\n\r\n			<p>2</p>\r\n\r\n			<p>3</p>\r\n\r\n			<p>4</p>\r\n\r\n			<p>5</p>\r\n\r\n			<p>6</p>\r\n\r\n			<p>7</p>\r\n\r\n			<p>8</p>\r\n\r\n			<p>9</p>\r\n\r\n			<p>10</p>\r\n\r\n			<p>11</p>\r\n\r\n			<p>12</p>\r\n\r\n			<p>13</p>\r\n\r\n			<p>14</p>\r\n\r\n			<p>15</p>\r\n			</td>\r\n			<td>\r\n			<p><code>&lt;strong&gt;</code><code>// Chuỗi cần chuyển&lt;br /&gt;</code></p>\r\n\r\n			<p><code>$str</code> <code>=&nbsp;</code><code>&#39;freetuts.net is a website free for you&#39;</code><code>;</code></p>\r\n\r\n			<p><code>&nbsp;</code>&nbsp;</p>\r\n\r\n			<p><code>// Mỗi khoảng trắng sẽ l&agrave; một phần tử trong mảng&lt;br /&gt;</code></p>\r\n\r\n			<p><code>var_dump(</code><code>explode</code><code>(</code><code>&#39; &#39;</code><code>,&nbsp;</code><code>$str</code><code>));</code></p>\r\n\r\n			<p><code>&nbsp;</code>&nbsp;</p>\r\n\r\n			<p><code>/*Kết quả</code></p>\r\n\r\n			<p><code>array</code></p>\r\n\r\n			<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>0 =&gt; &#39;freetuts.net&#39;,</code></p>\r\n\r\n			<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>1 =&gt; &#39;is&#39;,</code></p>\r\n\r\n			<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>2 =&gt; &#39;a&#39; ,</code></p>\r\n\r\n			<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>3 =&gt; &#39;website&#39;,</code></p>\r\n\r\n			<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>4 =&gt; &#39;free&#39;,</code></p>\r\n\r\n			<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>5 =&gt; &#39;for&#39; ,</code></p>\r\n\r\n			<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>6 =&gt; &#39;you&#39; */</code><code>&lt;/strong&gt;</code></p>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p><strong>implode($delimiter, $piecesarray);</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>H&agrave;m n&agrave;y ngược với h&agrave;m explode, n&oacute; chuyển một mảng&nbsp;$piecesarray th&agrave;nh chuỗi v&agrave; mỗi phần tử c&aacute;ch nhau bởi chuỗi $delimiter</p>\r\n\r\n<table border="0" cellpadding="0" cellspacing="0">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<p>1</p>\r\n\r\n			<p>2</p>\r\n\r\n			<p>3</p>\r\n\r\n			<p>4</p>\r\n\r\n			<p>5</p>\r\n\r\n			<p>6</p>\r\n\r\n			<p>7</p>\r\n\r\n			<p>8</p>\r\n			</td>\r\n			<td>\r\n			<p><code>echo</code> <code>implode(</code><code>&#39; &#39;</code><code>,&nbsp;</code><code>array</code><code>(</code></p>\r\n\r\n			<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>&#39;freetuts&#39;</code><code>,</code></p>\r\n\r\n			<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>&#39;xin&#39;</code><code>,</code></p>\r\n\r\n			<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>&#39;ch&agrave;o&#39;</code><code>,</code></p>\r\n\r\n			<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>&#39;c&aacute;c&#39;</code><code>,</code></p>\r\n\r\n			<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>&#39;bạn&#39;</code></p>\r\n\r\n			<p><code>));</code></p>\r\n\r\n			<p><code>// k&ecirc;t quả l&agrave; freetuts xin ch&agrave;o c&aacute;c bạn</code></p>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p><strong>ord ( $string )</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>H&agrave;m n&agrave;y trả về m&atilde; ASCII của k&yacute; tự đầu ti&ecirc;n trong chuỗi $string.</p>\r\n\r\n<table border="0" cellpadding="0" cellspacing="0">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<p>1</p>\r\n\r\n			<p>2</p>\r\n			</td>\r\n			<td>\r\n			<p><code>echo</code> <code>ord (</code><code>&#39;Ab&#39;</code><code>);</code></p>\r\n\r\n			<p><code>// kết quả: 65</code></p>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p><strong>strlen($string)</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>H&agrave;m n&agrave;y đếm số k&yacute; tự của chuỗi $string.</p>\r\n\r\n<table border="0" cellpadding="0" cellspacing="0">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<p>1</p>\r\n\r\n			<p>2</p>\r\n			</td>\r\n			<td>\r\n			<p><code>echo</code> <code>strlen</code><code>(</code><code>&#39;freetuts.net&#39;</code><code>);</code></p>\r\n\r\n			<p><code>// kết quả: 12</code></p>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p><strong>str_word_count($str)</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>H&agrave;m n&agrave;y trả về số từ trong chuỗi $str.</p>\r\n\r\n<table border="0" cellpadding="0" cellspacing="0">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<p>1</p>\r\n\r\n			<p>2</p>\r\n			</td>\r\n			<td>\r\n			<p><code>echo</code> <code>str_word_count</code><code>(</code><code>&#39;freetuts xin ch&agrave;o c&aacute;c bạn&#39;</code><code>);</code></p>\r\n\r\n			<p><code>// kết quả l&agrave; 5</code></p>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p><strong>str_repeat(&nbsp; $str,&nbsp; int $n&nbsp; )</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>H&agrave;m n&agrave;y lặp chuỗi $str $n lần.<br />\r\n&nbsp;</p>\r\n\r\n<table border="0" cellpadding="0" cellspacing="0">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<p>1</p>\r\n\r\n			<p>2</p>\r\n			</td>\r\n			<td>\r\n			<p><code>echo</code> <code>str_repeat</code><code>(&nbsp;</code><code>&#39;Hello&#39;</code><code>, 5 );</code></p>\r\n\r\n			<p><code>// Kết quả l&agrave; HelloHelloHelloHelloHello</code></p>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p><strong>str_replace( $chuoi_tim, $chuoi_thay_the, $chuoi_nguon )</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>H&agrave;m n&agrave;y t&igrave;m kiếm v&agrave; thay thế chuỗi.</p>\r\n\r\n<table border="0" cellpadding="0" cellspacing="0">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<p>1</p>\r\n\r\n			<p>2</p>\r\n\r\n			<p>3</p>\r\n			</td>\r\n			<td>\r\n			<p><code>$str</code> <code>=&nbsp;</code><code>&#39;Freetuts Xin Ch&agrave;o C&aacute;c Bạn&#39;</code><code>;</code></p>\r\n\r\n			<p><code>$str</code> <code>=&nbsp;</code><code>str_replace</code><code>(&nbsp;</code><code>&#39;Freetuts&#39;</code><code>,&nbsp;</code><code>&#39;Freetuts.net&#39;</code><code>,&nbsp;</code><code>$str</code> <code>);</code></p>\r\n\r\n			<p><code>echo</code> <code>$str</code><code>;&nbsp;</code><code>// kết quả l&agrave; Freetuts.net Xin Ch&agrave;o C&aacute;c Bạn</code></p>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>Để thay thế nhiều chuỗi ta c&oacute; thể d&ugrave;ng mảng để truyền v&agrave;o</p>\r\n\r\n<table border="0" cellpadding="0" cellspacing="0">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<p>1</p>\r\n\r\n			<p>2</p>\r\n\r\n			<p>3</p>\r\n			</td>\r\n			<td>\r\n			<p><code>$str</code> <code>=&nbsp;</code><code>&#39;Freetuts Xin Ch&agrave;o C&aacute;c Bạn&#39;</code><code>;</code></p>\r\n\r\n			<p><code>$str</code> <code>=&nbsp;</code><code>str_replace</code><code>(&nbsp;</code><code>array</code><code>(</code><code>&#39;Freetuts&#39;</code><code>,&nbsp;</code><code>&#39;Xin Ch&agrave;o&#39;</code><code>),&nbsp;</code><code>array</code><code>(</code><code>&#39;Freetuts.net&#39;</code><code>,&nbsp;</code><code>&#39;Hello&#39;</code><code>),&nbsp;</code><code>$str</code> <code>);</code></p>\r\n\r\n			<p><code>echo</code> <code>$str</code><code>;&nbsp;</code><code>// kết quả l&agrave; Freetuts.net Hello C&aacute;c Bạn</code></p>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p><strong>md5( $str)</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>H&agrave;m n&agrave;y m&atilde; h&oacute;a chuỗi th&agrave;nh một d&atilde;y 32 k&yacute; tự (m&atilde; h&oacute;a md5).</p>\r\n\r\n<table border="0" cellpadding="0" cellspacing="0">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<p>1</p>\r\n\r\n			<p>2</p>\r\n			</td>\r\n			<td>\r\n			<p><code>echo</code> <code>md5(</code><code>&#39;freetuts.net&#39;</code><code>);</code></p>\r\n\r\n			<p><code>// Kết quả: 83617175fd8cf470d4af657a28def98e</code></p>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p><strong>sha1($string)</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>H&agrave;m n&agrave;y m&atilde; h&oacute;a chuỗi th&agrave;nh một d&atilde;y 40 k&yacute; tự (m&atilde; h&oacute;a sha1)</p>\r\n\r\n<table border="0" cellpadding="0" cellspacing="0">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<p>1</p>\r\n\r\n			<p>2</p>\r\n			</td>\r\n			<td>\r\n			<p><code>echo</code> <code>sha1(</code><code>&#39;freetuts.net&#39;</code><code>);</code></p>\r\n\r\n			<p><code>// kết quả 8d9fa09de2e997d8fbb544326b84d1f894cd3ca3</code></p>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p><strong>htmlentities($str)</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>H&agrave;m n&agrave;y chuyển c&aacute;c thể html trong chuỗi $str sang&nbsp; dạng thực thể của ch&uacute;ng (html sẽ ko c&ograve;n t&aacute;c dụng n&ecirc;n bạn c&oacute; thể echo ra b&ecirc;n ngo&agrave;i).</p>\r\n\r\n<table border="0" cellpadding="0" cellspacing="0">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<p>1</p>\r\n\r\n			<p>2</p>\r\n			</td>\r\n			<td>\r\n			<p><code>echo</code> <code>htmlentities(</code><code>&#39;&lt;b&gt;freetuts.net&lt;/b&gt;&#39;</code><code>);</code></p>\r\n\r\n			<p><code>// Kết quả &lt;b&gt;freetuts.net&lt;/b&gt;</code></p>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p><strong>html_entity_decode($string)</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Ngược lại với htmlentities, h&agrave;m n&agrave;y chuyển ngược c&aacute;c k&yacute; tự dạng thực thể HTML sang dạng k&yacute; tự của ch&uacute;ng.</p>\r\n\r\n<table border="0" cellpadding="0" cellspacing="0">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<p>1</p>\r\n\r\n			<p>2</p>\r\n\r\n			<p>3</p>\r\n\r\n			<p>4</p>\r\n			</td>\r\n			<td>\r\n			<p><code>$str</code> <code>= htmlentities(</code><code>&#39;&lt;b&gt;freetuts.net&lt;/b&gt;&#39;</code><code>);</code></p>\r\n\r\n			<p><code>&nbsp;</code>&nbsp;</p>\r\n\r\n			<p><code>echo</code> <code>&#39;Entity: &#39;</code> <code>.&nbsp;</code><code>$str</code> <code>.&nbsp;</code><code>&#39;&lt;br/&gt;&#39;</code><code>;</code></p>\r\n\r\n			<p><code>echo</code> <code>&#39;Decode: &#39;</code> <code>. html_entity_decode(</code><code>$str</code><code>);</code></p>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p><strong>htmlspecialchars( $string)</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Tương tự như htmlentities.<br />\r\n<strong>htmlspecialchars_decode($string)</strong></p>\r\n\r\n<p>Tương tự như html_entity_decode.</p>\r\n\r\n<p><strong>strip_tags( $string, $allow_tags )</strong></p>\r\n\r\n<p>H&agrave;m n&agrave;y bỏ c&aacute;c thẻ html trong chuỗi $string được khai b&aacute;o ở $allow_tags.</p>\r\n\r\n<table border="0" cellpadding="0" cellspacing="0">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<p>1</p>\r\n			</td>\r\n			<td>\r\n			<p><code>echo</code> <code>strip_tags</code><code>(</code><code>&#39;&lt;b&gt;freetuts.net&lt;/b&gt;&#39;</code><code>,&nbsp;</code><code>&#39;b&#39;</code><code>);</code></p>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p><strong>substr( $string,&nbsp; $start, $length )</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>H&agrave;m n&agrave;y lấy một chuỗi con nằm trong chuỗi $str bắt đầu từ k&yacute; tự thứ $start v&agrave; chiều d&agrave;i $length.</p>\r\n\r\n<table border="0" cellpadding="0" cellspacing="0">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<p>1</p>\r\n\r\n			<p>2</p>\r\n			</td>\r\n			<td>\r\n			<p><code>echo</code> <code>substr</code><code>(&nbsp;</code><code>&#39;freetuts.net&#39;</code><code>,&nbsp; 0, 8);</code></p>\r\n\r\n			<p><code>// Kết quả freetuts</code></p>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p><strong>strstr( $string, $ky_tu_cho_truoc )</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>T&aacute;ch một chuỗi bắt đầu từ&nbsp; $ky_tu_cho_truoc cho đến hết chuỗi.</p>\r\n\r\n<table border="0" cellpadding="0" cellspacing="0">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<p>1</p>\r\n\r\n			<p>2</p>\r\n			</td>\r\n			<td>\r\n			<p><code>echo</code> <code>strstr</code><code>(</code><code>&#39;freetuts.net Xin Ch&agrave;o&#39;</code><code>,&nbsp;</code><code>&#39;Xin&#39;</code><code>);</code></p>\r\n\r\n			<p><code>// Kết quả: Xin Ch&agrave;o</code></p>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p><strong>strpos($str, $chuoi_tim )</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>T&igrave;m vị tr&iacute; của chuỗi $chuoi_tim trong chuỗi $str, kết quả trả về false nếu kh&ocirc;ng t&igrave;m thấy.</p>\r\n\r\n<table border="0" cellpadding="0" cellspacing="0">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<p>1</p>\r\n\r\n			<p>2</p>\r\n			</td>\r\n			<td>\r\n			<p><code>echo</code> <code>strpos</code><code>(</code><code>&#39;freetuts.net ch&agrave;o c&aacute;c bạn&#39;</code><code>,&nbsp;</code><code>&#39;ch&agrave;o&#39;</code><code>);</code></p>\r\n\r\n			<p><code>// kết quả 13</code></p>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p><strong>strtolower($str);</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Chuyển tất cả c&aacute;c k&yacute; tự chuỗi $str sang chữ thường</p>\r\n\r\n<p><strong>strtoupper($string );</strong><br />\r\nChuyển tất cả c&aacute;c k&yacute; tự chuỗi $str sang chữ hoa</p>\r\n\r\n<p><strong>ucfirst( $string )</strong></p>\r\n\r\n<p>Chuyển k&yacute; tự đầu ti&ecirc;n chuỗi $string sang chữ hoa</p>\r\n\r\n<p><strong>ucfirst( $string )</strong></p>\r\n\r\n<p>Chuyển k&yacute; tự đầu ti&ecirc;n trong chuỗi $string sang chữ thường</p>\r\n\r\n<p><strong>ucwords( $string )</strong></p>\r\n\r\n<p>Chuy&ecirc;n từ đầu ti&ecirc;n trong chuỗi $string sang chữ hoa</p>\r\n\r\n<p><strong>trim($string, $ky_tu);</strong></p>\r\n\r\n<p>X&oacute;a k&yacute; tự $ky_tu nằm ở đầu v&agrave; cuối chuỗi $str, nếu ta kh&ocirc;ng nhập $ky_tu th&igrave; mặc định n&oacute; hiểu l&agrave; x&oacute;a khoảng trắng.</p>\r\n\r\n<table border="0" cellpadding="0" cellspacing="0">\r\n	<tbody>\r\n		<tr>\r\n			<td>\r\n			<p>1</p>\r\n\r\n			<p>2</p>\r\n\r\n			<p>3</p>\r\n\r\n			<p>4</p>\r\n\r\n			<p>5</p>\r\n			</td>\r\n			<td>\r\n			<p><code>echo</code> <code>trim(</code><code>&#39; freetuts.net &#39;</code><code>);</code></p>\r\n\r\n			<p><code>// kết quả: &#39;freetuts.net&#39;</code></p>\r\n\r\n			<p><code>&nbsp;</code>&nbsp;</p>\r\n\r\n			<p><code>echo</code> <code>trim(</code><code>&#39;freetuts.neth&#39;</code><code>);</code></p>\r\n\r\n			<p><code>// kết quả: &#39;freetuts.net&#39;</code></p>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p><strong>ltrim($string, $ky_tu);</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Tương tự như trim nhưng chỉ x&oacute;a b&ecirc;n tr&aacute;i</p>\r\n\r\n<p><strong>rtrim($string, $ky_tu)</strong></p>\r\n\r\n<p>Tương tự như trim nhưng chỉ x&oacute;a b&ecirc;n phải</p>\r\n\r\n<p><strong>nl2br($string)</strong></p>\r\n\r\n<p>Chuyển c&aacute;c k&yacute; tự xuống d&ograve;ng &ldquo;\n&rdquo; th&agrave;nh thẻ</p>\r\n\r\n<p><strong>json_decode($json, $is_array)</strong></p>\r\n\r\n<p>D&ugrave;ng để chuyển chuỗi dạng JSON sang c&aacute;c đối tượng mảng hoặc object. Nếu&nbsp;<strong>$is_array</strong>&nbsp;c&oacute; gi&aacute; trị false th&igrave; h&agrave;m sẽ chuyển một chuỗi $json th&agrave;nh một Class (object),&nbsp; ngược lại nếu&nbsp;<strong>$is_array</strong>&nbsp;c&oacute; gi&aacute; trị true th&igrave; sẽ chuyển chuỗi $json th&agrave;nh một mảng.</p>\r\n\r\n<p><strong>json_encode($array_or_object)</strong></p>\r\n\r\n<p>Chuyển một mảng hoặc mội đối tượng (classs) sang chuỗi dạng JSON</p>\r\n', '/admin/images_cm/php.png', 39, '2015-11-03', 10, 1, NULL),
(35, 'chương trình c tính tích hai 2 ma trận bất kì', '<pre class="brush:cpp;">\r\n/*chuong trinh c tinh tich hai ma tran bat ki*/\r\n#include&lt;stdio.h&gt;\r\n#include&lt;conio.h&gt;\r\n#define max 100\r\n/*tao ham nhap ma tran*/\r\nvoid nhap(int mt[max][max],int h,int c)\r\n{\r\n printf(&quot;nhap ma tran:\n _____________________________\n&quot;);\r\n for (int i = 0; i &lt; h; i++)\r\n {\r\n  printf(&quot;nhap hang %d:\n&quot;,i+1);\r\n  for (int j = 0; j &lt; c; j++)\r\n  {\r\n   scanf_s(&quot;%d&quot;, &amp;mt[i][j]);\r\n  }\r\n  printf(&quot;\n&quot;);\r\n }\r\n}\r\n/*tao ham xuat ma tran*/\r\nvoid xuat(int mt[max][max], int h, int c)\r\n{\r\n printf(&quot;__________________________\n&quot;);\r\n for (int i = 0; i &lt; h; i++)\r\n {\r\n  for (int j = 0; j &lt; c; j++)\r\n  {\r\n   printf(&quot;%6d&quot;, mt[i][j]);\r\n  }\r\n  printf(&quot;\n&quot;);\r\n }\r\n}\r\nint mt1[max][max];\r\nint mt2[max][max];\r\nint tich[max][max];\r\nvoid main()\r\n{\r\n printf(&quot;________author: Tran Khanh Toan____________\n___________________________\n&quot;);\r\n int h1, h2, c1, c2;\r\n /*nhap ma tran 1*/\r\n printf(&quot;&gt;&gt;&gt;ma tran 1\n&quot;);\r\n printf(&quot;nhap so hang: &quot;);\r\n scanf_s(&quot;%d&quot;, &amp;h1);\r\n printf(&quot;nhap so cot: &quot;);\r\n scanf_s(&quot;%d&quot;, &amp;c1);\r\n nhap(mt1, h1, c1);\r\n /*nhap ma tran 2*/\r\n printf(&quot;\n__________________________________\n &gt;&gt;&gt;ma tran 2\n&quot;);\r\n printf(&quot;nhap so hang: &quot;);\r\n scanf_s(&quot;%d&quot;, &amp;h2);\r\n printf(&quot;nhap so cot: &quot;);\r\n scanf_s(&quot;%d&quot;, &amp;c2);\r\n nhap(mt2, h2, c2);\r\n /*kiem tra hai ma colien hop khong\r\n neu khong lien hop thi ket thuc chuong trinh*/\r\n if (c1 != h2)\r\n {\r\n  printf(&quot;hai ma tran khong lien hop nen khong the tinh tich&quot;);\r\n  goto kt;\r\n }\r\n /*tinh tich 2 ma tran*/\r\n\r\n for (int i = 0; i &lt; h1; i++)\r\n {\r\n  for (int j = 0; j &lt; c2; j++)\r\n  {\r\n   for (int n = 0; n &lt; c1; n++)\r\n   {\r\n    tich[i][j] += mt1[i][n] * mt2[n][j];\r\n   }\r\n  }\r\n }\r\n printf(&quot;\n ________________________\n tich 2 ma tran do la: \n&quot;);\r\n xuat(tich, h1, c2);\r\nkt:;\r\n \r\n _getch();\r\n}\r\n/* a(i,1)*b(1,j)+a(i,2)*b(2,j)=c(i,j)    */</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 1, 1, NULL),
(36, 'đọc 1 số có 4 chữ số trong lập trình c', '<pre class="brush:cpp;">\r\n#include&lt;stdio.h&gt;\r\n#include&lt;conio.h&gt;\r\nvoid main()\r\n{\r\n int n,i, a[4];\r\n printf(&quot;nhap so co 4 chu so: &quot;);\r\n scanf_s(&quot;%d&quot;, &amp;n);\r\n if (n &gt; 999 &amp;&amp; n &lt; 10000)\r\n {\r\n  printf(&quot;doc la             : &quot;);\r\n  for (i = 0; i &lt; 4; i++)\r\n  {\r\n   a[i] = n % 10;\r\n   n = n / 10;\r\n  }\r\n  switch (a[3])\r\n  {\r\n  case 1:printf(&quot; mot &quot;); break;\r\n  case 2:printf(&quot; hai &quot;); break;\r\n  case 3:printf(&quot; ba &quot;); break;\r\n  case 4:printf(&quot; bon &quot;); break;\r\n  case 5:printf(&quot; nam &quot;); break;\r\n  case 6:printf(&quot; sau &quot;); break;\r\n  case 7:printf(&quot; bay &quot;); break;\r\n  case 8:printf(&quot; tam &quot;); break;\r\n  case 9:printf(&quot; chin &quot;); break;\r\n  }\r\n  printf(&quot; nghin &quot;);\r\n  switch (a[2])\r\n  {\r\n  case 1:printf(&quot; mot &quot;); break;\r\n  case 2:printf(&quot; hai &quot;); break;\r\n  case 3:printf(&quot; ba &quot;); break;\r\n  case 4:printf(&quot; bon &quot;); break;\r\n  case 5:printf(&quot; nam &quot;); break;\r\n  case 6:printf(&quot; sau &quot;); break;\r\n  case 7:printf(&quot; bay &quot;); break;\r\n  case 8:printf(&quot; tam &quot;); break;\r\n  case 9:printf(&quot; chin &quot;); break;\r\n  case 0:printf(&quot; khong &quot;); break;\r\n  }\r\n  printf(&quot; tram &quot;);\r\n  switch (a[1])\r\n  {\r\n  case 1:printf(&quot; mot muoi &quot;); break;\r\n  case 2:printf(&quot; hai muoi &quot;); break;\r\n  case 3:printf(&quot; ba muoi &quot;); break;\r\n  case 4:printf(&quot; bon muoi &quot;); break;\r\n  case 5:printf(&quot; nam muoi &quot;); break;\r\n  case 6:printf(&quot; sau muoi &quot;); break;\r\n  case 7:printf(&quot; bay muoi &quot;); break;\r\n  case 8:printf(&quot; tam muoi &quot;); break;\r\n  case 9:printf(&quot; chin muoi &quot;); break;\r\n  case 0:printf(&quot; le &quot;); break;\r\n  }\r\n  switch (a[0])\r\n  {\r\n  case 1:printf(&quot; mot \n&quot;); break;\r\n  case 2:printf(&quot; hai \n&quot;); break;\r\n  case 3:printf(&quot; ba \n&quot;); break;\r\n  case 4:printf(&quot; bon \n&quot;); break;\r\n  case 5:if (a[1] == 0) printf(&quot; nam \n&quot;);\r\n      else printf(&quot; lam \n&quot;); break;\r\n  case 6:printf(&quot; sau \n&quot;); break;\r\n  case 7:printf(&quot; bay \n&quot;); break;\r\n  case 8:printf(&quot; tam \n&quot;); break;\r\n  case 9:printf(&quot; chin \n&quot;); break;\r\n  }\r\n }\r\n else printf(&quot;nhap so khong dung&quot;);\r\n _getch();\r\n}</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 1, 1, NULL),
(37, 'tính tổng các chữ số của 1 số có 4 chữ số trong lập trình c', '<pre class="brush:cpp;">\r\n#include&lt;stdio.h&gt;\r\n#include&lt;conio.h&gt;\r\nvoid main()\r\n{\r\n int a, b, c, d, m;\r\n printf(&quot;nhap vao m co 4 chu so&quot;);\r\n scanf_s(&quot;%d&quot;, &amp;m);\r\n /*ph&acirc;n t&iacute;ch số đ&oacute; ra v&agrave; g&aacute;n v&agrave;o từng biến*/\r\n a = m / 1000;\r\n b = (m % 1000) / 100;\r\n c = (m % 100) / 10;\r\n d = m % 10;\r\n printf(&quot;tong cac chu so cua m la: %d&quot;, a + b + c + d);\r\n _getch();\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 1, 1, NULL),
(39, '[c++]tìm từ dài nhất trong chuỗi', '<pre class="brush:cpp;">\r\n#include&quot;stdio.h&quot;\r\n#include&quot;conio.h&quot;\r\n#include&quot;string.h&quot;\r\nchar *max(char *s)    \r\n{\r\n   char c[100], a[100];\r\n   int i, j, k, max = 0;\r\n   i = 0;  \r\n   while (s[i]!=&#39;o&#39;)//s[i] kh&ocirc;ng phải l&agrave; k&iacute; tự cuối c&ugrave;ng\r\n   {\r\n       j = 0; \r\n       if (s[i] != &#39; &#39;)//nếu k&yacute; tự đang x&eacute;t kh&aacute;c k&iacute; tự trắng\r\n   { \r\n   while (s[i] != &#39;o&#39;)   //lặp với số lần kh&ocirc;ng biết trước n&ecirc;n d&ugrave;ng while\r\n   {//khi k&iacute; tự c&ograve;n kh&aacute;c k&iacute; tự trắng\r\n       if (s[i] == &#39; &#39;) break;   //điều kiền để kết th&uacute;c v&ograve;ng lặp while l&agrave; gặp k&iacute; tự trắng\r\n       c[j] = s[i];//d&ugrave;ng mảng chuổi c để lưu c&aacute;c k&iacute; tự thỏa v&agrave; tăng i,j l&ecirc;n 1 đơn vị\r\n       j++; i++;//trong v&ograve;ng lặp đ&atilde; c&oacute; lệnh i++; rồi n&ecirc;n khi copy xong kh&ocirc;ng cần d&ugrave;ng lệnh i++;\r\n       //để thực hiện v&ograve;ng lặp nữa\r\n   } \r\n   c[j] = &#39;o&#39;;           //k&iacute; tự cuối c&ugrave;ng phải l&agrave; k&iacute; tự kết th&uacute;c để chuổi c&oacute; nghĩa\r\n   if (max &lt; strlen(c))  //nếu n&oacute; l&agrave; chuổi d&agrave;i hơn chuỗi max th&igrave; g&aacute;n gi&aacute; trị cho max\r\n   {//copy chuỗi v&agrave;o chuỗi a để lưu\r\n       max = strlen(c);\r\n       gets_s(a, c);\r\n   }\r\n}\r\nelse i++;  //nếu ban đầu n&oacute; l&agrave; k&iacute; tự trắng th&igrave; tăng i để tiếp tục lặp\r\n}    \r\n   return a;\r\n}\r\nvoid main()\r\n{\r\n   char s[255];\r\n   printf(&quot;nhap chuoi: &quot;); fflush(stdin); gets_s(s);\r\n   printf(&quot;tu dai nhat: %s\r\n&quot;, max(s));\r\n}</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 1, 1, NULL),
(40, 'lập trình giải mã mật thư Cesar', '<p>Cho một đoạn mật thư đ&atilde; được m&atilde; h&oacute;a th&agrave;nh những chuỗi k&iacute; tự 0,1 với mỗi 5 k&iacute; tự số sẽ tương ứng với một k&iacute; tự trong bảng chữ c&aacute;i alphabel. Thứ tự bảng m&atilde; sẽ giống với bảng chữ c&aacute;i alphabel (V&iacute; dụ a=00001 th&igrave; z=11010,a=01001 th&igrave; z=00001). Độ dịch của bảng&nbsp;<a href="http://www.laptrinh321.tk/2015/05/cc-lap-trinh-giai-ma-mat-thu-cesar.html">m&atilde;</a>sẽ l&agrave; một số ngẫu nhi&ecirc;n từ 1 đến 100, bạn phải t&igrave;m ra để c&oacute; được bảng m&atilde; đ&uacute;ng</p>\r\n\r\n<p>V&iacute; dụ: với a=00001</p>\r\n\r\n<p>01111011001100101101100000100100001 0100110100 sẽ được giải m&atilde; l&agrave; &ldquo;olympia it&rdquo;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>000110000110101 011000000100011 0001001111 000111000010100sẽ được giải m&atilde; l&agrave; &ldquo;cau lac bo cpt&rdquo;</p>\r\n\r\n<pre class="brush:cpp;">\r\n#include&lt;iostream&gt;  \r\n#include&lt;fstream&gt;  \r\n#include&lt;string&gt;  \r\nusing namespace std;  \r\nchar dich(string s,int i)  \r\n{  \r\n    if(s==&quot;00000&quot;) return 97-i;  \r\n    if(s==&quot;00001&quot;) return 98-i;  \r\n    if(s==&quot;00010&quot;) return 99-i;  \r\n    if(s==&quot;00011&quot;) return 100-i;  \r\n    if(s==&quot;00100&quot;) return 101-i;  \r\n    if(s==&quot;00101&quot;) return 102-i;  \r\n    if(s==&quot;00110&quot;) return 103-i;  \r\n    if(s==&quot;00111&quot;) return 104-i;  \r\n    if(s==&quot;01000&quot;) return 105-i;  \r\n    if(s==&quot;01001&quot;) return 106-i;  \r\n    if(s==&quot;01010&quot;) return 107-i;  \r\n    if(s==&quot;01011&quot;) return 108-i;  \r\n    if(s==&quot;01100&quot;) return 109-i;  \r\n    if(s==&quot;01101&quot;) return 110-i;  \r\n    if(s==&quot;01110&quot;) return 111-i;  \r\n    if(s==&quot;01111&quot;) return 112-i;  \r\n    if(s==&quot;10000&quot;) return 113-i;  \r\n    if(s==&quot;10001&quot;) return 114-i;  \r\n    if(s==&quot;10010&quot;) return 115-i;  \r\n    if(s==&quot;10011&quot;) return 116-i;  \r\n    if(s==&quot;10100&quot;) return 117-i;  \r\n    if(s==&quot;10101&quot;) return 118-i;  \r\n    if(s==&quot;10110&quot;) return 119-i;  \r\n    if(s==&quot;10111&quot;) return 120-i;  \r\n    if(s==&quot;11000&quot;) return 121-i;  \r\n    if(s==&quot;11001&quot;) return 122-i;  \r\n    if(s==&quot;11010&quot;) return 123-i;  \r\n    if(s==&quot;11011&quot;) return 124-i;  \r\n    if(s==&quot;11100&quot;) return 125-i;  \r\n    if(s==&quot;11101&quot;) return 126-i;  \r\n    if(s==&quot;11110&quot;) return 127-i;  \r\n    if(s==&quot;11111&quot;) return 128-i;  \r\n    return 48;  \r\n}  \r\nvoid main()  \r\n{  \r\n    fstream t(&quot;file1.inp&quot;,ios::in);  \r\n    fstream f(&quot;file1.out&quot;,ios::out);  \r\n    string s,c;  \r\n    char a;  \r\n    int i,j;  \r\n    for(int k=1;k&lt;100;k++)  \r\n    {  \r\n        while(!t.eof())  \r\n        {  \r\n            getline(t,s);  \r\n            i=0;  \r\n            while(i&lt;s.size())  \r\n            {  \r\n                c=s.substr(i,5);  \r\n                i+=5;  \r\n                a=dich(c,k);  \r\n                f&lt;&lt;a;  \r\n                if(s[i]==&#39; &#39;)  \r\n                {  \r\n                    i++;  \r\n                    f&lt;&lt;&quot; &quot;;  \r\n                }  \r\n            }  \r\n            f&lt;&lt;endl;  \r\n        }  \r\n        f&lt;&lt;endl;  \r\n        t.clear();  \r\n        t.seekg(0,ios::beg);  \r\n    }  \r\n    t.close();  \r\n    system(&quot;pause&quot;);  \r\n}  </pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 2, 1, NULL);
INSERT INTO `baiviet` (`idbv`, `subject`, `content`, `image_bv`, `parent`, `date_add`, `views`, `author`, `des`) VALUES
(41, 'lập trình c++ tính giá trị biểu thức toán học', '<p>viết chương tr&igrave;nh t&iacute;nh gi&aacute; trị của 1 biểu thức to&aacute;n học th&ocirc;ng thường với số thực, số nguy&ecirc;n đều được v&agrave; c&aacute;c ph&eacute;p to&aacute;n cộng + trừ - nh&acirc;n * chia / v&agrave; dấu ngoặc. thuật to&aacute;n n&agrave;y được thiết kế code c++ bởi Trần Kh&aacute;nh To&agrave;n, c&aacute;i hay của b&agrave;i n&agrave;y l&agrave; t&iacute;nh được cả số thực, c&aacute;c biểu thức nếu m&aacute;y t&iacute;nh fx-500ms t&iacute;nh được th&igrave; n&oacute; t&iacute;nh được, ri&ecirc;ng phần b&aacute;o lỗi th&igrave; n&oacute; kh&ocirc;ng c&oacute;, nhập biểu thức sai c&uacute; ph&aacute;p th&igrave; n&oacute; chạy sai hoặc hệ thống b&aacute;o kh&ocirc;ng chạy được chương tr&igrave;nh n&agrave;y, kh&ocirc;ng g&igrave; l&agrave; ho&agrave;n hảo cả n&ecirc;n t sẽ cố gắng cải tiến v&agrave; update l&ecirc;n đ&acirc;y để mọi người học hỏi kinh nghiệm.&nbsp;</p>\r\n\r\n<pre class="brush:cpp;">\r\n#include&lt;iostream&gt;  \r\n#include&lt;string&gt;  \r\nusing namespace std;  \r\nbool check(string s)  \r\n{  \r\n for(int i=0;i&lt;s.size();i++)  \r\n  if(s[i]==&#39;(&#39;||s[i]==&#39;)&#39;)  \r\n   return true;  \r\n return false;  \r\n}  \r\nstring itoa(float x)  \r\n{  \r\n string s;  \r\n int d=0,dem=0,a;  \r\n if(x==0) s.insert(0,&quot;0&quot;);  \r\n if(x&lt;0)  \r\n {  \r\n  d=1;  \r\n  x=-x;  \r\n }  \r\n while(float(x)-long(x)!=0)  \r\n {  \r\n  dem++;  \r\n  x*=10;  \r\n }  \r\n long z=long(x);  \r\n for(int i=0;i&lt;dem;i++)  \r\n {  \r\n  a=z%10;  \r\n  z/=10;  \r\n  switch(a)  \r\n  {  \r\n  case 0:s.insert(0,&quot;0&quot;);break;  \r\n  case 1:s.insert(0,&quot;1&quot;);break;  \r\n  case 2:s.insert(0,&quot;2&quot;);break;  \r\n  case 3:s.insert(0,&quot;3&quot;);break;  \r\n  case 4:s.insert(0,&quot;4&quot;);break;  \r\n  case 5:s.insert(0,&quot;5&quot;);break;  \r\n  case 6:s.insert(0,&quot;6&quot;);break;  \r\n  case 7:s.insert(0,&quot;7&quot;);break;  \r\n  case 8:s.insert(0,&quot;8&quot;);break;  \r\n  case 9:s.insert(0,&quot;9&quot;);break;  \r\n  }  \r\n }  \r\n if(dem&gt;0)s.insert(0,&quot;.&quot;);  \r\n if(z==0) s.insert(0,&quot;0&quot;);  \r\n while(z&gt;0)  \r\n {  \r\n  a=z%10;  \r\n  z/=10;  \r\n  switch(a)  \r\n  {  \r\n  case 0:s.insert(0,&quot;0&quot;);break;  \r\n  case 1:s.insert(0,&quot;1&quot;);break;  \r\n  case 2:s.insert(0,&quot;2&quot;);break;  \r\n  case 3:s.insert(0,&quot;3&quot;);break;  \r\n  case 4:s.insert(0,&quot;4&quot;);break;  \r\n  case 5:s.insert(0,&quot;5&quot;);break;  \r\n  case 6:s.insert(0,&quot;6&quot;);break;  \r\n  case 7:s.insert(0,&quot;7&quot;);break;  \r\n  case 8:s.insert(0,&quot;8&quot;);break;  \r\n  case 9:s.insert(0,&quot;9&quot;);break;  \r\n  }  \r\n }  \r\n if(d==1) s.insert(0,&quot;-&quot;);  \r\n else s.insert(0,&quot;+&quot;);  \r\n return s;  \r\n}  \r\nfloat lay1(string s)  \r\n{  \r\n long d=1;  \r\n float x=0;  \r\n for(int i=s.size()-1;i&gt;=0;i--)  \r\n {  \r\n  if(s[i]==&#39;-&#39; || s[i]==&#39;+&#39; || s[i]==&#39;*&#39; || s[i]==&#39;/&#39; || s[i]==&#39;(&#39; || s[i]==&#39;)&#39;)  \r\n  {  \r\n   if(s[i]==&#39;-&#39;) x=-x;  \r\n   break;  \r\n  }  \r\n  else if(s[i]==&#39;.&#39;)  \r\n  {  \r\n   x/=d;  \r\n   d=1;  \r\n  }  \r\n  else  \r\n  {  \r\n   switch(s[i])  \r\n   {  \r\n   case &#39;0&#39;:break;  \r\n   case &#39;1&#39;:x+=d;break;  \r\n   case &#39;2&#39;:x+=2*d;break;  \r\n   case &#39;3&#39;:x+=3*d;break;  \r\n   case &#39;4&#39;:x+=4*d;break;  \r\n   case &#39;5&#39;:x+=5*d;break;  \r\n   case &#39;6&#39;:x+=6*d;break;  \r\n   case &#39;7&#39;:x+=7*d;break;  \r\n   case &#39;8&#39;:x+=8*d;break;  \r\n   case &#39;9&#39;:x+=9*d;break;  \r\n   }  \r\n   d*=10;  \r\n  }  \r\n }  \r\n return x;  \r\n}  \r\nfloat lay2(string s)  \r\n{  \r\n long j=0,k=0,i;  \r\n float d;  \r\n float x=0;  \r\n if(s[0]==&#39;+&#39; || s[0]==&#39;-&#39;) j=1;  \r\n for(i=j;i&lt;s.size();i++)  \r\n {  \r\n  if(s[i]&gt;=&#39;0&#39; &amp;&amp; s[i]&lt;=&#39;9&#39;)  \r\n  {  \r\n   switch(s[i])  \r\n   {  \r\n   case &#39;0&#39;:x=x*10+0;break;  \r\n   case &#39;1&#39;:x=x*10+1;break;  \r\n   case &#39;2&#39;:x=x*10+2;break;  \r\n   case &#39;3&#39;:x=x*10+3;break;  \r\n   case &#39;4&#39;:x=x*10+4;break;  \r\n   case &#39;5&#39;:x=x*10+5;break;  \r\n   case &#39;6&#39;:x=x*10+6;break;  \r\n   case &#39;7&#39;:x=x*10+7;break;  \r\n   case &#39;8&#39;:x=x*10+8;break;  \r\n   case &#39;9&#39;:x=x*10+9;break;  \r\n   }  \r\n  }  \r\n  else break;  \r\n }  \r\n if(i&lt;s.size() &amp;&amp; s[i]==&#39;.&#39;)  \r\n {  \r\n  d=10;  \r\n  for(j=i+1;j&lt;s.size();j++)  \r\n  {  \r\n   if(s[j]&gt;=&#39;0&#39; &amp;&amp; s[j]&lt;=&#39;9&#39;)  \r\n   {  \r\n    switch(s[j])  \r\n    {  \r\n    case &#39;0&#39;:x+=0/d;break;  \r\n    case &#39;1&#39;:x+=1/d;break;  \r\n    case &#39;2&#39;:x+=2/d;break;  \r\n    case &#39;3&#39;:x+=3/d;break;  \r\n    case &#39;4&#39;:x+=4/d;break;  \r\n    case &#39;5&#39;:x+=5/d;break;  \r\n    case &#39;6&#39;:x+=6/d;break;  \r\n    case &#39;7&#39;:x+=7/d;break;  \r\n    case &#39;8&#39;:x+=8/d;break;  \r\n    case &#39;9&#39;:x+=9/d;break;  \r\n    }  \r\n    d*=10;  \r\n   }  \r\n   else break;  \r\n  }  \r\n }  \r\n if(s[0]==&#39;-&#39;) x=-x;  \r\n return x;  \r\n}  \r\nvoid xuly(string &amp;s)  \r\n{  \r\n if(s[s.size()-1]==&#39;+&#39;||s[s.size()-1]==&#39;-&#39;)  \r\n {  \r\n  s.push_back(&#39;0&#39;);  \r\n }  \r\n if(s[s.size()-1]==&#39;*&#39;||s[s.size()-1]==&#39;/&#39;)  \r\n {  \r\n  bool p=false;  \r\n  for(int i=s.size()-2;i&gt;=0;i--)  \r\n   if(s[i]==&#39;+&#39;||s[i]==&#39;-&#39;)  \r\n   {  \r\n    p=true;  \r\n    i++;  \r\n    s.replace(i,s.size()-i,&quot;0&quot;);  \r\n   }  \r\n  if(p==false)  \r\n  {  \r\n   s.erase(0,s.size());  \r\n   s.insert(0,&quot;0&quot;);  \r\n  }  \r\n }  \r\n for(int i=0;i&lt;s.size()-1;i++)  \r\n  if(s[i]==&#39;+&#39; &amp;&amp; s[i+1]==&#39;+&#39;)  \r\n  {  \r\n   s.erase(i,1);  \r\n  }  \r\n  else if(s[i]==&#39;+&#39; &amp;&amp; s[i+1]==&#39;-&#39;)  \r\n  {  \r\n   s.erase(i,1);  \r\n  }  \r\n  else if(s[i]==&#39;-&#39; &amp;&amp; s[i+1]==&#39;+&#39;)  \r\n  {  \r\n   s.erase(i+1,1);  \r\n  }  \r\n  else if(s[i]==&#39;-&#39; &amp;&amp; s[i+1]==&#39;-&#39;)  \r\n  {  \r\n   s.erase(i,2);  \r\n   s.insert(i,&quot;+&quot;);  \r\n  }  \r\n}  \r\nfloat tinh(string s)  \r\n{  \r\n xuly(s);  \r\n int p1,p2;  \r\n string a,c;  \r\n float x,y,t=0,p;  \r\n while(check(s))  \r\n {  \r\n  p2=s.find(&quot;)&quot;);  \r\n  if(p2&gt;=0)  \r\n  {  \r\n   xuly(s);  \r\n   p1=s.rfind(&quot;(&quot;,p2);  \r\n   a=s.substr(p1+1,p2-p1-1);  \r\n   p=tinh(a);  \r\n   c=itoa(p);  \r\n   s.replace(p1,p2-p1+1,c);  \r\n   xuly(s);  \r\n  }  \r\n }  \r\nloop:;  \r\n for(p=0;p&lt;s.size();p++)  \r\n  if(s[p]==&#39;*&#39; || s[p]==&#39;/&#39;) break;  \r\n if(p!=s.size())  \r\n {  \r\n  xuly(s);  \r\n  a=s.substr(0,p);  \r\n  c=s.substr(p+1,s.size()-p-1);  \r\n  x=lay1(a);  \r\n  y=lay2(c);  \r\n  if(s[p]==&#39;*&#39;) t=x*y;  \r\n  else t=x/y;  \r\n  for(p1=p-1;p1&gt;=0;p1--)  \r\n   if(s[p1]==&#39;+&#39; || s[p1]==&#39;-&#39;|| s[p1]==&#39;*&#39;|| s[p1]==&#39;/&#39;|| s[p1]==&#39;(&#39;|| s[p1]==&#39;)&#39;) break;  \r\n  if(p1==-1) p1++;  \r\n  else if(s[p1]==&#39;*&#39; || s[p1]==&#39;/&#39;) p1++;  \r\n  for(p2=p+2;p2&lt;s.size();p2++)  \r\n   if(s[p2]==&#39;+&#39; || s[p2]==&#39;-&#39;|| s[p2]==&#39;*&#39;|| s[p2]==&#39;/&#39;|| s[p2]==&#39;(&#39;|| s[p2]==&#39;)&#39;) break;  \r\n  p2--;  \r\n  a=itoa(t);  \r\n  s.replace(p1,p2-p1+1,a);  \r\n  xuly(s);  \r\n  goto loop;  \r\n }  \r\n //dau +-  \r\n else  \r\n {  \r\n  int k;  \r\n  do{  \r\n   k=0;  \r\n   for(p=1;p&lt;s.size();p++)  \r\n    if(s[p]==&#39;+&#39; || s[p]==&#39;-&#39;) break;  \r\n   if(p&lt;s.size())  \r\n   {  \r\n    xuly(s);  \r\n    a=s.substr(0,p);  \r\n    c=s.substr(p+1,s.size()-p-1);  \r\n    x=lay1(a);  \r\n    y=lay2(c);  \r\n    if(s[p]==&#39;+&#39;) t=x+y;  \r\n    else t=x-y;  \r\n    a=itoa(t);  \r\n    for(p2=p+1;p2&lt;s.size();p2++)  \r\n     if(s[p2]==&#39;+&#39; || s[p2]==&#39;-&#39;) break;  \r\n    p2--;  \r\n    s.replace(0,p2+1,a);  \r\n    xuly(s);  \r\n    k=1;  \r\n   }  \r\n  }while(k);  \r\n }  \r\n t=lay1(s);  \r\n return t;  \r\n}  \r\nvoid main()  \r\n{  \r\n string s;  \r\n getline(cin,s);  \r\n cout&lt;&lt;s&lt;&lt;&quot; = &quot;;  \r\n cout&lt;&lt;tinh(s)&lt;&lt;endl;  \r\n system(&quot;pause&quot;);  \r\n}  </pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 1, 1, NULL),
(42, 'code c++ phần mềm split and join file part,001,002', '<pre class="brush:cpp;">\r\n#include&lt;stdio.h&gt;  \r\n#include&lt;conio.h&gt;  \r\n#include&lt;stdlib.h&gt;  \r\n#include&lt;string.h&gt;  \r\n#include&lt;Windows.h&gt;  \r\nvoid layten(char *duongdan,char *ten)  \r\n{  \r\n int d=0;  \r\n for(int i=strlen(duongdan)-1;i&gt;=0;i--)  \r\n  if(duongdan[i]!=&#39;/&#39; &amp;&amp; duongdan[i]!=&#39;\\&#39;) ten[d++]=duongdan[i];  \r\n  else break;  \r\n ten[d]=&#39;\0&#39;;  \r\n for(int i=0;i&lt;strlen(ten)/2;i++)  \r\n {  \r\n  char c=ten[i];  \r\n  ten[i]=ten[strlen(ten)-1-i];  \r\n  ten[strlen(ten)-1-i]=c;  \r\n }  \r\n}  \r\nvoid bang(char *a,char *b)  \r\n{  \r\n for(int i=0;i&lt;strlen(b);i++) a[i]=b[i];  \r\n a[strlen(b)-1]=&#39;\0&#39;;  \r\n}  \r\nint insertpass(char *duongdan,char *mk)  \r\n{  \r\n FILE *t=fopen(duongdan,&quot;rb+&quot;);  \r\n FILE *f=fopen(&quot;logTKT.bin&quot;,&quot;wb+&quot;);  \r\n if(t==NULL || f==NULL) return 0;  \r\n fwrite(mk,8,1,f);  \r\n char s[2];  \r\n while(fread(s,1,1,t)) fwrite(s,1,1,f);  \r\n rewind(t);rewind(f);  \r\n while(fread(s,1,1,f)) fwrite(s,1,1,t);  \r\n fcloseall();  \r\n remove(&quot;logTKT.bin&quot;);  \r\n return 1;  \r\n}  \r\nint pass_ok(char *s)  \r\n{  \r\n int dem=0;  \r\n for(int i=0;i&lt;strlen(s);i++)  \r\n  if(s[i]&gt;=&#39;0&#39; &amp;&amp; s[i]&lt;=&#39;9&#39;) dem++;  \r\n if(dem!=strlen(s) || dem!=6) return 0;  \r\n s[6]=s[7]=&#39;#&#39;;  \r\n s[8]=&#39;\0&#39;;  \r\n return 1;  \r\n}  \r\nint split(char *duongdan,char *thumuc,int n)  \r\n{  \r\n char ten[100],duongdan2[100],a[10],*s=new char[2];  \r\n unsigned long dungluong,dem;  \r\n int i;  \r\n layten(duongdan,ten);  \r\n strcat(thumuc,&quot;/&quot;);  \r\n strcat(thumuc,ten);  \r\n strcat(thumuc,&quot;.partt&quot;);  \r\n FILE *t=fopen(duongdan,&quot;rb&quot;);  \r\n if(t==NULL)  \r\n {  \r\n  printf(&quot;\nduong dan file khong hop le!&quot;);  \r\n  return 0;  \r\n }  \r\n fseek(t,0,2);  \r\n dungluong=ftell(t)/n;  \r\n rewind(t);  \r\n for(i=1;i&lt;n;i++)  \r\n {  \r\n  bang(duongdan2,thumuc);  \r\n  a[0]=&#39;\0&#39;;  \r\n  itoa(i,a,10);  \r\n  strcat(duongdan2,a);  \r\n  FILE *f=fopen(duongdan2,&quot;wb&quot;);  \r\n  if(f==NULL)  \r\n  {  \r\n   printf(&quot;\nduong dan thu muc chua file ket qua khong hop le!&quot;);  \r\n   return 0;  \r\n  }  \r\n  dem=0;  \r\n  do{  \r\n   fread(s,1,1,t);  \r\n   fwrite(s,1,1,f);  \r\n   dem+=1;  \r\n  }while(dem!=dungluong);  \r\n  fclose(f);  \r\n }  \r\n bang(duongdan2,thumuc);  \r\n a[0]=&#39;\0&#39;;  \r\n itoa(n,a,10);  \r\n strcat(duongdan2,a);  \r\n FILE *f=fopen(duongdan2,&quot;wb&quot;);  \r\n if(f==NULL)  \r\n {  \r\n  printf(&quot;\nduong dan thu muc chua file ket qua khong hop le!&quot;);  \r\n  return 0;  \r\n }  \r\n while(fread(s,1,1,t)) fwrite(s,1,1,f);  \r\n fclose(f);  \r\n delete []s;  \r\n fclose(t);  \r\n return 1;  \r\n}  \r\nint join(char *duongdan,char *thumuc)  \r\n{  \r\n int i;  \r\n char ten[100],duongdanketqua[100],a[10],s[2],dd[100];  \r\n layten(duongdan,ten);  \r\n for(i=strlen(ten)-1;i&gt;=0;i--)  \r\n  if(ten[i]!=&#39;.&#39;) ten[i]=&#39;\0&#39;;  \r\n  else break;  \r\n ten[i]=&#39;\0&#39;;  \r\n duongdanketqua[0]=&#39;\0&#39;;  \r\n strcat(duongdanketqua,thumuc);  \r\n if(strlen(duongdanketqua)&gt;0)strcat(duongdanketqua,&quot;/&quot;);  \r\n strcat(duongdanketqua,ten);  \r\n FILE *t=fopen(duongdanketqua,&quot;wb&quot;);  \r\n if(t==NULL)  \r\n {  \r\n  printf(&quot;\nduong dan thu muc chua file ket qua khong hop le!\n&quot;);  \r\n  return 0;  \r\n }  \r\n for(i=strlen(duongdan)-1;i&gt;=0;i--)  \r\n  if(duongdan[i]&gt;=&#39;0&#39; &amp;&amp; duongdan[i]&lt;=&#39;9&#39;) duongdan[i]=&#39;\0&#39;;  \r\n  else break;  \r\n i=1;  \r\n while(1)  \r\n {  \r\n  a[0]=&#39;\0&#39;;  \r\n  itoa(i++,a,10);  \r\n  bang(dd,duongdan);  \r\n  strcat(dd,&quot;t&quot;);  \r\n  strcat(dd,a);  \r\n  FILE *f=fopen(dd,&quot;rb&quot;);  \r\n  if(i==1 &amp;&amp; f==NULL)  \r\n  {  \r\n   printf(&quot;\nduong dan file khong hop le!&quot;);  \r\n   return 0;  \r\n  }  \r\n  if(f==NULL) break;  \r\n  while(fread(s,1,1,f)) fwrite(s,1,1,t);  \r\n  fclose(f);  \r\n }  \r\n fclose(t);  \r\n return 1;  \r\n}  \r\nint split2(char *duongdan,char *thumuc,char *dl)  \r\n{  \r\n unsigned long dungluong=0,dem;  \r\n int i;  \r\n char a[100],ten[100],duongdan2[100],s[2];  \r\n layten(duongdan,ten);  \r\n if(strlen(thumuc)&gt;0)strcat(thumuc,&quot;/&quot;);  \r\n strcat(thumuc,ten);  \r\n strcat(thumuc,&quot;.partt&quot;);  \r\n for(i=0;i&lt;strlen(dl);i++)  \r\n  if(dl[i]&gt;=&#39;0&#39; &amp;&amp; dl[i]&lt;=&#39;9&#39;) a[i]=dl[i];  \r\n  else break;  \r\n a[i]=&#39;\0&#39;;  \r\n dungluong+=atol(a);  \r\n if(dl[i]==&#39;K&#39;) dungluong*=1024;  \r\n if(dl[i]==&#39;M&#39;) dungluong*=1024*1024;  \r\n FILE *t=fopen(duongdan,&quot;rb&quot;);  \r\n if(t==NULL)  \r\n {  \r\n  printf(&quot;\nduong dan file khong hop le!&quot;);  \r\n  return 0;  \r\n }  \r\n i=1;  \r\n while(!feof(t))  \r\n {  \r\n  bang(duongdan2,thumuc);  \r\n  a[0]=&#39;\0&#39;;  \r\n  itoa(i++,a,10);  \r\n  strcat(duongdan2,a);  \r\n  FILE *f=fopen(duongdan2,&quot;wb&quot;);  \r\n  if(f==NULL)  \r\n  {  \r\n   printf(&quot;\nduong dan thu muc chua file ket qua khong hop le!&quot;);  \r\n   return 0;  \r\n  }  \r\n  dem=0;  \r\n  for(dem=1;dem&lt;=dungluong;dem++)  \r\n   if(fread(s,1,1,t)) fwrite(s,1,1,f);  \r\n   else break;  \r\n  fclose(f);  \r\n }  \r\n return 1;  \r\n}  \r\nint co_pass(char *duongdan,char *pass)  \r\n{  \r\n FILE *t=fopen(duongdan,&quot;rb+&quot;);  \r\n if(t==NULL) return -1;  \r\n char s[10];  \r\n fread(s,8,1,t);  \r\n if(s[6]==&#39;#&#39; &amp;&amp; s[7]==&#39;#&#39;)  \r\n {  \r\n  int i;  \r\n  for(i=0;i&lt;6;i++) pass[i]=s[i];  \r\n  pass[i]=&#39;\0&#39;;    \r\n  fclose(t);  \r\n  return 1;  \r\n }  \r\n fclose(t);  \r\n return 0;  \r\n}  \r\nvoid xuly_pass(char *duongdan)  \r\n{  \r\n FILE *t=fopen(duongdan,&quot;rb&quot;);  \r\n FILE *f=fopen(&quot;logTKT.bin&quot;,&quot;wb+&quot;);  \r\n char s[10];  \r\n fread(s,8,1,t);  \r\n while(fread(s,1,1,t)) fwrite(s,1,1,f);  \r\n rewind(f);fclose(t);  \r\n t=fopen(duongdan,&quot;wb&quot;);  \r\n while(fread(s,1,1,f)) fwrite(s,1,1,t);  \r\n fcloseall();  \r\n remove(&quot;logTKT.bin&quot;);  \r\n}  \r\nvoid main()  \r\n{  \r\n char duongdan[100],thumuc[100],dungluong[100],pass[100];  \r\n int n,k=1,kt,kiemtrapass;  \r\n while(k!=0)  \r\n {  \r\n  system(&quot;cls&quot;);  \r\n  printf(&quot;\n\n________________MENU___________________\n&quot;);  \r\n  printf(&quot;| 1. chia file thanh n part.(split1)   |\n&quot;);  \r\n  printf(&quot;| 2. chia file theo dung luong.(split2)|\n&quot;);  \r\n  printf(&quot;| 3. gop file (join)                   |\n&quot;);  \r\n  printf(&quot;| 0. Thoat.                            |\n&quot;);  \r\n  printf(&quot;________________________________________\n&quot;);  \r\n  scanf(&quot;%d&quot;,&amp;k);  \r\n  \r\n  \r\n  \r\n  if(k==1)  \r\n  {  \r\n   kiemtrapass=0;  \r\n   printf(&quot;\nnhap vao DUONG DAN FILE chua file can Split: &quot;);fflush(stdin);gets(duongdan);  \r\n   printf(&quot;\nnhap vao THU MUC chua file ket qua Split: &quot;);fflush(stdin);gets(thumuc);  \r\n   printf(&quot;\nnhap vao SO PART can Split: N=&quot;);scanf(&quot;%d&quot;,&amp;n);  \r\n   printf(&quot;\nDo you Set PassWord?? 1-yes; 0-no;  : &quot;);scanf(&quot;%d&quot;,&amp;kt);  \r\n   if(kt==1)  \r\n   {  \r\n    kiemtrapass=1;  \r\n    int kc,kl;  \r\n    do{  \r\n     kc=0;  \r\n     printf(&quot;\nnhap 6 chu so password: &quot;);fflush(stdin);gets(pass);  \r\n     kl=pass_ok(pass);  \r\n     if(kl==0)  \r\n     {  \r\n      printf(&quot;\nnhap pass sai dinh dang! nhap lai!&quot;);  \r\n      kc=1;  \r\n     }  \r\n    }while(kc==1);  \r\n    printf(&quot;\ndang cai dat PassWord vao file! doi nhe! ...&quot;);  \r\n    kc=insertpass(duongdan,pass);  \r\n    if(kc==0)  \r\n    {  \r\n     printf(&quot;\nduong dan file khong hop le!&quot;);  \r\n     goto ketthuc1;  \r\n    }  \r\n   }  \r\n   printf(&quot;\nDANG XU LY! VUI LONG DOI! ...&quot;);  \r\n   kt=split(duongdan,thumuc,n);  \r\n   if(kiemtrapass==1)xuly_pass(duongdan);  \r\n   if(kt==1) printf(&quot;\nOK - Da Xong!\n&quot;);  \r\nketthuc1:;  \r\n   system(&quot;pause&quot;);  \r\n  }  \r\n  \r\n  \r\n  \r\n  \r\n  else if(k==2)  \r\n  {  \r\n   kiemtrapass=0;  \r\n   printf(&quot;\nnhap vao DUONG DAN FILE chua file can Split: &quot;);fflush(stdin);gets(duongdan);  \r\n   printf(&quot;\nnhap vao THU MUC chua file ket qua Split: &quot;);fflush(stdin);gets(thumuc);  \r\n     \r\n   do{  \r\n    kt=0;  \r\n    printf(&quot;\nnhap vao DUNG LUONG 1 part can Split: dung luong =&quot;);fflush(stdin);gets(dungluong);  \r\n    int dem=0;  \r\n    for(int i=0;i&lt;strlen(dungluong);i++)  \r\n     if((dungluong[i]&gt;=&#39;0&#39; &amp;&amp; dungluong[i]&lt;=&#39;9&#39;) || dungluong[i]==&#39;B&#39; || dungluong[i]==&#39;K&#39; || dungluong[i]==&#39;M&#39;)  \r\n      dem++;  \r\n    if(dem!=strlen(dungluong))  \r\n    {  \r\n     printf(&quot;\nkhong hop le!&quot;);  \r\n     kt=1;  \r\n    }  \r\n   }while(kt);  \r\n  \r\n   printf(&quot;\nDo you Set PassWord?? 1-yes; 0-no;  : &quot;);scanf(&quot;%d&quot;,&amp;kt);  \r\n   if(kt==1)  \r\n   {  \r\n    kiemtrapass=1;  \r\n    int kc,kl;  \r\n    do{  \r\n     kc=0;  \r\n     printf(&quot;\nnhap 6 chu so password: &quot;);fflush(stdin);gets(pass);  \r\n     kl=pass_ok(pass);  \r\n     if(kl==0)  \r\n     {  \r\n      printf(&quot;\nnhap pass sai dinh dang! nhap lai!&quot;);  \r\n      kc=1;  \r\n     }  \r\n    }while(kc==1);  \r\n    printf(&quot;\ndang cai dat PassWord vao file! doi nhe! ...&quot;);  \r\n    kc=insertpass(duongdan,pass);  \r\n    if(kc==0)  \r\n    {  \r\n     printf(&quot;\nduong dan file khong hop le!&quot;);  \r\n     goto ketthuc2;  \r\n    }  \r\n   }  \r\n   printf(&quot;\nDANG XU LY! VUI LONG DOI! ...&quot;);  \r\n   kt=split2(duongdan,thumuc,dungluong);  \r\n   if(kiemtrapass==1)xuly_pass(duongdan);  \r\n   if(kt==1) printf(&quot;\nOK - Da Xong!\n&quot;);  \r\nketthuc2:;  \r\n   system(&quot;pause&quot;);  \r\n  }  \r\n  \r\n  \r\n  \r\n  else if(k==3)  \r\n  {  \r\n   printf(&quot;\nnhap vao DUONG DAN FILE part1: &quot;);fflush(stdin);gets(duongdan);  \r\n   printf(&quot;\nnhap vao THU MUC chua file ket qua: &quot;);fflush(stdin);gets(thumuc);  \r\n   char lay_pass[100];  \r\n   printf(&quot;\ndang xu ly! ...&quot;);  \r\n   int mk=co_pass(duongdan,lay_pass);  \r\n   if(mk==-1)  \r\n   {  \r\n    printf(&quot;\nduong dan file khong hop le!&quot;);  \r\n    goto ketthuc3;  \r\n   }  \r\n   else if(mk==1)  \r\n   {  \r\n    char check_pass[100];  \r\n    printf(&quot;\nnhap PASS de join file: &quot;);fflush(stdin);gets(check_pass);  \r\n    if(strcmp(lay_pass,check_pass)!=0)  \r\n    {  \r\n     printf(&quot;\nnhap pass sai!!!&quot;);  \r\n     goto ketthuc3;  \r\n    }  \r\n    else xuly_pass(duongdan);  \r\n   }  \r\n   printf(&quot;\nDANG XU LY! VUI LONG DOI! ...&quot;);  \r\n   kt=join(duongdan,thumuc);  \r\n   if(kt==1) printf(&quot;\nOK - Da Xong!\n&quot;);  \r\nketthuc3:;  \r\n   system(&quot;pause&quot;);  \r\n  }  \r\n  else printf(&quot;\n\nTAM BIET!\n&quot;);  \r\n }  \r\n getch();  \r\n}  </pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 3, 1, NULL),
(43, 'tính giá trị của 1 biểu thức bất kỳ', '<pre class="brush:cpp;">\r\n#include&lt;iostream&gt;  \r\n#include&lt;time.h&gt;  \r\nusing namespace std;  \r\nlong tinh(char *s)  \r\n{  \r\n char a[100],dau[100],b[100],e[100];  \r\n int i,d=0;  \r\n for(i=0;i&lt;strlen(s);i++) if(s[i]==&#39;+&#39; || s[i]==&#39;-&#39; || s[i]==&#39;*&#39; || s[i]==&#39;/&#39; || s[i]==&#39;(&#39; || s[i]==&#39;)&#39;) dau[d++]=s[i];  \r\n if(d==0) return atol(s);  \r\n for(i=0;i&lt;d;i++)   \r\n {  \r\n  if(dau[i]!=&#39;*&#39; &amp;&amp; dau[i]!=&#39;/&#39;)   \r\n  {  \r\n   int m,j;  \r\n   char c;  \r\n   for(m=0;m&lt;strlen(s);m++)  \r\n   {  \r\n    if(s[m]==&#39;+&#39; || s[m]==&#39;-&#39; || s[m]==&#39;(&#39;){c=s[m]; break;}  \r\n    a[m]=s[m];  \r\n   }  \r\n   a[m]=&#39;\0&#39;;  \r\n   if(c==&#39;+&#39; || c==&#39;-&#39;)  \r\n   {  \r\n    int dd=0;  \r\n    for(j=m+1;j&lt;strlen(s);j++) b[dd++]=s[j];  \r\n    b[dd]=&#39;\0&#39;;  \r\n    if(c==&#39;+&#39;) return tinh(a)+tinh(b);  \r\n    else  \r\n    {//doi dau chuoi b  \r\n     j=0;  \r\n     while(j&lt;strlen(b))  \r\n     {  \r\n      while(b[j]!=&#39;(&#39; &amp;&amp; j&lt;strlen(b))  \r\n      {  \r\n       if(b[j]==&#39;+&#39;) b[j]=&#39;-&#39;;  \r\n       else if(b[j]==&#39;-&#39;) b[j]=&#39;+&#39;;  \r\n       j++;  \r\n      }  \r\n      j++;dd=1;  \r\n      while(j&lt;strlen(b))  \r\n      {  \r\n       if(b[j]==&#39;(&#39;) dd++;  \r\n       if(b[j]==&#39;)&#39;) dd--;  \r\n       if(dd==0) break;  \r\n       j++;  \r\n      }  \r\n      j++;  \r\n     }  \r\n     return tinh(a)-tinh(b);  \r\n    }  \r\n   }  \r\n   else if(c==&#39;(&#39;)  \r\n   {  \r\n    char c1,c2,c3,a1[100],a2[100],a3[100],a4[100];  \r\n    int p1,p2,p3,p4,dem=1;  \r\n    p1=m;p2=p1+1;  \r\n    while(p2&lt;strlen(s))  \r\n    {  \r\n     if(s[p2]==&#39;(&#39;) dem++;  \r\n     else if(s[p2]==&#39;)&#39;) dem--;  \r\n     if(dem==0) break;  \r\n     p2++;  \r\n    }  \r\n    p4=0;  \r\n    for(p3=p1+1;p3&lt;p2;p3++) a2[p4++]=s[p3];  \r\n    a2[p4]=&#39;\0&#39;;  \r\n  \r\n    p1--;  \r\n    c1=s[p1];  \r\n    for(p3=0;p3&lt;p1;p3++) a1[p3]=s[p3];  \r\n    a1[p3]=&#39;\0&#39;;  \r\n  \r\n    c2=s[p2+1];  \r\n    if(c2==&#39;*&#39; || c2==&#39;/&#39;)  \r\n    {  \r\n     p2+=2;  \r\n     p4=0;  \r\n     loop:;  \r\n     while(p2&lt;strlen(s) &amp;&amp; s[p2]!=&#39;-&#39; &amp;&amp; s[p2]!=&#39;+&#39; &amp;&amp; s[p2]!=&#39;(&#39;) a3[p4++]=s[p2++];  \r\n     if(s[p2]==&#39;(&#39;)  \r\n     {  \r\n      p3=p2+1;  \r\n      dem=1;  \r\n      while(p3&lt;strlen(s))  \r\n      {  \r\n       if(s[p3]==&#39;(&#39;) dem++;  \r\n       else if(s[p3]==&#39;)&#39;) dem--;  \r\n       if(dem==0) break;  \r\n       p3++;  \r\n      }  \r\n      for(p1=p2;p1&lt;=p3;p1++) a3[p4++]=s[p1];  \r\n      p2=p3+1;  \r\n      goto loop;  \r\n     }  \r\n     a3[p4]=&#39;\0&#39;;  \r\n     c3=s[p2];  \r\n     p2++;p4=0;  \r\n     while(p2&lt;strlen(s)) a4[p4++]=s[p2++];  \r\n     a4[p4]=&#39;\0&#39;;  \r\n    }  \r\n    else  \r\n    {  \r\n     c3=c2;  \r\n     a3[0]=&#39;\0&#39;;  \r\n     p4=0;p2+=2;  \r\n     while(p2&lt;strlen(s)) a4[p4++]=s[p2++];  \r\n     a4[p4]=&#39;\0&#39;;  \r\n    }  \r\n    if(c3==&#39;-&#39;)  \r\n    {  \r\n     p4=0;  \r\n     while(p4&lt;strlen(a4))  \r\n     {  \r\n      while(a4[p4]!=&#39;(&#39; &amp;&amp; p4&lt;strlen(a4))  \r\n      {  \r\n       if(a4[p4]==&#39;+&#39;) a4[p4]=&#39;-&#39;;  \r\n       else if(a4[p4]==&#39;-&#39;) a4[p4]=&#39;+&#39;;  \r\n       p4++;  \r\n      }  \r\n      p4++;dem=1;  \r\n      while(p4&lt;strlen(a4))  \r\n      {  \r\n       if(a4[p4]==&#39;(&#39;) dem++;  \r\n       if(a4[p4]==&#39;)&#39;) dem--;  \r\n       if(dem==0) break;  \r\n       p4++;  \r\n      }  \r\n      p4++;  \r\n     }  \r\n    }  \r\n    long k=tinh(a2);  \r\n    if(strlen(a1)&gt;0)  \r\n    {  \r\n     if(c1==&#39;*&#39;) k=tinh(a1)*k;  \r\n     else if(c1==&#39;/&#39;) k=tinh(a1)/k;  \r\n    }  \r\n    if(strlen(a3)&gt;0)  \r\n    {  \r\n     if(c2==&#39;*&#39;) k=k*tinh(a3);  \r\n     else if(c2==&#39;/&#39;) k=k/tinh(a3);  \r\n    }  \r\n    if(strlen(a4)&gt;0)  \r\n    {  \r\n     if(c3==&#39;+&#39;) k=k+tinh(a4);  \r\n     else if(c3==&#39;-&#39;) k=k-tinh(a4);  \r\n    }  \r\n    return k;  \r\n   }  \r\n  }  \r\n }  \r\n char c;  \r\n for(i=0;i&lt;strlen(s);i++)  \r\n {  \r\n  if(s[i]==&#39;*&#39; || s[i]==&#39;/&#39;) break;  \r\n  a[i]=s[i];  \r\n }  \r\n a[i]=&#39;\0&#39;;  \r\n long kq=atol(a);  \r\n c=s[i];  \r\n i++;  \r\n while(i&lt;strlen(s))  \r\n {  \r\n  d=0;  \r\n  while(s[i]!=&#39;*&#39; &amp;&amp; s[i]!=&#39;/&#39; &amp;&amp; i&lt;strlen(s)) a[d++]=s[i++];  \r\n  a[d]=&#39;\0&#39;;  \r\n  if(c==&#39;*&#39;) kq*=atol(a);  \r\n  else kq/=atol(a);  \r\n  c=s[i];  \r\n  i++;  \r\n }  \r\n return kq;  \r\n}  \r\nvoid xuly(char *s,int x)  \r\n{  \r\n char a[100],b[100];  \r\n int i,j,m;  \r\n ltoa(x,a,10);  \r\n if(s[0]==&#39;x&#39;)  \r\n {  \r\n  for(i=0;i&lt;strlen(a);i++) b[i]=a[i];  \r\n  for(j=1;j&lt;strlen(s);j++) b[i++]=s[j];  \r\n  b[i]=&#39;\0&#39;;  \r\n  for(i=0;i&lt;strlen(b);i++) s[i]=b[i];  \r\n  s[i]=&#39;\0&#39;;  \r\n }  \r\n for(i=1;i&lt;strlen(s);i++)  \r\n {  \r\n  if(s[i]==&#39;x&#39;)  \r\n  {  \r\n   if(s[i-1]&gt;=&#39;0&#39; &amp;&amp; s[i-1]&lt;=&#39;9&#39;)  \r\n   {  \r\n    for(j=0;j&lt;i;j++) b[j]=s[j];  \r\n    b[j++]=&#39;*&#39;;  \r\n    for(m=0;m&lt;strlen(a);m++) b[j++]=a[m];  \r\n    for(m=i+1;m&lt;strlen(s);m++) b[j++]=s[m];  \r\n    b[j]=&#39;\0&#39;;  \r\n    for(j=0;j&lt;strlen(b);j++) s[j]=b[j];  \r\n    s[j]=&#39;\0&#39;;  \r\n   }  \r\n   else  \r\n   {  \r\n    for(j=0;j&lt;i;j++) b[j]=s[j];  \r\n    for(m=0;m&lt;strlen(a);m++) b[j++]=a[m];  \r\n    for(m=i+1;m&lt;strlen(s);m++) b[j++]=s[m];  \r\n    b[j]=&#39;\0&#39;;  \r\n    for(j=0;j&lt;strlen(b);j++) s[j]=b[j];  \r\n    s[j]=&#39;\0&#39;;  \r\n   }  \r\n  }  \r\n }  \r\n}  \r\nvoid bang(char *a,char *b)  \r\n{  \r\n int i;  \r\n for(i=0;i&lt;strlen(b);i++) a[i]=b[i];  \r\n a[i]=&#39;\0&#39;;  \r\n}  \r\nvoid main()  \r\n{  \r\n FILE *t1=fopen(&quot;bai1.inp&quot;,&quot;r&quot;);  \r\n FILE *t2=fopen(&quot;bai1.out&quot;,&quot;w&quot;);  \r\n if(t1==NULL || t2==NULL) exit(0);  \r\n char s[1000],a[1000];  \r\n long n,x,gt;  \r\n fgets(s,100,t1);  \r\n fscanf(t1,&quot;%ld&quot;,&amp;n);  \r\n for(int i=1;i&lt;=n;i++)  \r\n {  \r\n  bang(a,s);  \r\n  fscanf(t1,&quot;%ld&quot;,&amp;x);  \r\n  xuly(a,x);  \r\n  gt=tinh(a);  \r\n  fprintf(t2,&quot;%ld &quot;,gt);  \r\n }  \r\n fcloseall();  \r\n}  </pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 1, 1, NULL),
(44, 'Sử dụng đệ quy, viết hàm kiểm tra mảng có toàn các số nguyên chia hết cho 7 hay không', '<pre class="brush:cpp;">\r\n#include&lt;iostream&gt;\r\nusing namespace std;\r\nint kiemtra(int a[],int n)\r\n{\r\n if(n==0) return 1;\r\n if(a[n-1]%7!=0) return 0;\r\n n--;\r\n return kiemtra(a,n);\r\n}\r\nvoid main()\r\n{\r\n int a[10]={7,14,21,28,35,42,49,56,63,70},n=10;\r\n if(kiemtra(a,n)) cout&lt;&lt;&quot;ok.tat ca chia het cho 7&quot;;\r\n else cout&lt;&lt;&quot;no.khong phai tat ca chia het cho 7&quot;;\r\n system(&quot;pause&quot;);\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 1, 1, NULL),
(45, 'Sử dụng đệ quy, viết hàm đếm các giá trị phân biệt trong mảng', '<pre class="brush:cpp;">\r\n#include&lt;iostream&gt;\r\nusing namespace std;\r\nint dem(int a[],int left,int right)\r\n{\r\n if(left&gt;right) return 0;\r\n for(int i=left+1;i&lt;=right;i++)\r\n  if(a[left]==a[i]) return dem(a,left+1,right);\r\n return 1+dem(a,left+1,right);\r\n}\r\nvoid main()\r\n{\r\n int a[10]={17,14,21,28,17,42,49,56,63,17},n=10;\r\n cout&lt;&lt;dem(a,0,n-1);\r\n system(&quot;pause&quot;);\r\n}</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(46, 'tìm UCLN tất cả phần tử trong mảng', '<pre class="brush:cpp;">\r\n#include&lt;iostream&gt;\r\nusing namespace std;\r\nint UCLN(int a[],int left,int right)\r\n{\r\n if(left==right-1)\r\n {\r\n  int x=a[left],y=a[right];\r\n  while(x!=y)\r\n   if(x&gt;y)x-=y;\r\n   else y-=x;\r\n  return x;\r\n }\r\n int x=a[left],y=UCLN(a,left+1,right);\r\n while(x!=y)\r\n  if(x&gt;y)x-=y;\r\n  else y-=x;\r\n return x;\r\n}\r\nvoid main()\r\n{\r\n int a[10]={6,12,18,24,30,36,42,48,54,60},n=10;\r\n cout&lt;&lt;&quot;UCLN=&quot;&lt;&lt;UCLN(a,0,n-1);\r\n system(&quot;pause&quot;);\r\n}</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(47, 'sử dụng đệ quy , viết hàm xuất tất cả các số nguyên tố có trong mảng', '<pre class="brush:cpp;">\r\n#include&lt;iostream&gt;\r\nusing namespace std;\r\nint songuyento(int n)\r\n{\r\n if(n&lt;2) return 0;\r\n if(n==2) return 1;\r\n for(int i=2;i&lt;n;i++)\r\n  if(n%i==0) return 0;\r\n return 1;\r\n}\r\nvoid xuat(int a[],int n)\r\n{\r\n if(n==0) return;\r\n if(songuyento(a[n])) cout&lt;&lt;a[n]&lt;&lt;&quot; &quot;;\r\n n--;\r\n xuat(a,n);\r\n}\r\nvoid main()\r\n{\r\n int a[10]={1,2,3,4,5,6,7,8,9,10},n=10;\r\n xuat(a,n);\r\n system(&quot;pause&quot;);\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(48, 'tìm min và max các phần tử của mảng.', '<pre class="brush:cpp;">\r\n#include&lt;iostream&gt;\r\nusing namespace std;\r\nint min(int a[],int left,int right)\r\n{\r\n if(left==right) return a[left];\r\n int m=min(a,left+1,right);\r\n return (a[left]&lt;m)?a[left]:m;\r\n}\r\nint max(int a[],int left,int right)\r\n{\r\n if(left==right) return a[left];\r\n int m=max(a,left+1,right);\r\n return (a[left]&lt;m)?m:a[left];\r\n}\r\nvoid main()\r\n{\r\n int a[10]={1,2,3,4,5,6,7,8,9,10},n=10;\r\n int mi=min(a,0,n-1);\r\n int ma=max(a,0,n-1);\r\n cout&lt;&lt;&quot;min=&quot;&lt;&lt;mi&lt;&lt;&quot;\nmax=&quot;&lt;&lt;ma;\r\n system(&quot;pause&quot;);\r\n}</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(49, 'nhập vào 1 ngày, tìm ngày kế tiếp và xuất kết quả', '<pre class="brush:cpp;">\r\n// Viet chuong trinh nhap vao 1 ngay. Tim ngay ke tiep va xuat ket qua.\r\n#pragma region +Declaration.\r\n#pragma region _Library\r\n#include &lt;iostream&gt;\r\nusing namespace std;\r\n#pragma endregion\r\n#pragma region _Data Struct\r\ntypedef struct Date\r\n{\r\n        int dd;\r\n        int mm;\r\n        int yyyy;\r\n} D;\r\n#pragma endregion\r\n#pragma region _Prototype.\r\nvoid InputDate (D&amp;);\r\nvoid OutputDate (D);\r\nD NextDate(D&amp;);\r\n#pragma endregion\r\n#pragma endregion\r\n#pragma region +Main Function.\r\nvoid main ()\r\n{\r\n        D a;\r\n        cout &lt;&lt; &quot;Input Date:&quot; &lt;&lt; endl;\r\n        InputDate (a);\r\n        cout &lt;&lt; &quot;\n\nNext Date: &quot;;\r\n        OutputDate (NextDate(a));\r\n        system(&quot;pause&quot;);\r\n}\r\n#pragma endregion\r\n#pragma region +Define Function\r\nvoid InputDate (D &amp;a)\r\n{\r\n        int x;\r\n        do\r\n        {\r\n                cout &lt;&lt; &quot;Day: &quot;;\r\n                cin &gt;&gt; a.dd;\r\n                cout &lt;&lt; &quot;Month: &quot;;\r\n                cin &gt;&gt; a.mm;\r\n                cout &lt;&lt; &quot;Year: &quot;;\r\n                cin &gt;&gt; a.yyyy;\r\n                switch (a.mm)\r\n                {\r\n                case 1: case 3: case 5: case 7: case 8: case 10: case 12:\r\n                        x = 31;\r\n                        break;\r\n                case 4: case 6: case 9: case 11:\r\n                        x = 30;\r\n                        break;\r\n                case 2:\r\n                        if ((a.yyyy % 400 == 0) || (a.yyyy % 4 == 0 &amp;&amp; a.yyyy % 100 != 0))\r\n                                x = 29;\r\n                        else\r\n                                x = 28;\r\n                        break;\r\n                default: x = 0;\r\n                }\r\n                if (x == 0 || a.dd &lt;= 0 || a.dd &gt; x)\r\n                        cout &lt;&lt; &quot;\nEror! Please Input Date.&quot; &lt;&lt; endl;\r\n        }while (x == 0 || a.dd &lt;= 0 || a.dd &gt; x);\r\n}\r\nvoid OutputDate (D a)\r\n{\r\n        cout &lt;&lt; a.dd &lt;&lt; &quot; / &quot; &lt;&lt; a.mm &lt;&lt; &quot; / &quot; &lt;&lt; a.yyyy &lt;&lt; endl;\r\n}\r\nD NextDate (D &amp;a)\r\n{\r\n        int x;\r\n        switch (a.mm)\r\n                {\r\n                case 1: case 3: case 5: case 7: case 8: case 10: case 12:\r\n                        x = 31;\r\n                        break;\r\n                case 4: case 6: case 9: case 11:\r\n                        x = 30;\r\n                        break;\r\n                case 2:\r\n                        if ((a.yyyy % 400 == 0) || (a.yyyy % 4 == 0 &amp;&amp; a.yyyy % 100 != 0))\r\n                                x = 29;\r\n                        else\r\n                                x = 28;\r\n                        break;\r\n                }\r\n        if (a.dd == x)\r\n        {\r\n                a.dd = 1;\r\n                if (a.mm == 12)\r\n                {\r\n                        a.mm = 1;\r\n                        a.yyyy ++;\r\n                }\r\n                else\r\n                        a.mm ++;\r\n        }\r\n        else\r\n                a.dd ++;\r\n        return a;\r\n}\r\n//T&Aacute;C GIẢ CODE: TRẦN MINH AN</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 1, 1, NULL),
(50, 'tìm các cặp số thân thiết', '<p><em>lập tr&igrave;nh c/c++ t&igrave;m c&aacute;c cặp số th&acirc;n thiết. c&aacute;c cặp số th&acirc;n thiết l&agrave; số:</em><br />\r\n<em>v&iacute; dụ:</em><br />\r\n<em>220 c&oacute; ước số l&agrave;: 1,2,4,5,.....220</em><br />\r\n<em>284 c&oacute; ước số l&agrave;: 1,2,....284</em><br />\r\n<em>tổng c&aacute;c ước số của 220 (trừ ch&iacute;nh n&oacute; ra) = 284;</em><br />\r\n<em>tổng c&aacute;c ước số của 284( trừ ch&iacute;nh n&oacute; ra) = 220;</em><br />\r\n<em>như vậy trong anh c&oacute; t&ocirc;i v&agrave; trong t&ocirc;i c&oacute; anh l&agrave; cặp số th&acirc;n thiết.</em><br />\r\n<em>chương tr&igrave;nh chạy hơi l&acirc;u v&igrave; c&aacute;c cặp số th&acirc;n thiết l&agrave; rất &iacute;t nhưng rất lớn, v&iacute; dụ như 220-284, 1184-1210,...&nbsp;</em><br />\r\n<em>bạn đọc hay suy ngẫm cải tiến thuật to&aacute;n để việc t&igrave;m nhanh hơn</em><br />\r\n&nbsp;</p>\r\n\r\n<pre class="brush:cpp;">\r\n#include&lt;iostream&gt;\r\nusing namespace std;\r\nint thanthiet(unsigned long a,unsigned long b)\r\n{\r\n long x=0,y=0;\r\n for(int i=1;i&lt;a;i++) if(a%i==0) x+=i;\r\n for(int i=1;i&lt;b;i++) if(b%i==0) y+=i;\r\n if(x==b &amp;&amp; y==a) return 1;\r\n return 0;\r\n}\r\nvoid main()\r\n{\r\n unsigned long a,b;\r\n for(a=220;a&lt;=4000000000;a++)\r\n  for(b=a+10;b&lt;1.5*a;b++)\r\n   if(thanthiet(a,b)) cout&lt;&lt;a&lt;&lt;&quot; - &quot;&lt;&lt;b&lt;&lt;endl;\r\n system(&quot;pause&quot;);\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 1, 1, NULL),
(51, 'Viết chương trình nhập vào một ngày. Tìm ngày kế tiếp và xuất kết quả', '<pre class="brush:cpp;">\r\n#include&lt;iostream&gt;\r\nusing namespace std;\r\nstruct day\r\n{\r\n int d,m,y;\r\n};\r\nvoid nhap(day &amp;x);\r\nvoid nextday(day x);\r\nvoid main()\r\n{\r\n day x;\r\n cout&lt;&lt;&quot;\nNHAP NGAY, THANG, NAM:\n&quot;;\r\n nhap(x);\r\n cout&lt;&lt;&quot;\nngay tiep theo la: &quot;;\r\n nextday(x);\r\n system(&quot;pause&quot;);\r\n}\r\nvoid nextday(day x)\r\n{\r\n int k=0;\r\n x.d++;\r\n switch(x.m)\r\n {\r\n case 1:case 3: case 5: case 7: case 8: case 10:\r\n  if(x.d&gt;31)\r\n  {\r\n   x.d=1;x.m++;\r\n  }\r\n  break;\r\n case 4: case 6: case 9: case 11:\r\n  if(x.d&gt;30)\r\n  {\r\n   x.d=1;x.m++;\r\n  }\r\n  break;\r\n case 12:\r\n  if(x.d&gt;31)\r\n  {\r\n   x.d=1;x.m=1;x.y++;\r\n  }\r\n  break;\r\n case 2:\r\n  if(x.y%400==0 || (x.y%4==0 &amp;&amp; x.y%100!=0)) k=1;\r\n  if(k==1 &amp;&amp; x.d&gt;29)\r\n  {\r\n   x.d=1;x.m++;\r\n  }\r\n  if(k==0 &amp;&amp; x.d&gt;28)\r\n  {\r\n   x.d=1;x.m++;\r\n  }\r\n }\r\n cout&lt;&lt;x.d&lt;&lt;&quot;/&quot;&lt;&lt;x.m&lt;&lt;&quot;/&quot;&lt;&lt;x.y;\r\n}\r\nvoid nhap(day &amp;x)\r\n{\r\n int kt,k=0;\r\n do{\r\n  kt=0;\r\n  cout&lt;&lt;&quot;\nngay:&quot;;cin&gt;&gt;x.d;\r\n  cout&lt;&lt;&quot;\nthang: &quot;;cin&gt;&gt;x.m;\r\n  cout&lt;&lt;&quot;\nnam: &quot;;cin&gt;&gt;x.y;\r\n  switch(x.m)\r\n  {\r\n  case 1: case 3: case 5: case 7: case 8: case 10: case 12:\r\n   if(x.d&lt;=0 || x.d&gt;31) kt=1;\r\n   break;\r\n  case 4: case 6: case 9: case 11:\r\n   if(x.d&lt;=0 || x.d&gt;30) kt=1;\r\n   break;\r\n  case 2:\r\n   if(x.y%400==0 || (x.y%4==0 &amp;&amp; x.y%100!=0)) k=1;\r\n   if(k==1 &amp;&amp; (x.d&lt;=0 || x.d&gt;29)) kt=1;\r\n   if(k==0 &amp;&amp; (x.d&lt;=0 || x.d&gt;28)) kt=1;\r\n   break;\r\n  default: kt=1; break;\r\n  }\r\n  if(kt==1) cout&lt;&lt;&quot;\nkhong hop le!&quot;;\r\n }while(kt);\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(52, 'nhập vào hai phân số, tìm phân số lớn nhất', '<pre class="brush:cpp;">\r\n//t&igrave;m ph&acirc;n số lớn nhất\r\n#include&lt;iostream&gt;\r\nusing namespace std;\r\nstruct phanso\r\n{\r\n int tu,mau;\r\n};\r\nvoid nhap(phanso &amp;x);\r\nvoid xuat(phanso x);\r\nphanso max(phanso x,phanso y);\r\nvoid main()\r\n{\r\n phanso x,y,z;\r\n cout&lt;&lt;&quot;\nNHAP 2 PHAN SO:\nnhap phan so 1:&quot;;\r\n nhap(x);\r\n cout&lt;&lt;&quot;\nnhap phan so 2:&quot;;\r\n nhap(y);\r\n cout&lt;&lt;&quot;\nphan so lon nhat la: &quot;;\r\n z=max(x,y);\r\n xuat(z);\r\n system(&quot;pause&quot;);\r\n}\r\nphanso max(phanso x,phanso y)\r\n{\r\n int a,b;\r\n a=x.tu*y.mau;\r\n b=y.tu*x.mau;\r\n if(a&gt;b) return x;\r\n return y;\r\n}\r\nvoid xuat(phanso x)\r\n{\r\n cout&lt;&lt;x.tu&lt;&lt;&quot;/&quot;&lt;&lt;x.mau;\r\n}\r\nvoid nhap(phanso &amp;x)\r\n{\r\n char s[100],c[100];\r\n int i,j,kt,d,dem;\r\n do{\r\n  kt=0;\r\n  cout&lt;&lt;&quot;\nnhap phan so dang a/b: &quot;;\r\n  gets(s);\r\n  dem=0;d=0;\r\n  for(i=0;i&lt;strlen(s);i++)\r\n  {\r\n   if(s[i]==&#39;/&#39; || (s[i]&gt;=&#39;0&#39; &amp;&amp; s[i]&lt;=&#39;9&#39;)) dem++;\r\n   if(s[i]==&#39;/&#39;) d++;\r\n  }\r\n  if(dem!=strlen(s) || d!=1)\r\n  {\r\n   kt=1;\r\n   cout&lt;&lt;&quot;\nloi dinh dang!&quot;;\r\n   continue;\r\n  }\r\n  i=0;\r\n  while(s[i]!=&#39;/&#39;) c[i]=s[i++];\r\n  c[i]=&#39;\0&#39;;\r\n  x.tu=atoi(c);\r\n  d=0;\r\n  for(j=i+1;j&lt;strlen(s);j++) c[d++]=s[j];\r\n  c[d]=&#39;\0&#39;;\r\n  x.mau=atoi(c);\r\n  if(x.mau==0)\r\n  {\r\n   kt=1;\r\n   cout&lt;&lt;&quot;\nloi toan hoc!&quot;;\r\n  }\r\n }while(kt);\r\n}</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(53, 'rút gọn phân số trong lập trình c', '<pre class="brush:cpp;">\r\n//r&uacute;t gọn ph&acirc;n số\r\n#include&lt;iostream&gt;\r\nusing namespace std;\r\nstruct phanso\r\n{\r\n int tu,mau;\r\n};\r\nvoid nhap(phanso &amp;x)\r\n{\r\n char s[100],c[100];\r\n int i,j,kt,d,dem;\r\n do{\r\n  kt=0;\r\n  cout&lt;&lt;&quot;\nnhap phan so dang a/b: &quot;;\r\n  gets(s);\r\n  dem=0;d=0;\r\n  for(i=0;i&lt;strlen(s);i++)\r\n  {\r\n   if(s[i]==&#39;/&#39; || (s[i]&gt;=&#39;0&#39; &amp;&amp; s[i]&lt;=&#39;9&#39;)) dem++;\r\n   if(s[i]==&#39;/&#39;) d++;\r\n  }\r\n  if(dem!=strlen(s) || d!=1)\r\n  {\r\n   kt=1;\r\n   cout&lt;&lt;&quot;\nloi dinh dang!&quot;;\r\n   continue;\r\n  }\r\n  i=0;\r\n  while(s[i]!=&#39;/&#39;) c[i]=s[i++];\r\n  c[i]=&#39;\0&#39;;\r\n  x.tu=atoi(c);\r\n  d=0;\r\n  for(j=i+1;j&lt;strlen(s);j++) c[d++]=s[j];\r\n  c[d]=&#39;\0&#39;;\r\n  x.mau=atoi(c);\r\n  if(x.mau==0)\r\n  {\r\n   kt=1;\r\n   cout&lt;&lt;&quot;\nloi toan hoc!&quot;;\r\n  }\r\n }while(kt);\r\n}\r\nvoid xuat(phanso x)\r\n{\r\n cout&lt;&lt;x.tu&lt;&lt;&quot;/&quot;&lt;&lt;x.mau;\r\n}\r\nvoid rutgon(phanso &amp;x)\r\n{\r\n int a=abs(x.tu),b=abs(x.mau);\r\n if(a==0) return;\r\n while(a!=b)\r\n  if(a&gt;b) a-=b;\r\n  else b-=a;\r\n x.tu/=a;\r\n x.mau/=a;\r\n}\r\nvoid main()\r\n{\r\n phanso a;\r\n nhap(a);\r\n xuat(a);\r\n rutgon(a);\r\n cout&lt;&lt;&quot;=&quot;;\r\n xuat(a);\r\n system(&quot;pause&quot;);\r\n}</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(54, 'in cách đọc số nguyên dương N nhập từ bàn phím', '<pre class="brush:cpp;">\r\n#include&lt;iostream&gt;\r\nusing namespace std;\r\nvoid main()\r\n{\r\n FILE *t=fopen(&quot;E:\\doc.txt&quot;,&quot;w+&quot;);\r\n if(t==NULL){cout&lt;&lt;&quot;error&quot;; exit(0);}\r\n //nhap so nguyen\r\n int n,x,dem=0,k=0;\r\n char s[100];\r\n do{\r\n  cout&lt;&lt;&quot;\nnhap so nguyen duong N&lt;=9999:\nN=&quot;;\r\n  cin&gt;&gt;n;\r\n  if(n&lt;0 || n&gt;9999) cout&lt;&lt;&quot;\nkhong hop le! nhap lai!!\n&quot;;\r\n }while(n&lt;0 || n&gt;9999);\r\n //doc so da nhap\r\n if(n==0) fprintf(t,&quot; gnohk&quot;);\r\n while(n&gt;0)\r\n {\r\n  dem++;\r\n  x=n%10;\r\n  n/=10;\r\n  switch(dem)\r\n  {\r\n  case 2:if(x==0) fprintf(t,&quot; el&quot;);\r\n      else fprintf(t,&quot; ioum&quot;);break;\r\n  case 3:fprintf(t,&quot; mart&quot;);break;\r\n  case 4:fprintf(t,&quot; nihgn&quot;);break;\r\n  }\r\n  switch(x)\r\n  {\r\n  case 1:if(dem!=2)fprintf(t,&quot; tom&quot;);break;\r\n  case 2:fprintf(t,&quot; iah&quot;);break;\r\n  case 3:fprintf(t,&quot; ab&quot;);break;\r\n  case 4:fprintf(t,&quot; nob&quot;);break;\r\n  case 5:if(dem==1) fprintf(t,&quot; mal&quot;);\r\n      else fprintf(t,&quot; man&quot;);\r\n      break;\r\n  case 6:fprintf(t,&quot; uas&quot;);break;\r\n  case 7:fprintf(t,&quot; yab&quot;);break;\r\n  case 8:fprintf(t,&quot; mat&quot;);break;\r\n  case 9:fprintf(t,&quot; nihc&quot;);break;\r\n  case 0:if(dem==3)fprintf(t,&quot; gnohk&quot;);\r\n   break;\r\n  } \r\n }\r\n rewind(t);\r\n fgets(s,100,t);\r\n for(int i=0;i&lt;strlen(s)/2;i++)\r\n {\r\n  char t=s[i];\r\n  s[i]=s[strlen(s)-1-i];\r\n  s[strlen(s)-1-i]=t;\r\n }\r\n if(s[strlen(s)-6]==&#39;e&#39;) s[strlen(s)-4]=&#39;n&#39;;\r\n if(dem==1 &amp;&amp; s[strlen(s)-2]==&#39;m&#39;) s[strlen(s)-4]=&#39;n&#39;;\r\n cout&lt;&lt;&quot;\n*DOC LA: &quot;;\r\n puts(s);\r\n fclose(t);\r\n system(&quot;pause&quot;);\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(55, '[C++] Tìm ma trận nghịch đảo của 1 ma trận vuông cấp n tùy ý', '<pre class="brush:cpp;">\r\n#include&lt;iostream&gt;\r\n#include&lt;iomanip&gt;\r\nusing namespace std;\r\nvoid nhap(float a[][100],int &amp;n);\r\nvoid xuat(float a[][100],int n);\r\nfloat det(float a[][100],int n);\r\nfloat con(float a[][100],int n,int h,int c);\r\nvoid nghichdao(float a[][100],int n);\r\nvoid main()\r\n{\r\n float a[100][100];\r\n int n;\r\n nhap(a,n);\r\n xuat(a,n);\r\n cout&lt;&lt;&quot;\n-------------------------------\nma tran nghich dao:\n&quot;;\r\n nghichdao(a,n);\r\n system(&quot;pause&quot;);\r\n}\r\nvoid nhap(float a[][100],int &amp;n)\r\n{\r\n cout&lt;&lt;&quot;\nnhap N= &quot;;\r\n cin&gt;&gt;n;\r\n for(int i=0;i&lt;n;i++)\r\n {\r\n  cout&lt;&lt;&quot;\nnhap hang &quot;&lt;&lt;i+1&lt;&lt;&quot;:\n&quot;;\r\n  for(int j=0;j&lt;n;j++)\r\n   cin&gt;&gt;a[i][j];\r\n }\r\n}\r\nvoid xuat(float a[][100],int n)\r\n{\r\n for(int i=0;i&lt;n;i++)\r\n {\r\n  cout&lt;&lt;&quot;\n\n&quot;;\r\n  for(int j=0;j&lt;n;j++)\r\n   cout&lt;&lt;setw(6)&lt;&lt;a[i][j];\r\n }\r\n}\r\nfloat det(float a[][100],int n)\r\n{\r\n int i,j,k,dem=0,kt;\r\n float b[100],h,kq=1;\r\n for(i=0;i&lt;n-1;i++)\r\n {\r\n  if(a[i][i]==0)\r\n  {\r\n   kt=0;\r\n   for(j=i+1;j&lt;n;j++)\r\n   {\r\n    if(a[i][j]!=0)\r\n    {\r\n     for(k=0;k&lt;n;k++)\r\n     {\r\n      float t=a[k][i];\r\n      a[k][i]=a[k][j];\r\n      a[k][j]=t;\r\n     }\r\n     dem++;kt++;\r\n     break;\r\n    }\r\n   }\r\n   if(kt==0) return 0;\r\n  }\r\n  b[i]=a[i][i];\r\n  for(j=0;j&lt;n;j++) a[i][j]/=b[i];\r\n  for(j=i+1;j&lt;n;j++)\r\n  {\r\n   h=a[j][i];\r\n   for(k=0;k&lt;n;k++) a[j][k]=a[j][k]-h*a[i][k];\r\n  }\r\n }\r\n b[n-1]=a[n-1][n-1];\r\n for(i=0;i&lt;n;i++) kq*=b[i];\r\n if(dem%2==0) return kq;\r\n return -kq;\r\n}\r\nfloat con(float a[][100],int n,int h,int c)\r\n{\r\n float b[100][100];\r\n int i,j,x=-1,y;\r\n for(i=0;i&lt;n;i++)\r\n {\r\n  if(i==h) continue;\r\n  x++;y=-1;\r\n  for(j=0;j&lt;n;j++)\r\n  {\r\n   if(j==c)continue;\r\n   y++;\r\n   b[x][y]=a[i][j];\r\n  }\r\n }\r\n if((h+c)%2==0) return det(b,n-1);\r\n return -det(b,n-1);\r\n}\r\nvoid nghichdao(float a[][100],int n)\r\n{\r\n float b[100][100];\r\n for(int i=0;i&lt;n;i++)\r\n {\r\n  for(int j=0;j&lt;n;j++)\r\n  {\r\n   b[i][j]=con(a,n,i,j);\r\n  }\r\n }\r\n for(int i=0;i&lt;n-1;i++)\r\n  for(int j=i+1;j&lt;n;j++)\r\n  {\r\n   float t=b[i][j];\r\n   b[i][j]=b[j][i];\r\n   b[j][i]=t;\r\n  }\r\n float k=det(a,n);\r\n for(int i=0;i&lt;n;i++)\r\n  for(int j=0;j&lt;n;j++)\r\n   b[i][j]/=k;\r\n if(k==0) cout&lt;&lt;&quot;\nkhong co ma tran nghich dao!&quot;;\r\n else xuat(b,n);\r\n}</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 1, 1, NULL),
(56, 'chuyển đổi hệ đếm nhị phân, bát phân, thập lục phân', '<pre class="brush:cpp;">\r\n#include&lt;iostream&gt;\r\nusing namespace std;\r\nlong sodu(int a,int b)\r\n{\r\n return a-b*int(a/b);\r\n}\r\nvoid dao(char *s)\r\n{\r\n char a;\r\n for(int i=0;i&lt;strlen(s)/2;i++)\r\n {\r\n  a=s[i];s[i]=s[strlen(s)-1-i];s[strlen(s)-1-i]=a;\r\n }\r\n}\r\nvoid to2(long n,char *s)\r\n{\r\n\r\n int i=0;\r\n while(n&gt;0)\r\n {\r\n  s[i++]=sodu(n,2)+48;        //so 0 co ma 48\r\n  n/=2;\r\n }\r\n s[i]=&#39;\0&#39;;\r\n dao(s);\r\n}\r\nvoid to8(long n,char *s)\r\n{\r\n int i=0;\r\n while(n&gt;0)\r\n {\r\n  s[i++]=sodu(n,8)+48;//so 0 co ma 48\r\n  n/=8;\r\n }\r\n s[i]=&#39;\0&#39;;\r\n dao(s);\r\n}\r\nvoid to16(long n,char *s)\r\n{\r\n int i=0,m;\r\n while(n&gt;0)\r\n {\r\n  m=sodu(n,16);\r\n  if(m&lt;10) s[i++]=m+48;\r\n  else switch(m)\r\n  {\r\n  case 10:s[i++]=&#39;A&#39;;break;\r\n  case 11:s[i++]=&#39;B&#39;;break;\r\n  case 12:s[i++]=&#39;C&#39;;break;\r\n  case 13:s[i++]=&#39;D&#39;;break;\r\n  case 14:s[i++]=&#39;E&#39;;break;\r\n  case 15:s[i++]=&#39;F&#39;;break;\r\n  }\r\n  n/=16;\r\n }\r\n s[i]=&#39;\0&#39;;\r\n dao(s);\r\n}\r\nvoid main()\r\n{\r\n char a[100];\r\n char b[100];\r\n char c[100];\r\n int i;\r\n printf(&quot;DEC   :   BIN      : OCT    : HEX   \n-----------------------------------\n&quot;);\r\n for(i=150;i&lt;=256;i++)\r\n {\r\n  to2(i,a);to8(i,b);to16(i,c);\r\n  printf(&quot;%-5d : %-10s : %-6s : %-6s\n\n&quot;,i,a,b,c);\r\n }\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 1, 1, NULL),
(57, 'lập trình tìm các bộ số pitago', '<p>Một tam gi&aacute;c vu&ocirc;ng c&oacute; thể c&oacute; tất cả c&aacute;c cạnh l&agrave; c&aacute;c số nguy&ecirc;n. Tập của ba số nguy&ecirc;n của c&aacute;c cạnh của một tam gi&aacute;c vu&ocirc;ng được gọi l&agrave; bộ ba Pitago. Đ&oacute; l&agrave; tổng b&igrave;nh phương của hai cạnh bằng b&igrave;nh phương của cạnh huyền, chẳng hạn bộ ba Pitago (3, 4, 5). Viết chương tr&igrave;nh t&igrave;m tất cả c&aacute;c bộ ba Pitago như thế sao cho tất cả c&aacute;c cạnh kh&ocirc;ng qu&aacute; 500.</p>\r\n\r\n<pre class="brush:cpp;">\r\n#include&lt;iostream&gt;\r\n#include&lt;math.h&gt;\r\nusing namespace std;\r\nint sochinhphuong(float n)\r\n{\r\n if ((float)sqrt(n) - (int)sqrt(n) == 0) return 1;\r\n return 0;\r\n}\r\nvoid pitago()\r\n{\r\n int i, j;\r\n for (i = 2; i &lt; 500; i++)\r\n for (j = i; j &lt; 500; j++)\r\n {\r\n  if (sqrt(i*i+j*j)&gt;500) break;\r\n  if (sochinhphuong(i*i + j*j)) cout &lt;&lt; &quot; (&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;,&quot; &lt;&lt; sqrt(i*i + j*j) &lt;&lt; &quot;) \n&quot;;\r\n }\r\n}\r\nvoid main()\r\n{\r\n pitago();\r\n\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(58, 'viết hàm in các tam giác bằng dấu sao *', '<p>Viết chương tr&igrave;nh nhập v&agrave;o số nguy&ecirc;n dương h (2&lt;h&lt;23), sau đ&oacute; in ra c&aacute;c tam gi&aacute;c c&oacute; chiều cao l&agrave; h.viết h&agrave;m in c&aacute;c tam gi&aacute;c c&oacute; chiều cao h=N nhập v&agrave;o</p>\r\n\r\n<pre class="brush:cpp;">\r\n#include&lt;iostream&gt;\r\nusing namespace std;\r\nvoid tamgiac1(int n)\r\n{\r\n int i,j;\r\n for (i = n; i &gt;=1; i--)\r\n {\r\n  for (j = i; j &lt;= n; j++)cout &lt;&lt; &quot;  &quot;;\r\n  for (j = 1; j &lt;= 2 * i - 1; j++) cout &lt;&lt; &quot;* &quot;;\r\n  cout &lt;&lt; &quot;\n\n&quot;;\r\n }\r\n cout &lt;&lt; &quot;\n\n&quot;;\r\n}\r\nvoid tamgiac2(int n)\r\n{\r\n int j, i;\r\n for (i = 1; i &lt;= n; i++)\r\n {\r\n  for (j = i; j &lt;= n; j++) cout &lt;&lt; &quot;  &quot;;\r\n  for (j = 1; j &lt;= 2 * i - 1; j++) cout &lt;&lt; &quot; *&quot;;\r\n  cout &lt;&lt; &quot;\n\n&quot;;\r\n }\r\n cout &lt;&lt; &quot;\n\n&quot;;\r\n}\r\nvoid tamgiac3(int n)\r\n{\r\n int i, j;\r\n for (i = 1; i &lt; n; i++)\r\n {\r\n  for (j = i; j &lt;= n; j++) cout &lt;&lt; &quot;  &quot;;\r\n  for (j = 1; j &lt;= 2 * i - 1; j++) if (j == 1 || j == 2 * i - 1) cout &lt;&lt; &quot;* &quot;; else cout &lt;&lt; &quot;  &quot;;\r\n  cout &lt;&lt; &quot;\n\n&quot;;\r\n }\r\n cout &lt;&lt; &quot;  &quot;;\r\n for (i = 1; i &lt;= 2*n-1; i++) cout &lt;&lt; &quot;* &quot;;\r\n cout &lt;&lt; &quot;\n\n\n\n&quot;;\r\n}\r\nvoid tamgiac4(int n)\r\n{\r\n int i, j;\r\n cout &lt;&lt; &quot;  &quot;;\r\n for (i = 1; i &lt;= 2 * n - 1; i++) cout &lt;&lt; &quot;* &quot;;\r\n cout &lt;&lt; &quot;\n\n&quot;;\r\n for (i = n - 1; i &gt;= 1; i--)\r\n {\r\n  for (j = i; j &lt;=n; j++) cout &lt;&lt; &quot;  &quot;;\r\n  for (j = 1; j &lt;= 2 * i - 1; j++) if (j == 1 || j == 2 * i - 1) cout &lt;&lt; &quot;* &quot;; else cout &lt;&lt; &quot;  &quot;;\r\n  cout &lt;&lt; &quot;\n\n&quot;;\r\n }\r\n cout &lt;&lt; &quot;\n\n&quot;;\r\n}\r\nvoid main()\r\n{\r\n int n;\r\n cout &lt;&lt; &quot;nhap N=&quot;; cin &gt;&gt; n;\r\n tamgiac1(n);\r\n tamgiac2(n);\r\n tamgiac3(n);\r\n tamgiac4(n);\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 1, 1, NULL);
INSERT INTO `baiviet` (`idbv`, `subject`, `content`, `image_bv`, `parent`, `date_add`, `views`, `author`, `des`) VALUES
(59, 'viết hàm kiểm tra số chính phương', '<p>in ra m&agrave;n h&igrave;nh số ch&iacute;nh phương lớn nhất trong d&atilde;y. nếu kh&ocirc;ng c&oacute; s&oacute; ch&iacute;nh phương n&agrave;o th&igrave; in ra d&atilde;y kh&ocirc;ng c&oacute; số ch&iacute;nh phương n&agrave;o.</p>\r\n\r\n<p>viết h&agrave;m kiểm tra 1 số c&oacute; phải l&agrave; số ch&iacute;nh phương hay kh&ocirc;ng.</p>\r\n\r\n<pre class="brush:cpp;">\r\n#include&lt;iostream&gt;\r\n#include&lt;math.h&gt;\r\n#include&lt;stdlib.h&gt;\r\nusing namespace std;\r\nint sochinhphuong(float n)\r\n{\r\n if((float)sqrt(n)-(int)sqrt(n)==0) return 1;\r\n return 0;\r\n}\r\nvoid main()\r\n{\r\n int max=0;\r\n int *a=(int*)malloc(91*sizeof(int));\r\n for(int i=10;i&lt;=100;i++) a[i-10]=i;\r\n for(int i=0;i&lt;91;i++)\r\n  if(sochinhphuong(a[i]) &amp;&amp; max&lt;a[i]) max=a[i];\r\n cout&lt;&lt;&quot;day:&quot;;\r\n for(int i=0;i&lt;91;i++) cout&lt;&lt;&quot; &quot;&lt;&lt;a[i];\r\n if(max==0) cout&lt;&lt;&quot;\nday khong co so chinh phuong nao\n&quot;;\r\n else cout&lt;&lt;&quot;\nso chinh phuong lon nhat trong day: &quot;&lt;&lt;max&lt;&lt;&quot;\n&quot;;\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(60, 'Tính Giá Trị Biểu Thức Nhập Từ Bàn Phím', '<pre class="brush:cpp;">\r\n#include&lt;iostream&gt;\r\n#include&lt;string.h&gt;\r\n#include&lt;conio.h&gt;\r\n#include&lt;math.h&gt;\r\n#include&lt;stdlib.h&gt;\r\nusing namespace std;\r\nfloat tinhgiatri(char *s);\r\nvoid sohang(char *s,float *a,int &amp;n);\r\nvoid dau(char *s,char *b);\r\nint kiemtra(char *s);\r\nvoid main()\r\n{\r\n char s[1000],c;\r\n       cout&lt;&lt;&quot;TRẦN KH&Aacute;NH TO&Agrave;N\n-------------------------------------------------------------------&quot;;\r\nloop:;\r\n do\r\n {\r\n  cout &lt;&lt; &quot;\n-&gt;nhap bieu thuc:\n	&quot;;\r\n  fflush(stdin);\r\n  gets(s);\r\n  if(!kiemtra(s)) cout&lt;&lt;&quot;\nnhap bieu thuc khong chua &lt;space&gt;,ky tu,phep tinh lien ke...\n	NHAP LAI\n\n&quot;;\r\n }while(!kiemtra(s));\r\n cout&lt;&lt;&quot;	= &quot;&lt;&lt;tinhgiatri(s)&lt;&lt;&quot;\n\n	---------------------\n	| tiep tuc: &lt;space&gt; |\n	| ket thuc: bat ky  |\n	---------------------\n&quot;;\r\n if(c=getch()==32) goto loop;\r\n}\r\nfloat tinhgiatri(char *s)\r\n{\r\n float kq,a[1000];\r\n int i,j,n;\r\n char b[1000];\r\n sohang(s,a,n);\r\n dau(s,b);\r\n for(i=0;i&lt;strlen(b);i++)\r\n {\r\n  if(b[i]==&#39;*&#39;)\r\n  {\r\n   (float)a[i]*=(float)a[i+1];\r\n   for(j=i+1;j&lt;n-1;j++) a[j]=a[j+1];\r\n   n--;\r\n   for(j=i;j&lt;strlen(b)-1;j++)b[j]=b[j+1];\r\n   b[strlen(b)-1]=&#39;\0&#39;;\r\n   i--;\r\n  }\r\n  if(b[i]==&#39;/&#39;)\r\n  {\r\n   (float)a[i]/=(float)a[i+1];\r\n   for(j=i+1;j&lt;n-1;j++) a[j]=a[j+1];\r\n   n--;\r\n   for(j=i;j&lt;strlen(b)-1;j++) b[j]=b[j+1];\r\n   b[strlen(b)-1]=&#39;\0&#39;;\r\n   i--;\r\n  }\r\n }\r\n (float)kq=(float)a[0];\r\n for(i=0;i&lt;strlen(b);i++)\r\n {\r\n  if(b[i]==&#39;+&#39;) kq+=(float)a[i+1];\r\n  else kq-=(float)a[i+1];\r\n }\r\n return kq;\r\n}\r\nvoid sohang(char *s,float *a,int &amp;n)\r\n{\r\n char z[1000];\r\n int i,k,j,x;\r\n n=0;\r\n for(i=0;i&lt;strlen(s);i++)\r\n {\r\n  k=0;\r\n  while(s[i]&gt;=&#39;0&#39; &amp;&amp; s[i]&lt;=&#39;9&#39;) z[k++]=s[i++];\r\n  z[k]=&#39;\0&#39;;\r\n  x=atoi(z);\r\n  a[n++]=(float)x;\r\n }\r\n}\r\nvoid dau(char *s,char *b)\r\n{\r\n int i,k=0;\r\n for(i=0;i&lt;strlen(s);i++)\r\n  if(s[i]==&#39;+&#39; || s[i]==&#39;-&#39; || s[i]==&#39;*&#39; || s[i]==&#39;/&#39;)\r\n   b[k++]=s[i];\r\n b[k]=&#39;\0&#39;;\r\n}\r\nint kiemtra(char *s)\r\n{\r\n if(strlen(s)==0) return 0;\r\n for(int i=0;i&lt;strlen(s);i++)\r\n  if(s[i]==&#39; &#39; ||\r\n   (s[i]&gt;=&#39;a&#39; &amp;&amp; s[i]&lt;=&#39;z&#39;) ||\r\n   (s[i]&gt;=&#39;A&#39; &amp;&amp; s[i] &lt;=&#39;Z&#39;) ||\r\n   ((s[i]==&#39;+&#39; || s[i]==&#39;-&#39; || s[i]==&#39;*&#39; || s[i]==&#39;/&#39;)&amp;&amp; (s[i+1]==&#39;+&#39; || s[i+1]==&#39;-&#39; || s[i+1]==&#39;*&#39; || s[i+1]==&#39;/&#39;)))\r\n   return 0;\r\n return 1;\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(61, 'phân tích 1 số nguyên ra thừa số nguyên tố', '<pre class="brush:cpp;">\r\n#include&lt;stdio.h&gt;\r\nlong snt(long n)\r\n{\r\n if(n&lt;2)return 0;\r\n if(n==2) return 1;\r\n for(long i=2;i&lt;n;i++)\r\n  if(n%i==0)return 0;\r\n return 1;\r\n}\r\nvoid main()\r\n{\r\n long i,n,x,d=1;\r\n printf(&quot;nhap N= &quot;);scanf(&quot;%d&quot;,&amp;n);\r\n printf(&quot;%d = &quot;,n);\r\n while(n&gt;1)\r\n {\r\n  x=1;\r\n  while(1) if(snt(++x)==1 &amp;&amp; n%x==0) break;\r\n  if(d) {printf(&quot;%d&quot;,x);d=0;}\r\n  else printf(&quot; * %d&quot;,x);\r\n  n/=x;\r\n }\r\n printf(&quot;\n&quot;);\r\n}</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(62, 'ghi nội dung mảng lên file nhị phân', '<pre class="brush:cpp;">\r\n//ghi nội dung mảng l&ecirc;n file nhị ph&acirc;n\r\n#include&lt;stdio.h&gt;\r\n#include&lt;conio.h&gt;\r\n#include&lt;stdlib.h&gt;\r\nvoid nhapmang(int a[],int n)\r\n{\r\n for(int i=0;i&lt;n;i++)\r\n {\r\n  printf(&quot;A[%d]=&quot;,i+1);scanf(&quot;%d&quot;,&amp;a[i]);\r\n }\r\n}\r\nvoid main()\r\n{\r\n FILE *t=fopen(&quot;E:\\vd1.bin&quot;,&quot;w+b&quot;);\r\n if(t==NULL)\r\n {\r\n  printf(&quot;error&quot;);exit(0);\r\n }\r\n int n;\r\n printf(&quot;so phan tu cua mang: &quot;);\r\n scanf(&quot;%d&quot;,&amp;n);\r\n int *a=(int*)malloc(n*sizeof(int));\r\n printf(&quot;nhap mang: \n&quot;);\r\n nhapmang(a,n);\r\n fwrite(&amp;a,n*sizeof(int),1,t);//dung lượng cho mỗi phần tử l&agrave; int =&gt; của cả mảng l&agrave; n*sizeof(int)\r\n fseek(t,0,2);\r\n int m=ftell(t)/sizeof(int);//so luong bang ghi=dung lượng mảng chia dung lượng của 1 phần tử\r\n int *b=(int*)malloc(m*sizeof(int));\r\n rewind(t);\r\n fread(&amp;b,sizeof(int),1,t);\r\n printf(&quot;mang da ghi len file: \n&quot;);\r\n for(int i=0;i&lt;m;i++) printf(&quot;%d &quot;,b[i]);\r\n fclose(t);\r\n}</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(63, 'Viết chương trình đão ngược nội dung của một file văn bản.', '<pre class="brush:cpp;">\r\n#include&lt;stdio.h&gt;\r\n#include&lt;string.h&gt;\r\n#include&lt;stdlib.h&gt;\r\n#include&lt;conio.h&gt;\r\nvoid dao(char *s)\r\n{\r\n char c;\r\n for(int i=0;i&lt;strlen(s)/2;i++)\r\n {\r\n  c=s[i];s[i]=s[strlen(s)-1-i];s[strlen(s)-1-i]=c;\r\n }\r\n}\r\nvoid dois(char *a,char *b)\r\n{\r\n int i;char c[1000];\r\n for(i=0;i&lt;strlen(a);i++)c[i]=a[i];c[strlen(a)]=&#39;\0&#39;;\r\n for(i=0;i&lt;strlen(b);i++)a[i]=b[i];a[strlen(b)]=&#39;\0&#39;;\r\n for(i=0;i&lt;strlen(c);i++)b[i]=c[i];b[strlen(c)]=&#39;\0&#39;;\r\n}\r\nvoid nhap(FILE *t)\r\n{\r\n printf(&quot;nhap noi dung:\n\n&quot;);\r\n char s[1000];\r\n int dem=0;\r\n do\r\n {\r\n  gets(s);\r\n  if(strlen(s)&gt;0 &amp;&amp; dem==0)fputs(s,t);\r\n  if(strlen(s)&gt;0 &amp;&amp; dem&gt;0)\r\n  {\r\n   fputs(&quot;\n&quot;,t);fputs(s,t);\r\n  }\r\n  if(strlen(s)&gt;0)dem++;\r\n }while(strlen(s)&gt;0);\r\n}\r\nvoid xuat(FILE *t)\r\n{\r\n char s[1000];\r\n while(fgets(s,1000,t)!=0)printf(&quot;%s&quot;,s);\r\n}\r\nvoid main()\r\n{\r\n FILE *t=fopen(&quot;E:\\bai6.txt&quot;,&quot;w+&quot;);\r\n if(t==0)\r\n {\r\n  printf(&quot;error\n&quot;);exit(0);\r\n }\r\n nhap(t);\r\n rewind(t);\r\n char s[1000],a[1000][1000];int n=0;\r\n while(fgets(s,1000,t)!=0)\r\n {\r\n  strcpy(a[n],s);n++;\r\n }\r\n for(int i=0;i&lt;n/2;i++)dois(a[i],a[n-i-1]);\r\n for(int i=0;i&lt;n;i++)dao(a[i]);\r\n rewind(t);\r\n for(int i=0;i&lt;n;i++)fputs(a[i],t);\r\n rewind(t);\r\n printf(&quot;noi dung dao nguoc:\n\n&quot;);\r\n xuat(t);\r\n getch();\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(64, 'hoán vị 1 số trong lập trình c', '<pre class="brush:cpp;">\r\n//ho&aacute;n vị c&aacute;c phần tử trong mảng , ho&aacute;n vị 1 số nhập từ b&agrave;n ph&iacute;m trong lập tr&igrave;nh c\r\n//v&iacute; dụ 123=&gt;6 ho&aacute;n vị\r\n#include&lt;stdio.h&gt;\r\n#include&lt;conio.h&gt;\r\n#include&lt;stdlib.h&gt;\r\nvoid nhap(int *a,int n)\r\n{\r\n for(int i=0;i&lt;n;i++)\r\n {\r\n  printf(&quot;a[%d]=&quot;,i+1);\r\n  scanf(&quot;%d&quot;,&amp;a[i]);\r\n }\r\n}\r\nvoid xuat(int *a,int n)\r\n{\r\n for(int i=0;i&lt;n;i++) printf(&quot;%d &quot;,a[i]);\r\n printf(&quot;\n&quot;);\r\n}\r\nvoid doi(int &amp;a,int &amp;b)\r\n{\r\n int t=a;a=b;b=t;\r\n}\r\nvoid sapxep(int *a,int n,int i)\r\n{\r\n for(int j=i;j&lt;n-1;j++)\r\n  for(int k=j+1;k&lt;n;k++)\r\n   if(a[j]&gt;a[k]) doi(a[j],a[k]);\r\n}\r\nvoid hoanvi(int *a,int n)\r\n{\r\n int i,j;\r\n xuat(a,n);\r\nloop:;\r\n for(i=n-1;i&gt;0;i--) if(a[i]&gt;a[i-1]) break;\r\n if(i!=0)\r\n {\r\n  for(j=n-1;j&gt;=i;j--)\r\n  {\r\n   if(a[j]&gt;a[i-1])\r\n   {\r\n    doi(a[j],a[i-1]);\r\n    sapxep(a,n,i);\r\n    xuat(a,n);\r\n    break;\r\n   }\r\n  }\r\n }\r\n if(i!=0) goto loop;\r\n}\r\nvoid main()\r\n{\r\n int n,i;\r\n printf(&quot;nhap so hoan vi:&quot;);\r\n scanf(&quot;%d&quot;,&amp;n);\r\n int *a=(int *)malloc(n*sizeof(int));\r\n nhap(a,n);\r\n hoanvi(a,n);\r\n getch();\r\n}</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(65, 'chương trình c đếm số từ trong file', '<pre class="brush:cpp;">\r\n//chương tr&igrave;nh đếm số từ trong file\r\n#include&lt;stdio.h&gt;\r\n#include&lt;stdlib.h&gt;\r\nvoid main()\r\n{\r\n FILE *t;\r\n int k=0,dem=0;\r\n t=fopen(&quot;E:\\toan.txt&quot;,&quot;r&quot;);\r\n if(t==NULL)\r\n {\r\n  printf(&quot;error&quot;);\r\n  exit(0);\r\n }\r\n char c;\r\n do\r\n {\r\n  c=getc(t);\r\n  if((c&gt;=&#39;a&#39; &amp;&amp; c&lt;=&#39;z&#39; )||(c&gt;=&#39;A&#39; &amp;&amp; c&lt;=&#39;Z&#39;))k=1;\r\n  if((c==&#39; &#39; || c==&#39;	&#39; || c==10 || c==EOF)&amp;&amp;k==1 )\r\n  {\r\n   dem++;\r\n   k=0;\r\n  }\r\n }while(c!=EOF);\r\n printf(&quot;so tu = %d\n&quot;,dem);\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(66, 'làm tròn 1 số thực', '<p><strong>l&agrave;m tr&ograve;n số đến 0.5</strong><br />\r\nTức l&agrave; nếu coi phần lẻ của số thực l&agrave; x ta sẽ c&oacute; bảng sau:<br />\r\n0,00 &lt;= x &lt; 0,25 lam tron thanh 0,0<br />\r\n0,25 &lt;= x &lt; 0,75 lam tron thanh 0,5<br />\r\n0,75 &lt;= x &lt; 1,0 lam tron thanh 1,0</p>\r\n\r\n<pre class="brush:cpp;">\r\n#include&lt;stdio.h&gt;\r\n#include&lt;conio.h&gt;\r\n#include&lt;math.h&gt;\r\nvoid main()\r\n{\r\n float b=23.24,a=b,c=a;\r\n/*b l&agrave; gi&aacute; trị cần l&agrave;m tr&ograve;n, nếu muốn đưa chương tr&igrave;nh v&agrave;o th&agrave;nh 1 h&agrave;m th&igrave; chỉ cần khai b&aacute;o h&agrave;m float lamtronso(float &amp;b) v&agrave; trả về return b, kh&ocirc;ng cần phải printf*/\r\n while (a&gt;1) a-=1;\r\n if(a&gt;=0 &amp;&amp; a&lt;0.25) b=b-a;\r\n else if(a&gt;=0.25 &amp;&amp; a&lt;0.75) b=b-a+0.5;\r\n else b=b-a+1;\r\n printf(&quot; %f duoc lam tron = %f\n&quot;,c,b);\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(67, 'sắp xếp chẵn trước, lẻ sau và tăng dần - bài tập c', '<pre class="brush:cpp;">\r\n//sắp xếp c&aacute;c phần tử của mảng sao cho c&aacute;c phần tử chẵn đứng trước, c&aacute;c phần tử lẻ đ&uacute;ng sau đ&ocirc;ng thời cũng sắp xếp tăng dần\r\n#include&lt;stdio.h&gt;\r\n#include&lt;conio.h&gt;\r\nint a[10] = { 1, 5, 4, 8, 2, 9, 8, 6, 3, 9 };\r\nint n = 10;\r\nvoid sapxep(int a[], int n)\r\n{\r\n int i, j;\r\n for (i = 0; i &lt; n - 1;i++)\r\n for (j = i + 1; j &lt; n;j++)\r\n if ((a[i] % 2 != 0 &amp;&amp; a[j] % 2 == 0) \r\n  || (a[i] % 2 == 0 &amp;&amp; a[j] % 2 == 0 &amp;&amp; a[i]&gt;a[j]) \r\n  || (a[i] % 2 != 0 &amp;&amp; a[j] % 2 != 0 &amp;&amp; a[i]&gt;a[j]))\r\n {\r\n  int t = a[i];\r\n  a[i] = a[j];\r\n  a[j] = t;\r\n }\r\n}\r\nvoid xuatmang(int a[], int n)\r\n{\r\n for (int i = 0; i &lt; n; i++) printf(&quot; %d &quot;, a[i]);\r\n}\r\nvoid main()\r\n{\r\n sapxep(a, n);\r\n xuatmang(a, n);\r\n printf(&quot;\n&quot;);\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(68, 'viết hàm tính sin(x) - bài tập lập trình c', '<pre class="brush:cpp;">\r\n//viết h&agrave;m t&iacute;nh sin(x)\r\n#include&lt;stdio.h&gt;\r\n#include&lt;conio.h&gt;\r\n#include&lt;math.h&gt;\r\ndouble sin(double x)\r\n{\r\n double ps = x, i = 1, tong = x,dau=-1;\r\n while (fabs(ps) &gt; 0.00001)\r\n {\r\n  ps = ps*x*x / ((i + 1)*(i + 2));\r\n  tong += dau*ps;\r\n  dau = -dau;\r\n }\r\n return tong;\r\n}\r\nvoid main()\r\n{\r\n double x;\r\n printf(&quot;x=&quot;); scanf_s(&quot;%lf&quot;, &amp;x);\r\n printf(&quot;%lf\n&quot;, sin(x));\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(69, 'in ra màn hình tam giác pascal - bài tập c', '<pre class="brush:cpp;">\r\n//in ra m&agrave;n h&igrave;nh tam gi&aacute;c pascal với số h&agrave;ng bất kỳ nhập v&agrave;o\r\n#include&lt;stdio.h&gt;\r\n#include&lt;conio.h&gt;\r\nint tohop(int n, int k)\r\n{\r\n if (k == 1 || k == n) return 1;\r\n return tohop(n - 1, k - 1) + tohop(n - 1, k);\r\n}\r\nvoid main()\r\n{\r\n int n;\r\n printf(&quot;N=&quot;); scanf_s(&quot;%d&quot;, &amp;n);\r\n for (int i = 1; i &lt;= n; i++)\r\n {\r\n  for (int j = 1; j &lt;= i; j++)\r\n  {\r\n   if (j == 1)\r\n   {\r\n    for (int m = 1; m &lt;= n - i;m++) printf(&quot;   &quot;);\r\n   }\r\n   printf(&quot;%2d    &quot;, tohop(i, j));\r\n  }\r\n  printf(&quot;\n\n&quot;);\r\n }\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(70, 'liệt kê số bằng tổng ước số của nó - bài tập c', '<p>Viết chương tr&igrave;nh t&igrave;m v&agrave; in ra c&aacute;c số (&lt;=1000) thỏa t&iacute;nh chất: số bằng tổng c&aacute;c ước số của n&oacute;. V&iacute; dụ: 6 = 1 + 2 + 3.<br />\r\nliệt k&ecirc; số bằng tổng ước số của n&oacute; - b&agrave;i tập c</p>\r\n\r\n<pre class="brush:cpp;">\r\n//liệt k&ecirc; c&aacute;c số nhỏ hơn 1000 thỏa số bằng tổng c&aacute;c ước số của n&oacute;\r\n#include&lt;stdio.h&gt;\r\n#include&lt;conio.h&gt;\r\nvoid so()\r\n{\r\n for (int i = 3; i &lt; 1000; i++)\r\n {\r\n  int tong = 0;\r\n  for (int j = 1; j &lt; i;j++)\r\n  if (i%j == 0) tong += j;\r\n  if (tong == i) printf(&quot;%d\n&quot;,i);\r\n }\r\n}\r\nvoid main()\r\n{\r\n so();\r\n}</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(71, 'tìm kiếm phần tử giá trị k trong mảng ', '<pre class="brush:cpp;">\r\n//t&igrave;m c&aacute;c phần rử c&oacute; gi&aacute; trị bằng k cho trước v&agrave; hiện ra m&agrave;n h&igrave;nh c&aacute;c phần tử đ&oacute;.\r\n#include&lt;stdio.h&gt;\r\n#include&lt;conio.h&gt;\r\nint a[10] = { 1, 2, 3, 4, 3, 4, 2, 3, 4, 1 };\r\nint n = 10;\r\nvoid dem(int a[], int n, int k)\r\n{\r\n int b = 0;\r\n for (int i = 0; i &lt; n;i++)\r\n if (a[i] == k) b++;\r\n printf(&quot;co %d phan tu co gia tri %d\ncac phan tu do la:\n&quot;,b,k);\r\n for (int i = 0; i &lt; n;i++)\r\n if (a[i] == k) printf(&quot; a[%d] &quot;,i);\r\n}\r\nvoid main()\r\n{\r\n printf(&quot;nhap k=&quot;);\r\n int k;\r\n scanf_s(&quot;%d&quot;, &amp;k);\r\n dem(a, n, k);\r\n}</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(72, 'viết chương trình c tính số e và lũy thừa cơ số e', '<pre class="brush:cpp;">\r\n//t&iacute;nh số e, lũy thừa với số e\r\n#include&lt;stdio.h&gt;\r\n#include&lt;conio.h&gt;\r\n#include&lt;math.h&gt;\r\ndouble e(double x)\r\n{\r\n double tong = 1, i = 1, ps = 1;\r\n while (ps &gt; 0.00001)\r\n {\r\n  ps = ps*x / i;\r\n  tong += ps;\r\n  i++;\r\n }\r\n return tong;\r\n}\r\nvoid main()\r\n{\r\n printf(&quot;e^1=%lf\ne^7=%lf\n&quot;, e(1),e(7));\r\n}</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(73, 'lập trình tính số pi', '<pre class="brush:cpp;">\r\n//t&iacute;nh số pi\r\n#include&lt;stdio.h&gt;\r\n#include&lt;conio.h&gt;\r\n#include&lt;math.h&gt;\r\ndouble pi()\r\n{\r\n double dau,s=1,tong=1;\r\n int n = 1;\r\n while (fabs(s)&gt;0.00001)\r\n {\r\n  if (n % 2 == 0) dau = 1; else dau = -1;\r\n  s = dau / (2 * n + 1);\r\n  tong += s;\r\n  n++;\r\n }\r\n return tong*4;\r\n}\r\nvoid main()\r\n{\r\n printf(&quot;%.10lf\n&quot;, pi());\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(74, 'tìm BCNN bội chung nhỏ nhất của 2 số', '<pre class="brush:cpp;">\r\n#include&lt;stdio.h&gt;\r\n#include&lt;conio.h&gt;\r\nvoid main()\r\n{\r\n int a, b, i = 2;\r\n do\r\n {\r\n  printf(&quot;nhap a&gt;0,b&gt;0\n&quot;);\r\n  scanf_s(&quot;%d%d&quot;, &amp;a, &amp;b);\r\n } while (a &lt;= 0 || b &lt;= 0);\r\n while (a%b!=0)\r\n {\r\n  a = a / (i - 1)*i; i++;\r\n }\r\n printf(&quot;BCNN=%d&quot;, a);\r\n _getch();\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(75, 'tìm giá trị xuất hiện nhiều nhất trong mảng và số lần xuất hiện', '<pre class="brush:cpp;">\r\n#include&lt;stdio.h&gt;\r\n#include&lt;conio.h&gt;\r\nint a[100];\r\nvoid main()\r\n{\r\n int i, n,j, max, gt, dem;\r\n printf(&quot;nhap so phan tu cua mang:&quot;);\r\n scanf_s(&quot;%d&quot;, &amp;n);\r\n for (i = 0; i &lt; n; i++)\r\n {\r\n  printf(&quot;a[%d]=&quot;, i + 1);\r\n  scanf_s(&quot;%d&quot;, &amp;a[i]);\r\n }\r\n printf(&quot;mang da nhap:\n&quot;);\r\n for (i = 0; i &lt; n; i++) printf(&quot; %d &quot;, a[i]);\r\n max = 1;\r\n for (i = 0; i &lt; n; i++)\r\n {\r\n  dem = 0;\r\n  for (j = 0; j &lt; n; j++)\r\n  {\r\n   if (a[i] == a[j]) dem++;\r\n  }\r\n  if (max &lt; dem)\r\n  {\r\n   max = dem;\r\n   gt = a[i];\r\n  }\r\n }\r\n printf(&quot;\nphan tu xuat hien nhieu nhat la: %d\n voi so lan xuat hien la: %d&quot;, gt, max);\r\n _getch();\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(76, 'lập trình c tìm phần tử lớn thứ k trong mảng', '<pre class="brush:cpp;">\r\n#include&lt;stdio.h&gt;\r\n#include&lt;conio.h&gt;\r\nint a[100];\r\nvoid main()\r\n{\r\n int i, n, j,k,b,d;\r\n printf(&quot;nhap so phan tu cua mang:&quot;);\r\n scanf_s(&quot;%d&quot;, &amp;n);\r\n for (i = 0; i &lt; n; i++)\r\n {\r\n  printf(&quot;a[%d]=&quot;, i + 1);\r\n  scanf_s(&quot;%d&quot;, &amp;a[i]);\r\n }\r\n printf(&quot;mang da nhap:\n&quot;);\r\n for (i = 0; i &lt; n; i++) printf(&quot; %d &quot;, a[i]);\r\n for (i = 0; i &lt; n-1;i++)\r\n for (j = i + 1; j &lt; n;j++)\r\n if (a[i] &lt; a[j])\r\n {\r\n  k = a[i];\r\n  a[i] = a[j];\r\n  a[j] = k;\r\n }\r\n for (i = 1; i &lt; n; i++)\r\n {\r\n  for (j = 0; j &lt; i; j++)\r\n  {\r\n   if (a[i] == a[j])\r\n   {\r\n    for (d = i; d &lt; n; d++) a[d] = a[d + 1];\r\n    n--;\r\n    i--;\r\n   }\r\n  }\r\n }\r\n do \r\n {\r\n  printf(&quot;\ngia tri lon thu k trong mang: k= &quot;);\r\n  scanf_s(&quot;%d&quot;, &amp;b);\r\n  if (b&gt;n)printf(&quot;khong co phan tu lon thu %d\n nhap so khac!&quot;, b);\r\n } while (b &gt; n);\r\n printf(&quot;gia tri do la: %d&quot;, a[b - 1]);\r\n _getch();\r\n}</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(77, 'lập trình c hiển thị các dãy con tăng trong mảng 1 một chiều', '<pre class="brush:cpp;">\r\n#include&lt;stdio.h&gt;\r\n#include&lt;conio.h&gt;\r\nint a[100];\r\nvoid main()\r\n{\r\n int i, n, dem;\r\n printf(&quot;nhap so phan tu cua mang:&quot;);\r\n scanf_s(&quot;%d&quot;, &amp;n);\r\n for (i = 0; i &lt; n; i++)\r\n {\r\n  printf(&quot;a[%d]=&quot;, i + 1);\r\n  scanf_s(&quot;%d&quot;, &amp;a[i]);\r\n }\r\n printf(&quot;mang da nhap:\n&quot;);\r\n for (i = 0; i &lt; n; i++) printf(&quot; %d &quot;, a[i]);\r\n printf(&quot;\ncac day con tang la:\n&quot;);\r\n for (i = 0; i &lt; n; i++)\r\n {\r\n  dem = 0;\r\n  while (a[i] &lt; a[i + 1])\r\n  {\r\n   if (dem == 0) printf(&quot; %d  %d &quot;, a[i], a[i + 1]);\r\n   else printf(&quot; %d &quot;, a[i + 1]);\r\n   i++; dem++;\r\n  }\r\n  printf(&quot;\n&quot;);\r\n }\r\n _getch();\r\n\r\n}</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(78, 'lập trình c: xóa phần tử trùng nhau trong mảng', '<pre class="brush:cpp;">\r\n#include&lt;stdio.h&gt;\r\n#include&lt;conio.h&gt;\r\nint a[100];\r\nvoid main()\r\n{\r\n int i, j, n, k, dem = 0;\r\n printf(&quot;nhap so phan tu cua mang:&quot;);\r\n scanf_s(&quot;%d&quot;, &amp;n);\r\n for (i = 0; i &lt; n; i++)\r\n {\r\n  printf(&quot;a[%d]=&quot;, i + 1);\r\n  scanf_s(&quot;%d&quot;, &amp;a[i]);\r\n }\r\n printf(&quot;mang da nhap:\n&quot;);\r\n for (i = 0; i &lt; n; i++) printf(&quot; %d &quot;, a[i]);\r\n for (i = 1; i &lt; n; i++)\r\n for (j = 0; j &lt; i; j++)\r\n {\r\n  if (a[i] == a[j])\r\n  {\r\n   for (k = i; k &lt; n; k++) a[k] = a[k + 1];\r\n   n--;\r\n   i--;\r\n  }\r\n }\r\n printf(&quot;\nmang sau khi xoa la:\n&quot;);\r\n for (i = 0; i &lt; n; i++) printf(&quot; %d &quot;, a[i]);\r\n _getch();\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(79, 'lập trình c, chèn thêm phần tử x vào vị trí k trong mảng', '<pre class="brush:cpp;">\r\n#include&lt;stdio.h&gt;\r\n#include&lt;conio.h&gt;\r\nint a[100], b[100];\r\nvoid main()\r\n{\r\n int i,j, n,k,x;\r\n printf(&quot;nhap so phan tu cua mang: &quot;);\r\n scanf_s(&quot;%d&quot;, &amp;n);\r\n for (i = 0; i &lt; n; i++)\r\n {\r\n  printf(&quot;A[%d]=&quot;, i + 1);\r\n  scanf_s(&quot;%d&quot;, &amp;a[i]);\r\n }\r\n printf(&quot;mang da nhap la: \n&quot;);\r\n for (i=0;i&lt;n;i++) printf(&quot; %d &quot;, a[i]);\r\n printf(&quot;\nnhap vi tri muon chen k=&quot;);\r\n scanf_s(&quot;%d&quot;, &amp;k);\r\n printf(&quot;gia tri cua phan tu, x=&quot;);\r\n scanf_s(&quot;%d&quot;, &amp;x);\r\n for (i = 0; i &lt; k-1; i++) b[i] = a[i];\r\n b[k-1] = x;\r\n for (j = i; j &lt; n; j++)\r\n {\r\n  k++;\r\n  b[k-1] = a[j];\r\n }\r\n for (i = 0; i &lt; n + 1; i++)a[i] = b[i];\r\n printf(&quot;mang sau khi chen them la:\n&quot;);\r\n for (i = 0; i &lt; n + 1; i++) printf(&quot; %d &quot;, a[i]);\r\n _getch();\r\n}</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(80, 'lập trình c (mảng 1 chiều) tìm tổng lớn nhất của k phần tử liên tếp', '<pre class="brush:cpp;">\r\n#include&lt;stdio.h&gt;\r\n#include&lt;conio.h&gt;\r\nint a[100];\r\nint b[100];\r\nvoid main()\r\n{\r\n int k,i,n,j;\r\n printf(&quot;nhap so tu cua mang: &quot;);\r\n scanf_s(&quot;%d&quot;, &amp;n);\r\n for (i = 0; i &lt; n; i++)\r\n {\r\n  printf(&quot;nhap phan tu thu %d: &quot;, i + 1);\r\n  scanf_s(&quot;%d&quot;, &amp;a[i]);\r\n }\r\n printf(&quot;tong cua k phan tu lien tiep, nhap k= &quot;);\r\n scanf_s(&quot;%d&quot;, &amp;k);\r\n for (i = 0; i &lt;= n-k; i++)\r\n for (j = 0; j &lt; k; j++)\r\n  b[i] += a[i + j];\r\n int max = b[0];\r\n for (i = 1; i &lt;= n - k;i++)\r\n if (max &lt; b[i])max = b[i];\r\n printf(&quot;tong lon nhat cua %d phan tu lien tiep la: %d&quot;, k, max);\r\n _getch();\r\n\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(81, 'lập trình c kiểm tra tính đối xứng của mảng', '<pre class="brush:cpp;">\r\n#include&lt;stdio.h&gt;\r\n#include&lt;conio.h&gt;\r\nint a[100];\r\nvoid main()\r\n{\r\n int i, n,k=0;\r\n printf(&quot;nhap so phan tu cua mang: &quot;);\r\n scanf_s(&quot;%d&quot;, &amp;n);\r\n for (i = 0; i &lt; n; i++)\r\n {\r\n  printf(&quot;nhap phan tu thu %d: &quot;, i + 1);\r\n  scanf_s(&quot;%d&quot;, &amp;a[i]);\r\n }\r\n for (i = 0; i &lt; n / 2;i++) if (a[i] != a[n -1 - i]) k++;\r\n if (k == 0) printf(&quot;mang doi xung&quot;);\r\n else printf(&quot;mang khong doi xung&quot;);\r\n _getch();\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(82, 'kiểm tra số nguyên tố trong lập trình c', '<pre class="brush:cpp;">\r\n///chương tr&igrave;nh kiểm tra 1 số c&oacute; phải l&agrave; s&ocirc; nguy&ecirc;n t&oacute; kh&ocirc;ng\r\n#include&lt;stdio.h&gt;\r\n#include&lt;conio.h&gt;\r\nvoid kiemtrasonguyento(int n);\r\n/// l&agrave; số nguy&ecirc;n tố nếu n&oacute; kh&ocirc;ng chia hết cho bất cứ số n&agrave;o ngo&agrave;i 1 v&agrave; ch&iacute;nh n&oacute;\r\nvoid main()\r\n{\r\n int n;\r\n printf(&quot;nhap so: &quot;);\r\n scanf_s(&quot;%d&quot;, &amp;n);\r\n kiemtrasonguyento(n);\r\n _getch();\r\n}\r\nvoid kiemtrasonguyento(int n)\r\n{\r\n int dem = 0;\r\n for (int i = 2; i &lt; n; i++)if (n%i == 0) dem++;\r\n if (dem == 0) printf(&quot;la so nguyen to&quot;);\r\n else printf(&quot;khong phai la so nguyen to&quot;);\r\n}</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(83, 'giải hệ phương trình bật nhất n ẩn trong lập trình c', '<pre class="brush:cpp;">\r\n///chương tr&igrave;nh c giải hệ phương tr&igrave;nh bất nhất với số ẩn bất k&igrave;, n ẩn\r\n#include&lt;stdio.h&gt;\r\n#include&lt;conio.h&gt;\r\nvoid nhap(float a[][100], float b[], int n)\r\n{\r\n printf(&quot;_______________________________________________\n&quot;);\r\n for (int i = 0; i &lt; n; i++)\r\n {\r\n  printf(&quot;nhap cac he so phuong trinh %d:\n&quot;, i + 1);\r\n  for (int j = 0; j &lt; n; j++)\r\n   scanf_s(&quot;%f&quot;, &amp;a[i][j]);\r\n  scanf_s(&quot;%f&quot;, &amp;b[i]);\r\n }\r\n printf(&quot;_______________________________________________\n&quot;);\r\n}\r\nfloat det(float a[][100], int n)\r\n{\r\n int i, j, k, dem = 0,kt=0;\r\n float b[100], c[100], h, kq=1;\r\n for (i = 0; i &lt; n - 1; i++)\r\n {\r\n  if (a[i][i] == 0)\r\n  {\r\n   for (j = 0; j &lt; n; j++)\r\n   if (a[i][j] != 0)\r\n   {\r\n    for (k = 0; k &lt; n; k++)\r\n    {\r\n     c[k] = a[k][i];\r\n     a[k][i] = a[k][j];\r\n     a[k][j] = c[k];\r\n    }\r\n    dem++;\r\n    kt++;\r\n    break;\r\n   }\r\n   if (kt == 0) return 0;\r\n  }\r\n  b[i] = a[i][i];\r\n  for (j = 0; j &lt; n; j++) a[i][j] = a[i][j] / b[i];\r\n  for (j = i + 1; j &lt; n; j++)\r\n  {\r\n   h = a[j][i];\r\n   for (k = 0; k &lt; n; k++) a[j][k] = a[j][k] - h*a[i][k];\r\n  }\r\n\r\n }\r\n b[n - 1] = a[n - 1][n - 1];\r\n for (i = 0; i &lt; n; i++) kq *= b[i];\r\n if (dem % 2 == 0) return kq; else return -kq;\r\n}\r\nvoid truyen(float a[][100], float b[][100], int n)\r\n{\r\n for (int i = 0; i &lt; n; i++)\r\n for (int j = 0; j &lt; n; j++)\r\n  b[i][j] = a[i][j];\r\n}\r\nvoid gan(float b[100], float a[100][100], int n, int m)\r\n{\r\n for (int i = 0; i &lt; n; i++)\r\n  a[i][m] = b[i];\r\n}\r\nvoid main()\r\n{\r\n printf(&quot;___________Tran_Khanh_Toan__________________\n&quot;);\r\n printf(&quot;_______________________________________________\n&quot;);\r\n float dd;\r\n float a[100][100], b[100], x[100], c[100][100];\r\n int n, i;\r\n printf(&quot;&gt;&gt;ban muon giai he phuong trinh bat nhat may an ? :&quot;);\r\n scanf_s(&quot;%d&quot;, &amp;n);\r\n nhap(a, b, n);\r\n truyen(a, c, n);\r\n dd = det(c, n);\r\n if (dd!=0)\r\n {\r\n  for (i = 0; i &lt; n; i++)\r\n  {\r\n   truyen(a, c, n);\r\n   gan(b, c, n, i);\r\n   x[i] = det(c, n);\r\n  }\r\n  printf(&quot;he phuong trinh co nghiem la:\n&quot;);\r\n  for (i = 0; i &lt; n; i++)\r\n   printf(&quot;x%d = %.2f\n&quot;, i + 1, x[i]);\r\n }\r\n else printf(&quot;&gt;&gt;he phuong trinh vo nghiem hoac vo so nghiem&quot;);\r\n _getch();\r\n}</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(84, 'tính định thức ma trận cấp n trong lập trình C', '<pre class="brush:cpp;">\r\n/// t&iacute;nh định thức ma trận vu&ocirc;ng bất k&igrave;\r\n#include&lt;stdio.h&gt;\r\n#include&lt;conio.h&gt;\r\n/// h&agrave;m nhập ma trận\r\nvoid nhap(float a[][100], int n)\r\n{\r\n printf(&quot;_________________________________________________________\n&quot;);\r\n for (int i = 0; i &lt; n; i++)\r\n {\r\n  printf(&quot;nhap hang %d:\n&quot;, i + 1);\r\n  for (int j = 0; j &lt; n; j++)\r\n   scanf_s(&quot;%f&quot;, &amp;a[i][j]);\r\n }\r\n printf(&quot;_______________________________________________________\n&quot;);\r\n}\r\n///h&agrave;m xuất ma trận\r\nvoid xuat(float a[][100], int n)\r\n{\r\n printf(&quot;_______________________________________________________\n&quot;);\r\n for (int i = 0; i &lt; n; i++)\r\n {\r\n  for (int j = 0; j &lt; n; j++)\r\n  {\r\n   printf(&quot;%8.2f   &quot;, a[i][j]);\r\n  }\r\n  printf(&quot;\n&quot;);\r\n }\r\n printf(&quot;_________________________________________________________\n&quot;);\r\n}\r\n///h&agrave;m t&iacute;nh ma trận\r\nfloat tinh(float a[][100], int n)\r\n{\r\n ///khai b&aacute;o biến v&agrave; mảng\r\n int i, j, k, dem = 0,kt=0;\r\n float b[100], c[100], h, det = 1;\r\n for (i = 0; i &lt; n - 1; i++)\r\n {\r\n  ///nếu số ở đường ch&eacute;o ch&iacute;nh =0 th&igrave; biến đổi để mất số 0 đ&oacute; đi\r\n  if (a[i][i] == 0)\r\n  {\r\n   ///t&igrave;m 1 số kh&aacute;c kh&ocirc;ng tr&ecirc;n h&agrave;ng i\r\n   for (j = 0; j &lt; n; j++)\r\n   if (a[i][j] != 0)\r\n   {\r\n    ///tiến h&agrave;nh đổi chổ 2 cột i v&agrave; j\r\n    for (k = 0; k &lt; n; k++)\r\n    {\r\n     c[k] = a[k][i];\r\n     a[k][i] = a[k][j];\r\n     a[k][j] = c[k];\r\n    }\r\n    ///sau khi đổi xong th&igrave; đếm số lần đổi v&agrave; tho&aacute;t khỏi v&ograve;ng for,if\r\n    dem++;\r\n    kt++;\r\n    break;\r\n   }\r\n   if (kt == 0) return 0;\r\n   \r\n  }\r\n  ///d&ugrave;ng mảng b[i] để lưu lại những số ta đ&atilde; chia\r\n  b[i] = a[i][i];\r\n  ///tạo số 1 ở d&ograve;ng i cột i\r\n  for (j = 0; j &lt; n; j++) a[i][j] = a[i][j] / b[i];\r\n  ///tiến h&agrave;nh biến đổi để c&oacute; c&aacute;c số 0 tạo th&agrave;nh ma trận tam gi&aacute;c\r\n  for (j = i + 1; j &lt; n; j++)\r\n  {\r\n   h = a[j][i];\r\n   for (k = 0; k &lt; n; k++) a[j][k] = a[j][k] - h*a[i][k];\r\n  }\r\n }\r\n ///v&igrave; số thứ [n][n] ta kh&ocirc;ng thể biến n&oacute; th&agrave;nh số 0 do n&oacute; l&agrave; h&agrave;ng cuối c&ugrave;ng\r\n b[n - 1] = a[n - 1][n - 1];\r\n ///gi&aacute; trị của định thức l&agrave; t&iacute;ch c&aacute;c số m&agrave; ta đ&atilde; chia, tức l&agrave; b[i]\r\n for (i = 0; i &lt; n; i++) det *= b[i];\r\n /// nếu số lần đổi cột l&agrave; số lẻ th&igrave; ta cần th&ecirc;m dấu trừ v&agrave;o định thức đ&atilde; t&iacute;nh ở tr&ecirc;n\r\n if (dem % 2 == 0) return det; else return -det;\r\n}\r\n///chương tr&igrave;nh ch&iacute;nh\r\nvoid main()\r\n{\r\n float a[100][100];\r\n int n;\r\n printf(&quot;nhap cap cua ma tran:\n&quot;);\r\n scanf_s(&quot;%d&quot;, &amp;n);\r\n nhap(a, n);\r\n xuat(a, n);\r\n printf(&quot;dinh thuc cua ma tran la: %.2f&quot;, tinh(a, n));\r\n _getch();\r\n\r\n}</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(85, 'giải hệ phương trình 3 ẩn trong lập trình c', '<pre class="brush:cpp;">\r\n///giải hệ phương tr&igrave;nh 3 ẩn trong c\r\n#include&lt;stdio.h&gt;\r\n#include&lt;conio.h&gt;\r\nvoid main()\r\n{\r\n float a11, a12, a13, a21, a22, a23, a31, a32, a33, b1, b2, b3, x, y, z, d, dx, dy, dz;\r\n printf(&quot;nhap cac he so phuong trinh 1:\n&quot;);\r\n scanf_s(&quot;%f%f%f%f&quot;, &amp;a11, &amp;a12, &amp;a13, &amp;b1);\r\n printf(&quot;nhap cac he so phuong trinh 2:\n&quot;);\r\n scanf_s(&quot;%f%f%f%f&quot;, &amp;a21, &amp;a22, &amp;a23, &amp;b2);\r\n printf(&quot;nhap cac he so phuong trinh 3:\n&quot;);\r\n scanf_s(&quot;%f%f%f%f&quot;, &amp;a31, &amp;a32, &amp;a33, &amp;b3);\r\n d = a11*a22*a33 + a12*a23*a31 + a21*a32*a13 - a13*a22*a31 - a12*a21*a33 - a11*a32*a23;\r\n dx = b1*a22*a33 + a12*a23*b3 + b2*a32*a13 - a13*a22*b3 - a12*b2*a33 - a23*a32*b1;\r\n dy = a11*b2*a33 + b1*a23*a31 + a21*b3*a13 - a13*b2*a31 - b1*a21*a33 - a23*b3*a11;\r\n dz = a11*a22*b3 + a12*b2*a31 + a21*a32*b1 - b1*a22*a31 - a12*a21*b3 - b2*a32*a11;\r\n if (d == 0)\r\n {\r\n  if ((dx == 0) &amp;&amp; (dy == 0) &amp;&amp; (dz == 0))\r\n   printf(&quot;he vo so nghiem&quot;);\r\n  else printf(&quot;he vo nghiem&quot;);\r\n }\r\n else\r\n {\r\n  printf(&quot;he co nghiem la:\n x=%.2f \n y=%.2f \n z=%.2f&quot;, dx / d, dy / d, dz / d);\r\n }\r\n _getch();\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 1, 1, NULL),
(86, 'kiểm tra năm nhuận trong lập trình c', '<pre class="brush:cpp;">\r\n///kiểm tra năm nhuận trong lập tr&igrave;nh c\r\n#include&lt;stdio.h&gt;\r\n#include&lt;conio.h&gt;\r\nvoid main()\r\n{\r\n int year;\r\n printf(&quot;nhap nam:\n&quot;);\r\n scanf_s(&quot;%d&quot;, &amp;year);\r\n if ((year % 400 == 0) | ((year % 4 == 0) &amp;&amp; (year % 100 != 0)))\r\n  printf(&quot;la nam nhan&quot;);\r\n else printf(&quot;khong  la nam nhuan&quot;);\r\n _getch();\r\n}</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(87, 'giải hệ phương tình 2 ẩn trong lập trình c', '<pre class="brush:cpp;">\r\n///giải hệ phương tr&igrave;nh 2 ẩn trong lập tr&igrave;nh c\r\n#include&lt;stdio.h&gt;\r\n#include&lt;conio.h&gt;\r\nvoid main()\r\n{\r\n float a1, b1, c1, a2, b2, c2, d, dx, dy;\r\n printf(&quot;nhap vao cac he so cua phuong trinh 1:a1,b1,c1\n&quot;);\r\n scanf_s(&quot;%f%f%f&quot;, &amp;a1, &amp;b1, &amp;c1);\r\n printf(&quot;nhap vao cac he so cua phuong trih 2:a2,b2,c2 \n&quot;);\r\n scanf_s(&quot;%f%f%f&quot;, &amp;a2, &amp;b2, &amp;c2);\r\n d = a1*b2 - a2*b1;\r\n dx = c1*b2 - c2*b1;\r\n dy = a1*c2 - a2*c1;\r\n if (d == 0)\r\n {\r\n  if ((dx == 0) &amp;&amp; (dy == 0)) printf(&quot;he vo so nghiem&quot;);\r\n  else printf(&quot;he vo nghiem&quot;);\r\n }\r\n else\r\n {\r\n  printf(&quot;x=%.2f\n&quot;, dx / d);\r\n  printf(&quot;y=%.2f\n&quot;, dy / d);\r\n }\r\n _getch();\r\n\r\n}</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(88, '[oop c++] phạm vi truy xuất trong kế thừa', '<p>Truy xuất theo chiều dọc:<br />\r\nH&agrave;m th&agrave;nh phần của lớp con c&oacute; quyền truy xuất c&aacute;c th&agrave;nh phần của&nbsp;<a href="http://www.laptrinh321.tk/2015/06/oop-c-pham-vi-truy-xuat-trong-ke-thua.html" target="_blank">lớp</a>&nbsp;cha hay kh&ocirc;ng?<br />\r\nTruy xuất theo chiều ngang:<br />\r\nC&aacute;c th&agrave;nh phần của lớp cha, sau khi kế thừa xuống lớp con, th&igrave; thế giới b&ecirc;n ngo&agrave;i c&oacute; quyền truy xuất th&ocirc;ng qua đối tượng của lớp con hay kh&ocirc;ng?<br />\r\n<br />\r\n<a name="more"></a><br />\r\n&nbsp;</p>\r\n\r\n<h3>Truy xuất theo chiều dọc</h3>\r\n\r\n<p>Lớp con c&oacute; quyền truy xuất c&aacute;c th&agrave;nh phần của lớp cha hay kh&ocirc;ng, ho&agrave;n to&agrave;n do lớp cha quyết định. Điều đ&oacute; được x&aacute;c định bằng thuộc t&iacute;nh kế thừa.<br />\r\nTrong trường hợp lớp Sinh vi&ecirc;n kế thừa lớp Người, Sinh vi&ecirc;n c&oacute; quyền truy xuất họ t&ecirc;n của ch&iacute;nh m&igrave;nh (được khai b&aacute;o ở lớp Người) hay kh&ocirc;ng?<br />\r\n<br />\r\nclass A{<br />\r\nprivate:<br />\r\nint a;<br />\r\nvoid f();<br />\r\nprotected:<br />\r\nint b;<br />\r\nvoid g();<br />\r\npublic:<br />\r\nint c;<br />\r\nvoid h();<br />\r\n};<br />\r\n<br />\r\nvoid A::f()<br />\r\n{<br />\r\na = 1; b = 2; c = 3;<br />\r\n}<br />\r\nvoid A::g()<br />\r\n{<br />\r\na = 4; b = 5; c = 6;<br />\r\n}<br />\r\nvoid A::h(){<br />\r\na = 7; b = 8; c = 9;<br />\r\n}<br />\r\n&nbsp;</p>\r\n\r\n<h3>Thuộc t&iacute;nh public:</h3>\r\n\r\n<p>Th&agrave;nh phần n&agrave;o c&oacute; thuộc t&iacute;nh public th&igrave; c&oacute; thể truy xuất từ bất cứ nơi n&agrave;o.</p>\r\n\r\n<h3>Thuộc t&iacute;nh private:</h3>\r\n\r\n<p>&nbsp;Th&agrave;nh phần c&oacute; thuộc t&iacute;nh private<br />\r\nL&agrave; ri&ecirc;ng tư của lớp đ&oacute;<br />\r\nChỉ c&oacute; h&agrave;m th&agrave;nh phần của lớp v&agrave; ngoại lệ c&aacute;c h&agrave;m bạn được ph&eacute;p truy xuất.<br />\r\nC&aacute;c lớp con cũng kh&ocirc;ng c&oacute; quyền truy xuất</p>\r\n\r\n<h3>Thuộc t&iacute;nh protected:</h3>\r\n\r\n<p>Cho ph&eacute;p qui định một v&agrave;i th&agrave;nh phần n&agrave;o đ&oacute; của lớp l&agrave; bảo mật, theo nghĩa thế giới b&ecirc;n ngo&agrave;i kh&ocirc;ng được ph&eacute;p truy xuất, nhưng tất cả c&aacute;c lớp con, ch&aacute;u&hellip; đều được ph&eacute;p truy xuất.<br />\r\n<br />\r\nV&iacute; dụ Thuộc t&iacute;nh private<br />\r\nclass Nguoi {<br />\r\nchar *HoTen;<br />\r\nint NamSinh;<br />\r\npublic:<br />\r\n//...<br />\r\n};<br />\r\nclass SinhVien : public Nguoi {<br />\r\nchar *MaSo;<br />\r\npublic:<br />\r\n//...<br />\r\nvoid Xuat() const;<br />\r\n};<br />\r\nTrong v&iacute; dụ tr&ecirc;n, kh&ocirc;ng c&oacute; h&agrave;m th&agrave;nh phần n&agrave;o của lớp SinhVien c&oacute; thể truy xuất c&aacute;c th&agrave;nh phần HoTen, NamSinh của lớp Nguoi.<br />\r\nV&iacute; dụ, đoạn chương tr&igrave;nh sau đ&acirc;y sẽ g&acirc;y ra lỗi:<br />\r\nvoid SinhVien::Xuat() const {<br />\r\ncout &lt;&lt; &quot;Sinh vien, ma so: &quot;&lt;&lt;MaSo&lt;&lt;&quot;,ho&nbsp; ten:&quot;&lt;&lt;HoTen;<br />\r\n}<br />\r\n<br />\r\nTa c&oacute; thể khắc phục lỗi tr&ecirc;n nhờ khai b&aacute;o lớp SinhVien l&agrave; bạn của lớp Nguoi như trong v&iacute; dụ ban đầu:<br />\r\nclass Nguoi {<br />\r\nfriend class SinhVien;<br />\r\nchar *HoTen;<br />\r\nint NamSinh;<br />\r\npublic:<br />\r\n//...<br />\r\n};<br />\r\nKhai b&aacute;o lớp bạn như tr&ecirc;n, lớp SinhVien c&oacute; thể truy xuất c&aacute;c th&agrave;nh phần private của lớp Nguoi.<br />\r\nC&aacute;ch l&agrave;m tr&ecirc;n chỉ giải quyết được nhu cầu của người sử dụng khi muốn tạo lớp con c&oacute; quyền truy xuất c&aacute;c th&agrave;nh phần dữ liệu private của lớp cha.<br />\r\nTuy nhi&ecirc;n, cần phải sửa lại lớp cha v&agrave; tất cả c&aacute;c lớp ở cấp cao hơn mỗi khi c&oacute; một lớp con mới.<br />\r\n<br />\r\nclass Nguoi {<br />\r\nfriend class SinhVien;<br />\r\nfriend class NuSinh;<br />\r\nchar *HoTen; int NamSinh;<br />\r\npublic:<br />\r\n//...<br />\r\nvoid An() const { cout &lt;&lt; HoTen &lt;&lt; &quot; an 3 chen com&quot;;}<br />\r\n};<br />\r\nclass SinhVien : public Nguoi {<br />\r\nfriend class NuSinh;<br />\r\nchar *MaSo;<br />\r\npublic:<br />\r\n//...<br />\r\n};<br />\r\n<br />\r\nTrong v&iacute; dụ trước, khi c&agrave;i đặt lớp NuSinh ta phải thay đổi lớp cha SinhVien v&agrave; cả lớp cơ sở Nguoi ở mức cao hơn.<br />\r\nclass Nguoi {<br />\r\nprotected:<br />\r\nchar *HoTen;<br />\r\nint NamSinh;<br />\r\npublic:<br />\r\n//...<br />\r\n};<br />\r\nclass SinhVien : public Nguoi {<br />\r\nprotected:<br />\r\nchar *MaSo;<br />\r\npublic:<br />\r\nSinhVien(char *ht, char *ms, int ns) : Nguoi(ht,ns){&nbsp;<br />\r\nMaSo = strdup(ms);<br />\r\n}<br />\r\n~SinhVien(){<br />\r\ndelete [ ] MaSo;<br />\r\n}<br />\r\nvoid Xuat() const;&nbsp;<br />\r\n};<br />\r\nclass NuSinh : public SinhVien {<br />\r\npublic:<br />\r\nNuSinh(char *ht, char *ms, int ns) : SinhVien(ht,ms,ns){&nbsp;<br />\r\n}<br />\r\nvoid An() const {&nbsp;<br />\r\ncout &lt;&lt; HoTen &lt;&lt; &quot; ma so &quot; &lt;&lt; MaSo &lt;&lt; &quot; an 2 to pho&quot;;<br />\r\n}<br />\r\n};&nbsp;<br />\r\n// Co the truy xuat Nguoi::HoTen va<br />\r\n// Nguoi::NamSinh va SinhVien::MaSo<br />\r\n<br />\r\nvoid Nguoi::Xuat() const {<br />\r\ncout &lt;&lt; &quot;Nguoi, ho ten: &quot; &lt;&lt; HoTen &lt;&lt; &quot; sinh &quot; &lt;&lt; NamSinh;<br />\r\n}<br />\r\nvoid SinhVien::Xuat() const {<br />\r\ncout &lt;&lt; &quot;Sinh vien, ma so: &quot; &lt;&lt; MaSo &lt;&lt; &quot;, ho ten: &quot; &lt;&lt; HoTen;&nbsp;<br />\r\n// Ok: co quyen truy xuat, Nguoi::HoTen, Nguoi::NamSinh<br />\r\n}<br />\r\nvoid SinhVien::Xuat() const {<br />\r\ncout &lt;&lt; &quot;Sinh vien, ma so: &quot; &lt;&lt; MaSo&nbsp;<br />\r\ncout &nbsp;&lt;&lt; &quot;, ho ten: &quot; &lt;&lt; HoTen;<br />\r\n}<br />\r\n<br />\r\nL&agrave; c&aacute;ch để tr&aacute;nh phải sửa đổi lớp cơ sở khi c&oacute; lớp con mới h&igrave;nh th&agrave;nh Đảm bảo t&iacute;nh đ&oacute;ng g&oacute;i.<br />\r\nTh&ocirc;ng thường ta d&ugrave;ng thuộc t&iacute;nh protected cho th&agrave;nh phần dữ liệu v&agrave; public cho th&agrave;nh phần phương thức.<br />\r\nT&oacute;m tại, th&agrave;nh phần c&oacute; thuộc t&iacute;nh protected chỉ cho ph&eacute;p những lớp con kế thừa được ph&eacute;p sử dụng.<br />\r\n&nbsp;</p>\r\n\r\n<h3>Truy xuất theo chiều ngang</h3>\r\n\r\n<p>Th&agrave;nh phần protected v&agrave; public của lớp khi đ&atilde; kế thừa xuống lớp con th&igrave; thế giới b&ecirc;n ngo&agrave;i c&oacute; quyền truy xuất th&ocirc;ng qua đối tượng thuộc lớp con hay kh&ocirc;ng?<br />\r\nĐiều n&agrave;y ho&agrave;n to&agrave;n do lớp con quyết định bằng phạm vi kế thừa: Kế thừa public, Kế thừa protected, Kế thừa private<br />\r\n&nbsp;</p>\r\n\r\n<h3>Phương thức thiết lập</h3>\r\n\r\n<p>Phương thức thiết lập của lớp cơ sở lu&ocirc;n lu&ocirc;n được gọi mỗi khi c&oacute; một đối tượng của lớp dẫn xuất được tạo ra.<br />\r\n<br />\r\nNếu mọi phương thức thiết lập của lớp cơ sở đều đ&ograve;i hỏi phải cung cấp tham số th&igrave; lớp con bắt buộc phải c&oacute; phương thức thiết lập để cung cấp c&aacute;c tham số đ&oacute;<br />\r\n<br />\r\nclass A {<br />\r\n&nbsp; &nbsp;public:<br />\r\nA ( )<br />\r\n&nbsp;&nbsp;{ &nbsp;cout&lt;&lt; &ldquo;A:default&rdquo;&lt;&lt;endl; &nbsp;}<br />\r\nA (int a){<br />\r\n&nbsp;&nbsp; &nbsp; &nbsp;cout&lt;&lt;&ldquo;A:parameter&rdquo;&lt;&lt;endl;<br />\r\n}<br />\r\n};<br />\r\n<br />\r\nclass A {<br />\r\n&nbsp; &nbsp;public:<br />\r\nA ( )<br />\r\n&nbsp;&nbsp;{ &nbsp;cout&lt;&lt; &ldquo;A:default&rdquo;&lt;&lt;endl; }<br />\r\nA (int a){<br />\r\n&nbsp;&nbsp; cout&lt;&lt;&ldquo;A:parameter&rdquo;&lt;&lt;endl;<br />\r\n}<br />\r\n};<br />\r\n&nbsp;</p>\r\n\r\n<h3>Định nghĩa c&aacute;c th&agrave;nh phần ri&ecirc;ng</h3>\r\n\r\n<p>Ngo&agrave;i c&aacute;c th&agrave;nh phần được kế thừa, lớp dẫn xuất c&oacute; thể định nghĩa th&ecirc;m c&aacute;c th&agrave;nh phần ri&ecirc;ng<br />\r\nclass HinhTron : Diem {<br />\r\ndouble r;<br />\r\npublic:<br />\r\nHinhTron( double tx, double ty, double rr) : Diem(tx, ty){<br />\r\nr = rr;<br />\r\n}<br />\r\nvoid Ve(int color) const;<br />\r\nvoid TinhTien( double dx, double dy) const;<br />\r\n};<br />\r\nHinhTron t(200,200,50);<br />\r\n<br />\r\nLớp dẫn xuất cũng c&oacute; thể override c&aacute;c phương thức đ&atilde; được định nghĩa ở trong lớp cha.<br />\r\n&nbsp;</p>\r\n\r\n<h3>Phương thức hủy bỏ</h3>\r\n\r\n<p>Khi một đối tượng bị hủy đi, phương thức hủy bỏ của n&oacute; sẽ được gọi. Sau đ&oacute;, c&aacute;c phương thức hủy bỏ của lớp cơ sở sẽ được gọi một c&aacute;ch tự động.<br />\r\nV&igrave; vậy, lớp con kh&ocirc;ng cần v&agrave; cũng kh&ocirc;ng được thực hiện c&aacute;c thao t&aacute;c dọn dẹp cho c&aacute;c th&agrave;nh phần thuộc lớp cha.<br />\r\n<br />\r\nclass SinhVien : public Nguoi {<br />\r\nchar *MaSo;<br />\r\npublic:<br />\r\nSinhVien( char *ht, char *ms, int ns) : Nguoi(ht,ns){&nbsp; MaSo = strdup(ms);<br />\r\n}<br />\r\nSinhVien(const SinhVien &amp;s) : Nguoi(s){<br />\r\nMaSo = strdup(s.MaSo);<br />\r\n}<br />\r\n~SinhVien() {delete [ ] MaSo;}<br />\r\n//...<br />\r\n};<br />\r\n&nbsp;</p>\r\n\r\n<h3>Con trỏ v&agrave; kế thừa</h3>\r\n\r\n<p>Con trỏ trong kế thừa hoạt động theo nguy&ecirc;n tắc sau:<br />\r\nCon trỏ trỏ đến đối tượng thuộc lớp cơ sở th&igrave; c&oacute; thể trỏ đến c&aacute;c đối tượng thuộc lớp con.<br />\r\nNhưng con trỏ trỏ đến đối tượng thuộc lớp con th&igrave; kh&ocirc;ng thể trỏ đến c&aacute;c đối tượng thuộc lớp cơ sở.<br />\r\nC&oacute; thể &eacute;p kiểu để con trỏ trỏ đến đối tượng thuộc lớp con c&oacute; thể trỏ đến đối tượng thuộc lớp cơ sở. Tuy nhi&ecirc;n thao t&aacute;c n&agrave;y c&oacute; thể nguy hiểm.</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 1, 1, NULL);
INSERT INTO `baiviet` (`idbv`, `subject`, `content`, `image_bv`, `parent`, `date_add`, `views`, `author`, `des`) VALUES
(89, '[oop c++] Kế thừa - định nghĩa, cú pháp, sử dụng', '<h3>Kế thừa</h3>\r\n\r\n<p>&nbsp;l&agrave; một đặc điểm của ng&ocirc;n ngữ d&ugrave;ng để biểu diễn mối quan hệ đặc biệt h&oacute;a &ndash; tổng qu&aacute;t h&oacute;a giữa c&aacute;c lớp. C&aacute;c&nbsp;<a href="http://www.laptrinh321.tk/2015/06/oop-c-ke-thua-inh-nghia-cu-phap-su-dung.html" target="_blank">lớp</a>&nbsp;được trừu tượng h&oacute;a v&agrave; được tổ chức th&agrave;nh một sơ đồ ph&acirc;n cấp lớp.<br />\r\nSự kế thừa l&agrave; một mức cao hơn của trừu tượng h&oacute;a, cung cấp một cơ chế gom chung c&aacute;c lớp c&oacute; li&ecirc;n quan với nhau th&agrave;nh một mức kh&aacute;i qu&aacute;t h&oacute;a đặc trưng cho to&agrave;n bộ c&aacute;c lớp n&oacute;i tr&ecirc;n.<br />\r\n<br />\r\n<a name="more"></a><br />\r\n<br />\r\nC&aacute;c lớp với c&aacute;c đặc điểm tương tự nhau c&oacute; thể được tổ chức th&agrave;nh một sơ đồ ph&acirc;n cấp kế thừa (c&acirc;y kế thừa).<br />\r\nQuan hệ &ldquo;l&agrave; 1&rdquo;: Kế thừa được sử dụng th&ocirc;ng dụng nhất để biểu diễn quan hệ &ldquo;l&agrave; 1&rdquo;.<br />\r\nMột sinh vi&ecirc;n l&agrave; một người<br />\r\nMột h&igrave;nh tr&ograve;n l&agrave; một h&igrave;nh ellipse<br />\r\nMột tam gi&aacute;c l&agrave; một đa gi&aacute;c<br />\r\n&hellip;</p>\r\n\r\n<h3>Lợi &iacute;ch kế thừa</h3>\r\n\r\n<p>Kế thừa cho ph&eacute;p x&acirc;y dựng lớp mới từ lớp đ&atilde; c&oacute;.<br />\r\nKế thừa cho ph&eacute;p tổ chức c&aacute;c lớp chia sẻ m&atilde; chương tr&igrave;nh chung, nhờ vậy c&oacute; thể dễ d&agrave;ng sửa chữa, n&acirc;ng cấp hệ thống.<br />\r\nTrong C++, kế thừa c&ograve;n định nghĩa sự tương th&iacute;ch, nhờ đ&oacute; ta c&oacute; cơ chế chuyển kiểu tự động.<br />\r\n&nbsp;</p>\r\n\r\n<h3>Đặc t&iacute;nh Kế thừa</h3>\r\n\r\n<p>Cho ph&eacute;p định nghĩa lớp mới từ lớp đ&atilde; c&oacute;.<br />\r\nLớp mới gọi l&agrave; lớp con (subclass) hay lớp dẫn xuất (derived class)<br />\r\nLớp đ&atilde; c&oacute; gọi l&agrave; lớp cha (superclass) hay lớp cơ sở (base class).<br />\r\nThừa kế cho ph&eacute;p:<br />\r\nNhiều lớp c&oacute; thể dẫn xuất từ một lớp cơ sở<br />\r\nMột lớp c&oacute; thể l&agrave; dẫn xuất của nhiều lớp cơ sở<br />\r\nThừa kế kh&ocirc;ng chỉ giới hạn ở một mức: Một lớp dẫn xuất c&oacute; thể l&agrave; lớp cơ sở cho c&aacute;c lớp dẫn xuất kh&aacute;c<br />\r\n&nbsp;</p>\r\n\r\n<h3>C&uacute; ph&aacute;p khai b&aacute;o kế thừa</h3>\r\n\r\n<p>class SuperClass{<br />\r\n//Th&agrave;nh phần của lớp cơ sở<br />\r\n};<br />\r\n<br />\r\nclass DerivedClass : public/protected/private SusperClass{<br />\r\n//Th&agrave;nh phần bổ sung của lớp dẫn xuất<br />\r\n};<br />\r\n&nbsp;</p>\r\n\r\n<h3>Kế thừa đơn</h3>\r\n\r\n<p>X&eacute;t hai kh&aacute;i niệm Người v&agrave; Sinh vi&ecirc;n với mối quan hệ tự nhi&ecirc;n: Một Sinh vi&ecirc;n l&agrave; một Người. Trong C++, ta c&oacute; thể biểu diễn kh&aacute;i niệm tr&ecirc;n, một sinh vi&ecirc;n l&agrave; một người c&oacute; th&ecirc;m một số th&ocirc;ng tin v&agrave; một số thao t&aacute;c (ri&ecirc;ng biệt của sinh vi&ecirc;n).<br />\r\nNhư vậy, ta tổ chức lớp Sinh vi&ecirc;n kế thừa từ lớp Người.<br />\r\n<br />\r\nTa c&oacute; thể tổ chức hai lớp Nam sinh v&agrave; Nữ sinh l&agrave; hai lớp con (lớp dẫn xuất) của lớp Sinh vi&ecirc;n. Trường hợp n&agrave;y, lớp Sinh vi&ecirc;n trở th&agrave;nh lớp cha (lớp cơ sở) của hai lớp tr&ecirc;n.<br />\r\n&nbsp;</p>\r\n\r\n<h3>Kế thừa đơn &ndash; V&iacute; dụ</h3>\r\n\r\n<p>class Nguoi {<br />\r\nchar *HoTen;<br />\r\nint NamSinh;<br />\r\npublic:<br />\r\nNguoi();&nbsp;<br />\r\nNguoi( char *ht, int ns):NamSinh(ns) {HoTen=strdup(ht);}<br />\r\n~Nguoi() {delete [ ] HoTen;}<br />\r\nvoid An() const { cout&lt;&lt;HoTen&lt;&lt;&quot; an 3 chen com \n&quot;;}<br />\r\nvoid Ngu() const { cout&lt;&lt;HoTen&lt;&lt; &quot; ngu ngay 8 tieng \n&quot;;}<br />\r\nvoid Xuat() const;<br />\r\nfriend ostream&amp; operator &lt;&lt; (ostream &amp;os, Nguoi&amp; p);<br />\r\n};<br />\r\nclass SinhVien : public Nguoi {<br />\r\nchar *MaSo;<br />\r\npublic:<br />\r\nSinhVien();<br />\r\nSinhVien( char *ht, char *ms, int ns) : Nguoi(ht,ns) {&nbsp;<br />\r\nMaSo = strdup(ms);<br />\r\n}<br />\r\n~SinhVien() {<br />\r\ndelete [ ] MaSo;<br />\r\n}<br />\r\nvoid Xuat() const;<br />\r\n};<br />\r\nvoid Nguoi::Xuat() const&nbsp;<br />\r\n{<br />\r\ncout &lt;&lt; &quot;Nguoi, ho ten: &quot; &lt;&lt; HoTen;<br />\r\ncout &nbsp;&lt;&lt; &quot; sinh &quot; &lt;&lt; NamSinh;<br />\r\ncout &lt;&lt; endl;<br />\r\n}<br />\r\nvoid SinhVien::Xuat() const {<br />\r\ncout &lt;&lt; &quot;Sinh vien, ma so: &quot; &lt;&lt; MaSo;<br />\r\n//cout &lt;&lt; &quot;, ho ten: &quot; &lt;&lt; HoTen;<br />\r\n//cout &lt;&lt; &quot;, nam sinh: &quot; &lt;&lt; NamSinh;<br />\r\ncout &lt;&lt; endl;<br />\r\n}<br />\r\nvoid main() {<br />\r\nNguoi p1(&quot;Le Van Nhan&quot;,1980);<br />\r\nSinhVien s1(&quot;Vo Vien Sinh&quot;, &quot;200002541&quot;,1984);<br />\r\ncout &lt;&lt; &quot;1.\n&quot;;<br />\r\np1.An();&nbsp; s1.An();<br />\r\ncout &lt;&lt; &quot;2.\n&quot;;<br />\r\np1.Xuat();&nbsp; s1.Xuat();<br />\r\ns1.Nguoi::Xuat();<br />\r\ncout &lt;&lt; &quot;3.\n&quot;;<br />\r\ncout &lt;&lt; p1 &lt;&lt; &quot;\n&quot;;<br />\r\ncout &lt;&lt; s1 &lt;&lt; &quot;\n&quot;;<br />\r\n}<br />\r\n<br />\r\n&nbsp;</p>\r\n\r\n<h3>Kế thừa đặc t&iacute;nh của lớp cha</h3>\r\n\r\n<p>Khai b&aacute;o<br />\r\n&nbsp;&nbsp;class SinhVien : public Nguoi {<br />\r\n&nbsp;//...<br />\r\n&nbsp;&nbsp;};<br />\r\nCho biết lớp Sinh vi&ecirc;n kế thừa từ lớp Người. Khi đ&oacute; Sinh vi&ecirc;n thừa hưởng c&aacute;c đặc t&iacute;nh của lớp Người.<br />\r\nVề mặt dữ liệu: Mỗi đối tượng Sinh vi&ecirc;n tự động c&oacute; th&agrave;nh phần dữ liệu họ t&ecirc;n, năm sinh của người.<br />\r\n<br />\r\nVề mặt thao t&aacute;c: Lớp Sinh vi&ecirc;n được tự động kế thừa c&aacute;c thao t&aacute;c của lớp cha. Đ&acirc;y ch&iacute;nh l&agrave; khả năng sử dụng lại m&atilde; chương tr&igrave;nh.<br />\r\nRi&ecirc;ng phương thức thiết lập kh&ocirc;ng được kế thừa.<br />\r\nKhả năng thừa hưởng c&aacute;c thao t&aacute;c của lớp cơ sở c&oacute; thể được truyền qua &ldquo;v&ocirc; hạn mức&rdquo;.<br />\r\n&nbsp;</p>\r\n\r\n<h3>Định nghĩa lại thao t&aacute;c ở lớp con</h3>\r\n\r\n<p>Ta c&oacute; thể định nghĩa lại c&aacute;c đặc t&iacute;nh ở lớp con đ&atilde; c&oacute; ở lớp cha, việc định nghĩa chủ yếu l&agrave; thao t&aacute;c.<br />\r\n<br />\r\nclass SinhVien : public Nguoi {<br />\r\nchar *MaSo;<br />\r\npublic:<br />\r\n//...<br />\r\nvoid Xuat() const;<br />\r\n};<br />\r\nvoid SinhVien::Xuat() const {<br />\r\ncout &lt;&lt; &quot;Sinh vien, ma so: &quot; &lt;&lt; MaSo &lt;&lt; &quot;, ho ten: &quot; &lt;&lt; HoTen;<br />\r\n}<br />\r\n&nbsp;</p>\r\n\r\n<h3>R&agrave;ng buộc ngữ nghĩa ở lớp con</h3>\r\n\r\n<p>C&oacute; thể &aacute;p dụng quan hệ kế thừa mang &yacute; nghĩa r&agrave;ng buộc, đối tượng ở lớp con l&agrave; đối tượng ở lớp cha nhưng c&oacute; dữ liệu bị r&agrave;ng buộc:<br />\r\nH&igrave;nh tr&ograve;n l&agrave; Ellipse với r&agrave;ng buộc b&aacute;n k&iacute;nh ngang dọc bằng nhau.<br />\r\nSố ảo l&agrave; số phức với r&agrave;ng buộc phần ảo bằng 0<br />\r\n&hellip;<br />\r\nLớp số ảo sau đ&acirc;y l&agrave; một v&iacute; dụ minh họa.<br />\r\nV&iacute; dụ<br />\r\nclass Complex {<br />\r\nfriend ostream&amp; operator &lt;&lt;(ostream&amp;, Complex);<br />\r\nfriend class Imag;<br />\r\ndouble re, im;<br />\r\npublic:<br />\r\nComplex( double r = 0, double i = 0):re(r), im(i){ }<br />\r\nComplex operator +(Complex b);<br />\r\nComplex operator -(Complex b);<br />\r\nComplex operator *(Complex b);<br />\r\nComplex operator /(Complex b);<br />\r\ndouble Norm() const { return sqrt(re*re + im*im);}<br />\r\n};<br />\r\nclass Imag: public Complex {<br />\r\npublic:<br />\r\nImag(double i = 0):Complex(0, i){ }<br />\r\nImag(const Complex &amp;c) : Complex(0, c.im){ }<br />\r\nImag&amp; operator = (const Complex &amp;c){<br />\r\nre = 0; im = c.im;<br />\r\nreturn *this;<br />\r\n}<br />\r\ndouble Norm() const {<br />\r\nreturn fabs(im);<br />\r\n}<br />\r\n};<br />\r\nvoid main()&nbsp;<br />\r\n{<br />\r\nImag i = 1;<br />\r\nComplex z1(1,1)<br />\r\nComplex z3 = z1 - i;&nbsp; // z3 = (1,0)<br />\r\ni = Complex(5,2); // i la so ao (0,2)<br />\r\nImag j = z1; // j la so ao (0,1)<br />\r\ncout &lt;&lt; &quot;z1 = &quot; &lt;&lt; z1 &lt;&lt; &quot;\n&quot;;<br />\r\ncout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot;\n&quot;;<br />\r\ncout &lt;&lt; &quot;j = &quot; &lt;&lt; j &lt;&lt; &quot;\n&quot;;<br />\r\n}<br />\r\n<br />\r\nTrong v&iacute; dụ tr&ecirc;n, lớp số ảo (Imag) kế thừa hầu hết c&aacute;c thao t&aacute;c của lớp số phức (Complex).<br />\r\nTuy nhi&ecirc;n, ta muốn r&agrave;ng buộc mọi đối tượng thuộc lớp số ảo đều phải c&oacute; phần thực bằng 0. V&igrave; vậy, phải định nghĩa lại c&aacute;c h&agrave;m th&agrave;nh phần c&oacute; thể vi phạm điều n&agrave;y.<br />\r\nV&iacute; dụ ph&eacute;p to&aacute;n g&aacute;n phải được định nghĩa lại để đảm bảo r&agrave;ng buộc n&agrave;y.</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(90, '[oop c++] Quan hệ giữa các lớp đối tượng', '<h3>Giữa c&aacute;c lớp đối tượng c&oacute; những loại quan&nbsp;<a href="http://www.laptrinh321.tk/2015/06/oop-c-quan-he-giua-cac-lop-oi-tuong.html">hệ</a>&nbsp;sau:</h3>\r\n\r\n<p>Quan hệ một một (1-1)<br />\r\nQuan hệ một nhiều (1-n)<br />\r\nQuan hệ nhiều nhiều (n-n)<br />\r\nQuan hệ đặc biệt h&oacute;a, tổng qu&aacute;t h&oacute;a<br />\r\n<br />\r\n<a name="more"></a><br />\r\n<br />\r\n&nbsp;</p>\r\n\r\n<h3>Quan hệ một một (1-1)</h3>\r\n\r\n<p>Kh&aacute;i niệm: Hai lớp đối tượng được gọi l&agrave; c&oacute; quan hệ một-một với nhau khi một đối tượng thuộc lớp n&agrave;y quan hệ với một đối tượng thuộc lớp kia v&agrave; một đối tượng thuộc lớp kia c&oacute; quan hệ duy nhất với một đối tượng thuộc lớp n&agrave;y.<br />\r\n&nbsp;</p>\r\n\r\n<h3>Quan hệ một nhiều (1-n)</h3>\r\n\r\n<p>Kh&aacute;i niệm: Hai lớp đối tượng được gọi l&agrave; c&oacute; quan hệ một-nhiều với nhau khi một đối tượng thuộc lớp n&agrave;y quan hệ với nhiều đối tượng thuộc lớp kia v&agrave; một đối tượng lớp kia c&oacute; quan hệ duy nhất với một đối tượng thuộc lớp n&agrave;y.<br />\r\n&nbsp;</p>\r\n\r\n<h3>Quan hệ nhiều nhiều (n-n)</h3>\r\n\r\n<p>Kh&aacute;i niệm: hai lớp đối tượng được gọi l&agrave; quan hệ nhiều-nhiều với nhau khi một đối tượng thuộc lớp n&agrave;y c&oacute; quan hệ với nhiều đối tượng thuộc lớp kia v&agrave; một đối tượng lớp kia cũng c&oacute; quan hệ với nhiều đối tượng thuộc lớp n&agrave;y.<br />\r\n&nbsp;</p>\r\n\r\n<h3>Quan hệ đặc biệt h&oacute;a &ndash; tổng qu&aacute;t h&oacute;a</h3>\r\n\r\n<p>Kh&aacute;i niệm: hai lớp đối tượng được gọi l&agrave; c&oacute; quan hệ đặc biệt h&oacute;a-tổng qu&aacute;t h&oacute;a với nhau khi lớp đối tượng n&agrave;y l&agrave; trường hợp đặc biệt của lớp đối tượng kia v&agrave; lớp đối tượng kia l&agrave; trường hợp tổng qu&aacute;t của lớp đối tượng n&agrave;y.</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(91, '[oop c++] Các nguyên tắc xây dựng lớp', '<ol>\r\n	<li>H&igrave;nh th&agrave;nh lớp: Khi ta nghĩ đến &ldquo;n&oacute;&rdquo; như một kh&aacute;i niệm ri&ecirc;ng lẻ -&gt;X&acirc;y dựng lớp biểu diễn kh&aacute;i niệm đ&oacute;.</li>\r\n	<li>Lớp l&agrave; biểu diễn cụ thể của một kh&aacute;i niệm v&igrave; vậy t&ecirc;n lớp lu&ocirc;n l&agrave; danh từ.</li>\r\n	<li>C&aacute;c thuộc t&iacute;nh của lớp l&agrave; c&aacute;c th&agrave;nh phần dữ liệu n&ecirc;n ch&uacute;ng lu&ocirc;n l&agrave; danh từ.</li>\r\n	<li>C&aacute;c h&agrave;m th&agrave;nh phần (c&aacute;c h&agrave;nh vi) l&agrave; c&aacute;c thao t&aacute;c chỉ r&otilde; hoạt động của lớp n&ecirc;n c&aacute;c h&agrave;m l&agrave; động từ.</li>\r\n	<li>C&aacute;c thuộc t&iacute;nh c&oacute; thể suy diễn từ những thuộc t&iacute;nh kh&aacute;c th&igrave; d&ugrave;ng h&agrave;m th&agrave;nh phần để thực hiện t&iacute;nh to&aacute;n. V&iacute; dụ chu vi, diện t&iacute;ch của một tam gi&aacute;c</li>\r\n	<li>Tuy nhi&ecirc;n, nếu c&aacute;c thuộc t&iacute;nh suy diễn d&ograve;i hỏi nhiều t&agrave;i nguy&ecirc;n hoặc thời gian để thực hiện t&iacute;nh to&aacute;n, ta c&oacute; thể khai b&aacute;o l&agrave; dữ liệu th&agrave;nh phần.</li>\r\n	<li>Dữ liệu th&agrave;nh phần n&ecirc;n được kết hợp:</li>\r\n	<li>Trong mọi trường hợp, n&ecirc;n c&oacute; phương thức thiết lập (Constructor) để khởi động đối tượng</li>\r\n	<li>N&ecirc;n c&oacute; phương thức thiết lập c&oacute; khả năng tự khởi động kh&ocirc;ng cần tham số</li>\r\n	<li>Nếu đối tượng c&oacute; nhu cầu cấp ph&aacute;t t&agrave;i nguy&ecirc;n th&igrave; phải c&oacute; phương thức thiết lập, copy constructor để khởi động đối tượng bằng đối tượng c&ugrave;ng kiểu v&agrave; c&oacute; destructor để dọn dẹp. Ngo&agrave;i ra c&ograve;n c&oacute; ph&eacute;p g&aacute;n (chương 4).</li>\r\n	<li>Nếu đối tượng đơn giản kh&ocirc;ng cần t&agrave;i nguy&ecirc;n ri&ecirc;ng -&gt;Kh&ocirc;ng cần copy constructor v&agrave; destructor</li>\r\n</ol>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 1, 1, NULL),
(92, '[oop c++] Thành viên tĩnh – static member', '<p>Trong C, static xuất hiện trước dữ liệu được khai b&aacute;o trong một h&agrave;m n&agrave;o đ&oacute; th&igrave; gi&aacute; trị của dữ liệu đ&oacute; vẫn được lưu lại như một biến to&agrave;n cục.<br />\r\nTrong C++, nếu static xuất hiện trước một dữ liệu hoặc một phương thức của lớp th&igrave; gi&aacute; trị của n&oacute; vẫn được lưu lại v&agrave; c&oacute; &yacute; nghĩa cho đối tượng kh&aacute;c của c&ugrave;ng lớp n&agrave;y.<br />\r\nC&aacute;c th&agrave;nh vi&ecirc;n static c&oacute; thể l&agrave; public, private hoặc protected.<br />\r\n&nbsp;</p>\r\n\r\n<h3>Đối với class, static d&ugrave;ng để khai b&aacute;o th&agrave;nh vi&ecirc;n dữ liệu d&ugrave;ng chung cho mọi thể hiện của lớp:</h3>\r\n\r\n<p>Một bản duy nhất tồn tại trong suốt qu&aacute; tr&igrave;nh chạy của chương tr&igrave;nh.<br />\r\nD&ugrave;ng chung cho tất cả c&aacute;c thể hiện của lớp.<br />\r\nBất kể lớp đ&oacute; c&oacute; bao nhi&ecirc;u thể hiện.<br />\r\n<br />\r\nV&iacute; dụ<br />\r\nclass Rectangle<br />\r\n{<br />\r\n&nbsp; &nbsp; private:<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp;int width;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp;int length;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp;static int count;<br />\r\n&nbsp; &nbsp; public:<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp;void set(int w, int l);<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp;int area();<br />\r\n}<br />\r\n<br />\r\nV&iacute; dụ<br />\r\nĐếm số đối tượng MyClass:<br />\r\nclass MyClass{<br />\r\n&nbsp; &nbsp; public:<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; MyClass();<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; ~MyClass();<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; void printCount();<br />\r\n&nbsp; &nbsp; private:<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; static int count;<br />\r\n};<br />\r\n<br />\r\nint MyClass::count = 0;<br />\r\nMyClass::MyClass(){<br />\r\n&nbsp; &nbsp; this -&gt; count++;<br />\r\n}<br />\r\nMyClass::~MyClass(){<br />\r\n&nbsp; &nbsp; this -&gt; count--;<br />\r\n}<br />\r\nvoid MyClass::printCount(){<br />\r\n&nbsp; &nbsp; cout &lt;&lt; &ldquo;There are currently &rdquo; &lt;&lt; this  count &lt;&lt; &ldquo; instance(s) of MyClass.\n&rdquo;;<br />\r\n}<br />\r\nvoid main()<br />\r\n{<br />\r\n&nbsp; &nbsp; MyClass* x = new MyClass;<br />\r\n&nbsp; &nbsp; x -&gt; printCount();<br />\r\n&nbsp; &nbsp; MyClass* y = new MyClass;<br />\r\n&nbsp; &nbsp; &nbsp;x -&gt; printCount();<br />\r\n&nbsp; &nbsp; &nbsp;y -&gt; printCount();<br />\r\n&nbsp; &nbsp; delete x;<br />\r\n&nbsp; &nbsp; &nbsp;y -&gt; printCount();<br />\r\n}<br />\r\n<br />\r\n&nbsp;</p>\r\n\r\n<h3>Phương thức static?</h3>\r\n\r\n<p>Đối với c&aacute;c phương thức static, ngo&agrave;i &yacute; nghĩa tương tự với dữ liệu, c&ograve;n c&oacute; sự kh&aacute;c biệt cơ bản đ&oacute; l&agrave; việc cho ph&eacute;p truy cập đến c&aacute;c phương thức static khi chưa khai b&aacute;o đối tượng (th&ocirc;ng qua t&ecirc;n lớp)<br />\r\nC&aacute;c th&agrave;nh vi&ecirc;n lớp tĩnh public c&oacute; thể được truy cập th&ocirc;ng qua bất kỳ đối tượng n&agrave;o của lớp đ&oacute;, hoặc ch&uacute;ng c&oacute; thể được truy cập th&ocirc;ng qua t&ecirc;n lớp sử dụng to&aacute;n tử định phạm vi.<br />\r\nC&aacute;c th&agrave;nh vi&ecirc;n lớp tĩnh private v&agrave; protected phải được truy cập th&ocirc;ng qua c&aacute;c h&agrave;m th&agrave;nh vi&ecirc;n public của lớp hoặc th&ocirc;ng qua c&aacute;c friend của lớp.<br />\r\nC&aacute;c th&agrave;nh vi&ecirc;n lớp tĩnh tồn tại ngay cả khi đối tượng của lớp đ&oacute; kh&ocirc;ng tồn tại.<br />\r\nĐể truy cập một th&agrave;nh vi&ecirc;n lớp tĩnh public khi c&aacute;c đối tượng của lớp kh&ocirc;ng tồn tại, đơn giản th&ecirc;m v&agrave;o đầu t&ecirc;n lớp v&agrave; to&aacute;n tử định phạm vi cho th&agrave;nh vi&ecirc;n dữ liệu.<br />\r\nĐể truy cập một th&agrave;nh vi&ecirc;n lớp tĩnh private hoặc protected khi c&aacute;c đối tượng của lớp kh&ocirc;ng tồn tại, một h&agrave;m th&agrave;nh vi&ecirc;n public phải được cung cấp v&agrave; h&agrave;m phải được gọi bởi th&ecirc;m v&agrave;o đầu t&ecirc;n của n&oacute; với t&ecirc;n lớp v&agrave; to&aacute;n tử định phạm vi.</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(93, '[oop c++] hàm bạn, lớp bạn (friend function)', '<h3><strong>H&agrave;m bạn, lớp bạn (Friend function)</strong></h3>\r\n\r\n<p><br />\r\nGiả sử c&oacute; lớp Vector, lớp Matrix<br />\r\nCần viết h&agrave;m nh&acirc;n Vector với một Matrix<br />\r\nH&agrave;m nh&acirc;n:<br />\r\nKh&ocirc;ng thể thuộc lớp Vector<br />\r\nKh&ocirc;ng thể thuộc lớp Matrix<br />\r\nKh&ocirc;ng thể tự do<br />\r\nGiải ph&aacute;p: X&acirc;y dựng h&agrave;m&nbsp;<a href="http://www.laptrinh321.tk/2015/06/oop-c-ham-ban-lop-ban-friend-function.html">truy</a>&nbsp;cập dữ liệu?<br />\r\nH&agrave;m bạn kh&ocirc;ng thuộc lớp. Tuy nhi&ecirc;n, c&oacute; quyền truy cập c&aacute;c th&agrave;nh vi&ecirc;n private của lớp.<br />\r\nKhi định nghĩa một lớp, c&oacute; thể khai b&aacute;o một hay nhiều h&agrave;m &ldquo;bạn&rdquo; (b&ecirc;n ngo&agrave;i lớp)<br />\r\nƯu điểm:<br />\r\nKiểm so&aacute;t c&aacute;c truy nhập ở cấp độ lớp &ndash; kh&ocirc;ng thể &aacute;p đặt h&agrave;m bạn cho lớp nếu điều đ&oacute; kh&ocirc;ng được dự tr&ugrave; trước trong khai b&aacute;o của lớp.<br />\r\nD&ugrave;ng từ kh&oacute;a friend để khai b&aacute;o, định nghĩa h&agrave;m bạn<br />\r\nĐ&acirc;y l&agrave; c&aacute;ch cho ph&eacute;p chia sẻ dữ liệu giữa c&aacute;c đối tượng với một h&agrave;m t&ugrave;y &yacute; trong chương tr&igrave;nh (h&agrave;m friend) hoặc chia sẻ c&aacute;c th&agrave;nh phần của đối tượng c&oacute; thuộc t&iacute;nh private hay protected với c&aacute;c đối tượng kh&aacute;c (lớp friend).<br />\r\nC&aacute;c t&iacute;nh chất của quan hệ friend:<br />\r\nPhải được cho, kh&ocirc;ng được nhận<br />\r\nLớp B l&agrave; bạn của lớp A, lớp A phải khai b&aacute;o r&otilde; r&agrave;ng B l&agrave; bạn của n&oacute;<br />\r\nKh&ocirc;ng đối xứng, Kh&ocirc;ng bắc cầu<br />\r\nQuan hệ friend c&oacute; vẻ như vi phạm kh&aacute;i niệm đ&oacute;ng g&oacute;i (encapsulation) của OOP nhưng c&oacute; khi lại cần đến n&oacute; để c&agrave;i đặt c&aacute;c mối quan hệ giữa c&aacute;c lớp v&agrave; khả năng đa năng h&oacute;a to&aacute;n tử tr&ecirc;n lớp (sẽ đề cập ở chương sau)<br />\r\n<br />\r\nV&iacute; dụ<br />\r\nclass COUNTERCLASS{<br />\r\n&nbsp; &nbsp; int Counter;<br />\r\npublic:<br />\r\n&nbsp; &nbsp; char CounterChar;<br />\r\n&nbsp; &nbsp; void Init( char );<br />\r\n&nbsp; &nbsp; void AddOne( ){<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; Counter++;<br />\r\n&nbsp; &nbsp; }<br />\r\n&nbsp; &nbsp; friend int Total (int);<br />\r\n};<br />\r\nCOUNTERCLASS MyCounter[26]; &nbsp; &nbsp; //C&oacute; 26 đối tượng<br />\r\nint Total(int NumberObjects)<br />\r\n{<br />\r\n&nbsp; &nbsp; for (int i=0, sum=0; i&lt;NumberObjects; i++)<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; sum += MyCounter[i].Counter<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; //T&iacute;nh tổng số k&yacute; tự trong số c&aacute;c Objects k&yacute; tự<br />\r\n&nbsp; &nbsp; return sum;<br />\r\n}<br />\r\n<br />\r\nLưu &yacute;:<br />\r\nVị tr&iacute; của khai b&aacute;o &ldquo;bạn b&egrave;&rdquo; trong lớp ho&agrave;n to&agrave;n t&ugrave;y &yacute;<br />\r\nTrong h&agrave;m bạn, kh&ocirc;ng c&ograve;n tham số ngầm định this như trong h&agrave;m th&agrave;nh phần<br />\r\nH&agrave;m bạn của một lớp c&oacute; thể c&oacute; một hay nhiều tham số, hoặc c&oacute; thể c&oacute; gi&aacute; trị trả về thuộc kiểu lớp đ&oacute;<br />\r\nMột lớp c&oacute; thể truy cập đến c&aacute;c th&agrave;nh phần c&oacute; thuộc t&iacute;nh private của một lớp kh&aacute;c.<br />\r\nĐể thực hiện được điều n&agrave;y, ch&uacute;ng ta c&oacute; thể lấy to&agrave;n bộ một lớp l&agrave;m bạn (lớp friend) cho lớp kh&aacute;c.<br />\r\n<br />\r\nV&iacute; dụ<br />\r\nclass TOM{<br />\r\npublic:<br />\r\n&nbsp; &nbsp; friend class JERRY; &nbsp; &nbsp; //C&oacute; lớp bạn l&agrave; JERRY<br />\r\nprivate:<br />\r\n&nbsp; &nbsp; int SecretTom; &nbsp; &nbsp; &nbsp;//B&iacute; mật của TOM<br />\r\n};<br />\r\nclass JERRY{<br />\r\npublic:<br />\r\n&nbsp; &nbsp; void Change(TOM T){<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; T.SecretTom++; &nbsp;//Bạn n&ecirc;n c&oacute; thể truy cập<br />\r\n&nbsp; &nbsp; }<br />\r\n};</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(94, '[oop c++] hàm thiết lập constructor, hủy bỏ destructor', '<p>Trong hầu hết c&aacute;c thuật giải, để giải quyết một vấn đề thường phải thực hiện c&aacute;c c&ocirc;ng việc:<br />\r\nKhởi tạo gi&aacute; trị cho biến, cấp ph&aacute;t v&ugrave;ng bộ nhớ của biến con trỏ, mở tập tin để truy cập,&hellip;<br />\r\nHoặc khi kết th&uacute;c, ch&uacute;ng ta phải thực hiện qu&aacute;&nbsp;<a href="http://www.laptrinh321.tk/2015/06/oop-c-ham-thiet-lap-constructor-huy-bo.html">tr&igrave;nh</a>&nbsp;ngược lại như: Thu hồi v&ugrave;ng bộ nhớ đ&atilde; cấp ph&aacute;t, đ&oacute;ng tập tin,&hellip;<br />\r\nC&aacute;c ng&ocirc;n ngữ OOP c&oacute; c&aacute;c phương thức để thực hiện c&ocirc;ng việc n&agrave;y một c&aacute;ch &ldquo;tự động&rdquo; gọi l&agrave; phương thức thiết lập v&agrave; phương thức hủy bỏ.</p>\r\n\r\n<h3>Constructor&nbsp;<a name="more"></a></h3>\r\n\r\n<p>l&agrave; một loại phương thức đặc biệt d&ugrave;ng để khởi tạo thể hiện của lớp.<br />\r\nBất kỳ một đối tượng n&agrave;o được khai b&aacute;o đều phải sử dụng một h&agrave;m thiết lập để khởi tạo c&aacute;c gi&aacute; trị th&agrave;nh phần của đối tượng.<br />\r\nH&agrave;m thiết lập được khai b&aacute;o giống như một phương thức với t&ecirc;n phương thức tr&ugrave;ng với t&ecirc;n lớp v&agrave; kh&ocirc;ng c&oacute; gi&aacute; trị trả về (kể cả void).<br />\r\nConstructor phải c&oacute; thuộc t&iacute;nh public<br />\r\nConstructor c&oacute; thể được khai b&aacute;o chồng như c&aacute;c h&agrave;m C++ th&ocirc;ng thường kh&aacute;c hay kh&ocirc;ng?<br />\r\nConstructor c&oacute; thể được khai b&aacute;o với c&aacute;c tham số c&oacute; gi&aacute; trị ngầm định hay kh&ocirc;ng?<br />\r\nc&acirc;u trả lời l&agrave; c&oacute;:<br />\r\n<br />\r\nV&iacute; dụ<br />\r\nclass point{<br />\r\n&nbsp;&nbsp; /*Khai b&aacute;o c&aacute;c th&agrave;nh phần dữ liệu*/<br />\r\n&nbsp; int x, y;<br />\r\npublic:<br />\r\n&nbsp;&nbsp; point() { x = 0; y = 0; } &nbsp;/*H&agrave;m thiết lập mặc định*/<br />\r\n&nbsp;&nbsp; point(int ox, int oy) { x = ox; y = oy; }/*H&agrave;m thiết lập*/<br />\r\n&nbsp;&nbsp; void move (int dx, int dy);<br />\r\n&nbsp;&nbsp; void display();<br />\r\n};<br />\r\npoint a(5,2);<br />\r\npoint b;<br />\r\npoint c(3);&nbsp;<br />\r\n<br />\r\nV&iacute; dụ<br />\r\nclass point{<br />\r\n&nbsp;&nbsp; /*Khai b&aacute;o c&aacute;c th&agrave;nh phần dữ liệu*/<br />\r\n&nbsp; int x, y;<br />\r\npublic:<br />\r\n&nbsp;&nbsp; point() { x = 0; y = 0; } &nbsp;/*H&agrave;m thiết lập mặc định*/<br />\r\n&nbsp;&nbsp; point(int ox, int oy = 1){ x = ox; y = oy;}/*H&agrave;m thiết lập*/<br />\r\n&nbsp;&nbsp; void move (int dx, int dy);<br />\r\n&nbsp;&nbsp; void display();<br />\r\n};<br />\r\npoint a(5,2);<br />\r\npoint b;<br />\r\npoint c(3);<br />\r\n&nbsp;</p>\r\n\r\n<h3>Constructor mặc định</h3>\r\n\r\n<p>Constructor mặc định (default constructor) l&agrave; constructor được gọi khi thể hiện được khai b&aacute;o m&agrave; kh&ocirc;ng c&oacute; đối số n&agrave;o được cung cấp<br />\r\nMyClass x;<br />\r\nMyClass* p = new MyClass;<br />\r\nNgược lại, nếu tham số được cung cấp tại khai b&aacute;o thể hiện, tr&igrave;nh bi&ecirc;n dịch sẽ gọi constructor kh&aacute;c (overload)<br />\r\nMyClass x(5);<br />\r\nMyClass* p = new MyClass(5);<br />\r\nĐối với constructor mặc định, nếu ta kh&ocirc;ng cung cấp bất kỳ constructor n&agrave;o, C++ sẽ tự sinh constructor mặc định l&agrave; một phương thức rỗng.<br />\r\nTuy nhi&ecirc;n, nếu ta kh&ocirc;ng định nghĩa constructor mặc định nhưng lại c&oacute; c&aacute;c constructor kh&aacute;c, tr&igrave;nh bi&ecirc;n dịch sẽ b&aacute;o lỗi kh&ocirc;ng t&igrave;m thấy constructor mặc định nếu ta kh&ocirc;ng cung cấp tham số khi tạo thể hiện.<br />\r\n<br />\r\nV&iacute; dụ<br />\r\nclass point{<br />\r\n&nbsp;&nbsp; /*Khai b&aacute;o c&aacute;c th&agrave;nh phần dữ liệu*/<br />\r\n&nbsp; int x, y;<br />\r\npublic:<br />\r\n&nbsp;&nbsp; point(int ox, int oy = 1){ x = ox; y = oy;}<br />\r\n&nbsp;&nbsp; void move (int dx, int dy);<br />\r\n&nbsp;&nbsp; void display();<br />\r\n};<br />\r\npoint a(5,2);<br />\r\npoint b;<br />\r\npoint c(3);<br />\r\n&nbsp;</p>\r\n\r\n<h3>Copy constructor</h3>\r\n\r\n<p>Ch&uacute;ng ta c&oacute; thể tạo đối tượng mới giống đối tượng cũ một số đặc điểm, kh&ocirc;ng phải ho&agrave;n to&agrave;n như ph&eacute;p g&aacute;n b&igrave;nh thường, h&igrave;nh thức &ldquo;giống nhau&rdquo; được định nghĩa theo quan niệm của người lập tr&igrave;nh. Để l&agrave;m được vấn đề n&agrave;y, trong c&aacute;c ng&ocirc;n ngữ OOP cho ph&eacute;p ta x&acirc;y dựng phương thức thiết lập sao ch&eacute;p.<br />\r\nĐ&acirc;y l&agrave; phương thức thiết lập c&oacute; tham số l&agrave; tham chiếu đến đối tượng thuộc ch&iacute;nh lớp n&agrave;y.<br />\r\nTrong phương thức thiết lập sao ch&eacute;p c&oacute; thể ta chỉ sử dụng một số th&agrave;nh phần n&agrave;o đ&oacute; của đối tượng ta tham chiếu &ldquo;gần giống nhau&rdquo;<br />\r\n&nbsp;</p>\r\n\r\n<h3>H&agrave;m hủy bỏ &ndash; Destructor</h3>\r\n\r\n<p>Destructor, được gọi ngay trước khi một đối tượng bị thu hồi.<br />\r\nDestructor thường được d&ugrave;ng để thực hiện việc dọn dẹp cần thiết trước khi một đối tượng bị hủy.<br />\r\nMột lớp chỉ c&oacute; duy nhất một Destructor<br />\r\nPhương thức Destructor tr&ugrave;ng t&ecirc;n với t&ecirc;n lớp nhưng c&oacute; dấu ~ đặt trước<br />\r\nĐược tự động gọi thực hiện khi đối tượng hết phạm vi sử dụng.<br />\r\nDestructor phải c&oacute; thuộc t&iacute;nh public<br />\r\n<br />\r\nV&iacute; dụ<br />\r\nclass vector{<br />\r\nint n; &nbsp; //số chiều<br />\r\nfloat *v; &nbsp;&nbsp; //v&ugrave;ng nhớ tọa độ<br />\r\npublic:<br />\r\nvector();&nbsp; //H&agrave;m thiết lập kh&ocirc;ng tham số<br />\r\nvector(int size); //H&agrave;m thiết lập một tham số<br />\r\nvector(int size, float *a);<br />\r\n~vector(); //H&agrave;m hủy bỏ, lu&ocirc;n lu&ocirc;n kh&ocirc;ng c&oacute; tham số<br />\r\nvoid display();<br />\r\n};</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(95, '[oop c++] con trỏ this và phép gán đối tượng', '<h3>Con trỏ this</h3>\r\n\r\n<p><br />\r\nTừ kho&aacute; this trong định nghĩa của c&aacute;c h&agrave;m th&agrave;nh phần&nbsp;<a href="http://www.laptrinh321.tk/2015/06/oop-c-con-tro-this-va-phep-gan-oi-tuong.html">lớp</a>&nbsp;d&ugrave;ng để x&aacute;c định địa chỉ của đối tượng d&ugrave;ng l&agrave;m tham số ngầm định cho h&agrave;m th&agrave;nh phần.<br />\r\nCon trỏ this tham chiếu đến đối tượng đang gọi h&agrave;m th&agrave;nh phần.<br />\r\nV&iacute; dụ:<br />\r\nint Trung(point pt){<br />\r\nreturn (this -&gt; x == pt.x &amp;&amp; this -&gt; y == pt.y);<br />\r\n}<br />\r\n&nbsp;</p>\r\n\r\n<h3>Ph&eacute;p g&aacute;n đối tượng</h3>\r\n\r\n<p>L&agrave; việc sao ch&eacute;p gi&aacute; trị c&aacute;c th&agrave;nh phần dữ liệu từ đối tượng a sang đối tượng b tương ứng từng đ&ocirc;i một<br />\r\nV&iacute; dụ:<br />\r\npoint a, b;<br />\r\na.init(5,2);<br />\r\nb = a;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(96, '[OOP C++] Phạm Vi Truy Xuất Thành Phần Đối Tượng', '<p>Trong định nghĩa của lớp ta c&oacute; thể x&aacute;c định khả năng truy xuất th&agrave;nh phần của một lớp n&agrave;o đ&oacute; từ b&ecirc;n ngo&agrave;i phạm vi lớp.<br />\r\nprivate, protected v&agrave; public l&agrave;&nbsp;<a href="http://www.laptrinh321.tk/2015/06/oop-c-pham-vi-truy-xuat-thanh-phan-oi.html">c&aacute;c</a>&nbsp;từ kho&aacute; x&aacute;c định phạm vi truy xuất<br />\r\nMọi th&agrave;nh phần được liệt k&ecirc; trong phần public đều c&oacute; thể truy xuất trong bất kỳ h&agrave;m n&agrave;o.<br />\r\nNhững th&agrave;nh phần được liệt k&ecirc; trong phần private chỉ được truy xuất b&ecirc;n trong phạm vi lớp.<br />\r\nTrong lớp c&oacute; thể c&oacute; nhiều nh&atilde;n private v&agrave; public<br />\r\nMỗi nh&atilde;n n&agrave;y c&oacute; phạm vi ảnh hưởng cho đến khi gặp một nh&atilde;n kế tiếp hoặc hết khai b&aacute;o lớp.<br />\r\nNh&atilde;n private đầu ti&ecirc;n c&oacute; thể bỏ qua v&igrave; C++ ngầm hiểu rằng c&aacute;c th&agrave;nh phần trước nh&atilde;n public đầu ti&ecirc;n l&agrave; private.<br />\r\n<br />\r\n<a name="more"></a><br />\r\n<br />\r\nclass TamGiac{<br />\r\n&nbsp; private:<br />\r\n&nbsp; &nbsp; float a,b,c;/*độ d&agrave;i ba cạnh*/<br />\r\n&nbsp; public:<br />\r\n&nbsp; &nbsp; void Nhap();/*nhập v&agrave;o độ d&agrave;i ba cạnh*/<br />\r\n&nbsp; &nbsp; void In();/*in ra c&aacute;c th&ocirc;ng tin li&ecirc;n quan đến tam gi&aacute;c*/<br />\r\n&nbsp; private:<br />\r\n&nbsp; &nbsp; int Loaitg();//cho biết kiểu của tam gi&aacute;c: 1-d,2-vc,3-c,4-v,5-t<br />\r\n&nbsp; &nbsp; float DienTich();/*t&iacute;nh diện t&iacute;ch của tam gi&aacute;c*/<br />\r\n&nbsp; };<br />\r\n<br />\r\n<br />\r\nclass TamGiac{<br />\r\n&nbsp; private:<br />\r\n&nbsp; &nbsp; float a,b,c;/*độ d&agrave;i ba cạnh*/<br />\r\n&nbsp; &nbsp; int Loaitg();//cho biết kiểu của tam gi&aacute;c: 1-d,2-vc,3-c,4-v,5-t<br />\r\n&nbsp; &nbsp; float DienTich();/*t&iacute;nh diện t&iacute;ch của tam gi&aacute;c*/<br />\r\n&nbsp; public:<br />\r\n&nbsp; &nbsp; void Nhap();/*nhập v&agrave;o độ d&agrave;i ba cạnh*/<br />\r\n&nbsp; &nbsp; void In();/*in ra c&aacute;c th&ocirc;ng tin li&ecirc;n quan đến tam gi&aacute;c*/<br />\r\n};<br />\r\nvoid point::init (int xx, int yy){<br />\r\nx = xx;<br />\r\ny = yy; &nbsp;//x, y la thanh phan cua lop point<br />\r\n}<br />\r\n<br />\r\nH&agrave;m th&agrave;nh phần c&oacute; quyền truy nhập đến c&aacute;c th&agrave;nh phần private của đối tượng gọi n&oacute;<br />\r\nH&agrave;m th&agrave;nh phần c&oacute; quyền truy cập đến tất cả c&aacute;c th&agrave;nh phần private của c&aacute;c đối tượng, tham chiếu đối tượng hay con trỏ đối tượng c&oacute; c&ugrave;ng kiểu lớp khi được d&ugrave;ng l&agrave; tham số h&igrave;nh thức của n&oacute;.</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(97, 'thao tác file với thư viện fstream', '<p>Để sử dụng được thư viện fstream, ta phải include thư viện fstream v&agrave; using namespace std;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>#include &lt;fstream&gt;</p>\r\n\r\n<p>using namespace std;</p>\r\n\r\n<p>Điều đầu ti&ecirc;n, ta tạo ra một đối tượng&nbsp;<a href="http://www.laptrinh321.tk/2015/06/thao-tac-file-voi-thu-vien-fstream.html">fstream</a>. Ta sẽ thao t&aacute;c với file th&ocirc;ng qua đối tượng đ&oacute;.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>fstream f;</p>\r\n\r\n<p>Để mở một file, ta d&ugrave;ng phương thức open sau:</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>f.open(filePath, mod);</p>\r\n\r\n<p>Trong đ&oacute;:</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>filePath c&oacute; kiểu dữ liệu l&agrave; const char*, l&agrave; đường dẫn đến file cần mở.</p>\r\n\r\n<p>mod l&agrave; chế độ mở file. Ch&uacute;ng ta c&oacute; một số chế độ như sau:</p>\r\n\r\n<p>ios::in Mở file để đọc.</p>\r\n\r\n<p>ios::out Mở file c&oacute; sẵn để ghi</p>\r\n\r\n<p>ios::binary Mở file ở chế độ nhị ph&acirc;n.</p>\r\n\r\n<p>ios:ate Mở file v&agrave; đặt con trỏ file v&agrave;o cuối file.</p>\r\n\r\n<p>ios::app Mở file v&agrave; ghi dữ liệu v&agrave;o cuối file. Nếu file kh&ocirc;ng tồn tại th&igrave; tạo file mới.</p>\r\n\r\n<p>ios::trunc Chế độ mở file, x&oacute;a bỏ ho&agrave;n to&agrave;n nội dung trong file được mở.</p>\r\n\r\n<p><br />\r\n<a name="more"></a></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Đọc v&agrave; ghi dữ liệu với định dạng file nhị ph&acirc;n</p>\r\n\r\n<p>Khi mở file m&agrave; kh&ocirc;ng ghi r&otilde; chế độ mở file, tr&igrave;nh bi&ecirc;n dịch sẽ chuyển về chế độ mở file text. V&igrave; vậy, khi muốn mở ở chế độ binary, ta cần phải ghi r&otilde; r&agrave;ng mod l&agrave; ios::binary. Việc mở file dưới chế độ binary c&oacute; nghĩa l&agrave; ch&uacute;ng ta sẽ đọc th&ocirc;ng tin theo dạng binary file. Ch&uacute;ng ta sẽ sử dụng h&agrave;m write v&agrave; read để đọc v&agrave; ghi file dưới dạng binary.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>f.read(address, size);</p>\r\n\r\n<p>f.write(address, size);</p>\r\n\r\n<p>adress: Kiểu dữ liệu char*, l&agrave; địa chỉ v&ugrave;ng nhớ của dữ liệu được lưu v&agrave;o file.</p>\r\n\r\n<p>size: Kiểu dữ liệu int, l&agrave; số byte v&ugrave;ng nhớ</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ol>\r\n	<li>#include&nbsp;&lt;fstream&gt;&nbsp;&nbsp;</li>\r\n	<li>&nbsp;&nbsp;&nbsp;</li>\r\n	<li>using&nbsp;namespace&nbsp;std;&nbsp;&nbsp;</li>\r\n	<li>&nbsp;&nbsp;&nbsp;</li>\r\n	<li>int&nbsp;main()&nbsp;&nbsp;</li>\r\n	<li>{&nbsp;&nbsp;</li>\r\n	<li>&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;data[100];&nbsp;&nbsp;</li>\r\n	<li>&nbsp;&nbsp;&nbsp;</li>\r\n	<li>&nbsp;&nbsp;&nbsp;&nbsp;fstream&nbsp;f;&nbsp;&nbsp;</li>\r\n	<li>&nbsp;&nbsp;&nbsp;&nbsp;f.open(&quot;text.txt&quot;,&nbsp;ios::in&nbsp;|&nbsp;ios::binary);&nbsp;&nbsp;</li>\r\n	<li>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!f)&nbsp;&nbsp;</li>\r\n	<li>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;&nbsp;&nbsp;</li>\r\n	<li>&nbsp;&nbsp;&nbsp;</li>\r\n	<li>&nbsp;&nbsp;&nbsp;&nbsp;f.read(data,&nbsp;sizeof(data));&nbsp;&nbsp;</li>\r\n	<li>&nbsp;&nbsp;&nbsp;&nbsp;f.close();&nbsp;&nbsp;</li>\r\n	<li>&nbsp;&nbsp;&nbsp;</li>\r\n	<li>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;</li>\r\n	<li>}&nbsp;&nbsp;</li>\r\n</ol>\r\n\r\n<p>Đọc v&agrave; ghi dữ liệu với định dạng file text<br />\r\nSau khi mở tệp tin ta sẽ tiến h&agrave;nh đọc v&agrave; ghi file bằng operator &gt;&gt; v&agrave; &lt;&lt;.<br />\r\n<br />\r\nĐọc file<br />\r\nf &gt;&gt; data;<br />\r\nf: &nbsp;Kiểu dữ liệu fstream, l&agrave; t&ecirc;n biến file.<br />\r\ndata: l&agrave; t&ecirc;n biến lưu trữ dữ liệu.<br />\r\n<br />\r\nGhi file<br />\r\nf &lt;&lt; data;<br />\r\nf: l&agrave; t&ecirc;n biến file.<br />\r\ndata: t&ecirc;n biến dữ liệu chứa data cần ghi v&agrave;o file.<br />\r\n<br />\r\nĐ&oacute;ng file<br />\r\n<br />\r\nSau khi thao t&aacute;c với file, ta sẽ tiến h&agrave;nh đ&oacute;ng file bằng lệnh:<br />\r\n<br />\r\nf.close()<br />\r\n&nbsp;</p>\r\n\r\n<p>IV.C&aacute;ch truyền 1 file name v&agrave;o h&agrave;m :</p>\r\n\r\n<p>Ch&uacute;ng ta khi l&agrave;m việc với những chương tr&igrave;nh thực sự th&igrave; đ&ocirc;i khi ch&uacute;ng ta cần phải truyền 1 t&ecirc;n file v&agrave;o h&agrave;m n&agrave;o đ&oacute; để tiện cho việc quản l&yacute;, nhưng khi truyền phải lưu &yacute; l&agrave; lu&ocirc;n lu&ocirc;n truyền bằng tham chiếu..</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>.D&ugrave;ng h&agrave;m th&agrave;nh vi&ecirc;n để đọc v&agrave; ghi file :</p>\r\n\r\n<p>Khoảng trắng (Whitespace) l&agrave; 1 k&iacute; tự m&agrave; n&oacute; l&agrave; 1 phần của dữ liệu, vấn đề sẽ nảy sinh khi ta đoc v&agrave;o bằng to&aacute;n tử &gt;&gt;. Bởi v&igrave; t<strong>o&aacute;n tử &gt;&gt;&nbsp;</strong>n&oacute; xem khoảng trắng như 1 k&iacute; tự kết th&uacute;c (delimiter), v&igrave; thế n&oacute; sẽ kh&ocirc;ng đọc ch&uacute;ng v&agrave;o. Ch&uacute;ng ta sẽ d&ugrave;ng h&agrave;m getline() để xử l&yacute; những trường hợp như vậy.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Hoặc nếu kh&ocirc;ng th&iacute;ch d&ugrave;ng k&iacute; tự mặc định &#39;\n&#39; của h&agrave;m&nbsp;<strong>getline()</strong>&nbsp;th&igrave; ta c&oacute; thể d&ugrave;ng 1 k&iacute; tự bất k&igrave; kh&aacute;c như sau v&iacute; dụ :// B&acirc;y h d&ugrave;ng k&iacute; tự $ l&agrave; k&iacute; tự kết th&uacute;c.&nbsp;</p>\r\n\r\n<p><strong>dataFile.getline(input, SIZE, &#39;$&#39;);&nbsp;</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>I.H&agrave;m get() :</p>\r\n\r\n<p>H&agrave;m get()l&agrave; 1 h&agrave;m rất hữu dụng trong việc thao t&aacute;c với file. V&iacute; dụ :</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>inFile.get(ch);&nbsp;</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Trong v&iacute; dụ tr&ecirc;n th&igrave; ch l&agrave; 1 biến kiểu char. Một k&iacute; tự sẽ được đọc v&agrave;o từ file v&agrave; lưu v&agrave;o ch. Chương tr&igrave;nh sau sẽ l&agrave; 1 demo cho c&aacute;ch d&ugrave;ng get.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Chương tr&igrave;nh tr&ecirc;n sẽ xuất ra nội dung của bất k&igrave; file như thế n&agrave;o. H&agrave;m get() sẽ đọc lu&ocirc;n những k&iacute; tự trắng v&igrave; thế nội dung file sẽ y chang như n&oacute; xuất hiện trong file.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>II.H&agrave;m put()</p>\r\n\r\n<p>H&agrave;m get sẽ ghi 1 k&iacute; tự v&agrave;o file. V&iacute; dụ :</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>outFile.put(ch);&nbsp;</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Trong v&iacute; dụ tr&ecirc;n th&igrave; biến ch l&agrave; kiểu char.&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>III. C&aacute;c h&agrave;m định vị cho file tuần tự</p>\r\n\r\n<p>&bull; con trỏ vị tr&iacute; ghi số thứ tự của byte tiếp theo để đọc/ghi</p>\r\n\r\n<p>&bull; c&aacute;c h&agrave;m đặt lại vị tr&iacute; của con trỏ:</p>\r\n\r\n<p>&ndash;&nbsp;seekg (đặt vị tr&iacute; đọc cho lớp istream)</p>\r\n\r\n<p>&ndash; seekp (đặt vị tr&iacute; ghi cho ostream)</p>\r\n\r\n<p>&ndash; seekg v&agrave; seekp lấyc&aacute;c đối số l&agrave; offset v&agrave; mốc (offset: số byte tương đối kể từ mốc)</p>\r\n\r\n<p>&bull;Mốc(ios::beg mặc định)</p>\r\n\r\n<p>&ndash; ios::beg - đầu file</p>\r\n\r\n<p>&ndash; ios::cur -vị tr&iacute; hiện tại</p>\r\n\r\n<p>&ndash; ios::end -cuối file</p>\r\n\r\n<p>&bull; c&aacute;c h&agrave;m lấy vị tr&iacute; hiện tại của con trỏ:</p>\r\n\r\n<p>&ndash; tellg v&agrave; tellp</p>\r\n\r\n<p>&bull;V&iacute; dụ</p>\r\n\r\n<p>PHP Code:</p>\r\n\r\n<p><strong>fileObject.seekg(0)</strong></p>\r\n\r\n<p>đến đầu file (vị tr&iacute; 0), mặc định đối số thứ hai l&agrave; ios::beg</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>fileObject.seekg(n)</strong></p>\r\n\r\n<p>đến byte thứ n kể từ đầu file</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>fileObject.seekg(n, ios::cur)</strong></p>\r\n\r\n<p>tiến n byte</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>fileObject.seekg(y, ios::end)</strong></p>\r\n\r\n<p>l&ugrave;i y byte kể từ cuối file</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>fileObject.seekg(0, ios::cur)</strong></p>\r\n\r\n<p>đến cuối file</p>\r\n\r\n<p>seekp tương tự</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>location = fileObject.tellg()</strong></p>\r\n\r\n<p>lấy vị tr&iacute; đọc hiện tại của fileObject&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(98, '[opp c++] nhập xuất điểm trong tọa độ oxy', '<p><strong>diem.h</strong></p>\r\n\r\n<pre class="brush:cpp;">\r\n#pragma once  \r\n#include&lt;iostream&gt;  \r\nusing namespace std;  \r\nclass diem  \r\n{  \r\nprivate:  \r\n    float x,y;  \r\npublic:  \r\n    diem(float=0,float=0);  \r\n    ~diem(void);  \r\n    friend istream &amp;operator&gt;&gt;(istream &amp;in,diem &amp;a);  \r\n    friend ostream &amp;operator&lt;&lt;(ostream &amp;out,const diem &amp;a);  \r\n};  </pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>diem.cpp</strong></p>\r\n\r\n<pre class="brush:cpp;">\r\n#include &quot;diem.h&quot;  \r\ndiem::diem(float a,float b)  \r\n{  \r\n    x=a;y=b;  \r\n}  \r\n  \r\ndiem::~diem(void)  \r\n{  \r\n}  \r\nistream &amp;operator&gt;&gt;(istream &amp;in,diem &amp;a)  \r\n{  \r\n    cout&lt;&lt;&quot;x=&quot;;in&gt;&gt;a.x;  \r\n    cout&lt;&lt;&quot;y=&quot;;in&gt;&gt;a.y;  \r\n    return in;  \r\n}  \r\nostream &amp;operator&lt;&lt;(ostream &amp;out,const diem &amp;a)  \r\n{  \r\n    out&lt;&lt;&quot;(&quot;&lt;&lt;a.x&lt;&lt;&quot;,&quot;&lt;&lt;a.y&lt;&lt;&quot;)&quot;;  \r\n    return out;  \r\n}  </pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>main.cpp</strong></p>\r\n\r\n<pre class="brush:cpp;">\r\n#include&quot;diem.h&quot;  \r\nvoid main()  \r\n{  \r\n    diem x;  \r\n    cin&gt;&gt;x;  \r\n    cout&lt;&lt;x;  \r\n    system(&quot;pause&quot;);  \r\n}  \r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(99, 'OOP C++ cộng trừ nhân chia số phức', '<p><strong>sophuc.h</strong></p>\r\n\r\n<pre class="brush:cpp;">\r\n#pragma once  \r\n#include&lt;iostream&gt;  \r\nusing namespace std;  \r\nclass sophuc  \r\n{  \r\nprivate:  \r\n    float t,a;  \r\npublic:  \r\n    sophuc(float =0,float =0);  \r\n    ~sophuc(void);  \r\n    float dodai();  \r\n    sophuc operator+(const sophuc &amp;);  \r\n    sophuc operator-(const sophuc &amp;);  \r\n    sophuc operator*(const sophuc &amp;);  \r\n    sophuc operator/(const sophuc &amp;);  \r\n    bool operator&lt;(sophuc &amp;);  \r\n    bool operator&lt;=(sophuc &amp;);  \r\n    bool operator&gt;(sophuc &amp;);  \r\n    bool operator&gt;=(sophuc&amp;);  \r\n    bool operator==(sophuc&amp;);  \r\n    bool operator!=(sophuc&amp;);  \r\n    friend ostream &amp;operator&lt;&lt;(ostream &amp;out,const sophuc &amp;a);  \r\n    friend istream &amp;operator&gt;&gt;(istream &amp;in,sophuc &amp;a);  \r\n};  </pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>sophuc.cpp</strong></p>\r\n\r\n<pre class="brush:cpp;">\r\n#include &quot;sophuc.h&quot;  \r\n  \r\nsophuc::sophuc(float b,float c)  \r\n{  \r\n    t=b;a=c;  \r\n}  \r\nfloat sophuc::dodai()  \r\n{  \r\n    return sqrt(t*t+a*a);  \r\n}  \r\n  \r\nsophuc::~sophuc(void)  \r\n{  \r\n}  \r\nsophuc sophuc::operator+(const sophuc &amp;x)  \r\n{  \r\n    sophuc c;  \r\n    c.t=x.t+this-&gt;t;  \r\n    c.a=x.a+this-&gt;a;  \r\n    return c;  \r\n}  \r\nostream &amp;operator&lt;&lt;(ostream &amp;out,const sophuc &amp;a)  \r\n{  \r\n    if(a.t==0 &amp;&amp; a.a!=0) out&lt;&lt;a.a&lt;&lt;&quot;i&quot;;  \r\n    else if(a.a==0 &amp;&amp; a.t!=0) out&lt;&lt;a.t;  \r\n    else if(a.t==0 &amp;&amp; a.a==0) out&lt;&lt;0;  \r\n    else out&lt;&lt;a.t&lt;&lt;((a.a&gt;0)?&quot; + &quot;:&quot; - &quot;)&lt;&lt;abs(a.a)&lt;&lt;&quot;i&quot;;  \r\n    return out;  \r\n}  \r\nistream &amp;operator&gt;&gt;(istream &amp;in,sophuc &amp;a)  \r\n{  \r\n    cout&lt;&lt;&quot;phan thuc=&quot;;in&gt;&gt;a.t;  \r\n    cout&lt;&lt;&quot;phan ao=&quot;;in&gt;&gt;a.a;  \r\n    return in;  \r\n}  \r\nsophuc sophuc::operator-(const sophuc&amp;x)  \r\n{  \r\n    sophuc c;  \r\n    c.t=t-x.t;  \r\n    c.a=a-x.a;  \r\n    return c;  \r\n}  \r\nsophuc sophuc::operator*(const sophuc&amp;x)  \r\n{  \r\n    sophuc c;  \r\n    c.t=t*x.t-a*x.a;  \r\n    c.a=t*x.a+a*x.t;  \r\n    return c;  \r\n}  \r\nsophuc sophuc::operator/(const sophuc&amp;x)  \r\n{  \r\n    sophuc c;  \r\n    c.t=(t*x.t+a*x.a)/(x.t*x.t+x.a*x.a);  \r\n    c.a=(x.t*a-t*x.a)/(x.t*x.t+x.a*x.a);  \r\n    return c;  \r\n}  \r\nbool sophuc::operator&lt;(sophuc&amp;x)  \r\n{  \r\n    if(dodai()&lt;x.dodai()) return true;return false;  \r\n}  \r\nbool sophuc::operator&lt;=(sophuc&amp;x)  \r\n{  \r\n    if(dodai()&lt;=x.dodai()) return true;return false;  \r\n}  \r\nbool sophuc::operator&gt;(sophuc&amp;x)  \r\n{  \r\n    if(dodai()&gt;x.dodai()) return true;return false;  \r\n}  \r\nbool sophuc::operator&gt;=(sophuc&amp;x)  \r\n{  \r\n    if(dodai()&gt;=x.dodai()) return true;return false;  \r\n}  \r\nbool sophuc::operator==(sophuc&amp;x)  \r\n{  \r\n    if(dodai()==x.dodai()) return true;return false;  \r\n}  \r\nbool sophuc::operator!=(sophuc&amp;x)  \r\n{  \r\n    if(dodai()!=x.dodai()) return true;return false;  \r\n}  </pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>main.cpp</strong></p>\r\n\r\n<pre class="brush:cpp;">\r\n#include&quot;sophuc.h&quot;  \r\nvoid main()  \r\n{  \r\n    sophuc a,b,c;  \r\n    cin&gt;&gt;a&gt;&gt;b;  \r\n    cout&lt;&lt;a+b&lt;&lt;endl;  \r\n    cout&lt;&lt;a-b&lt;&lt;endl;  \r\n    cout&lt;&lt;a*b&lt;&lt;endl;  \r\n    cout&lt;&lt;a/b&lt;&lt;endl;  \r\n    if(a&gt;b) cout&lt;&lt;1&lt;&lt;endl;else cout&lt;&lt;0&lt;&lt;endl;  \r\n    if(a&gt;=b) cout&lt;&lt;1&lt;&lt;endl;else cout&lt;&lt;0&lt;&lt;endl;  \r\n    if(a&lt;b) cout&lt;&lt;1&lt;&lt;endl;else cout&lt;&lt;0&lt;&lt;endl;  \r\n    if(a&lt;=b) cout&lt;&lt;1&lt;&lt;endl;else cout&lt;&lt;0&lt;&lt;endl;  \r\n    if(a==b) cout&lt;&lt;1&lt;&lt;endl;else cout&lt;&lt;0&lt;&lt;endl;  \r\n    if(a!=b) cout&lt;&lt;1&lt;&lt;endl;else cout&lt;&lt;0&lt;&lt;endl;  \r\n    system(&quot;pause&quot;);  \r\n}  </pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL);
INSERT INTO `baiviet` (`idbv`, `subject`, `content`, `image_bv`, `parent`, `date_add`, `views`, `author`, `des`) VALUES
(100, '[OOP C++] Tính Tổng, Hiệu, Tích, Thương của 2 phân số theo kiểu lập trình hướng đối tượng', '<p><strong><em>PHANSO.H</em></strong></p>\r\n\r\n<pre class="brush:cpp;">\r\n#pragma once\r\n#include&lt;iostream&gt;\r\n#include&lt;string.h&gt;\r\n#include&lt;stdlib.h&gt;\r\nusing namespace std;\r\nclass phanso\r\n{\r\nprivate:\r\n int tu,mau;\r\npublic:\r\n phanso(void);\r\n ~phanso(void);\r\n int gettu(); //trả về gi&aacute; trị của tử số.\r\n int getmau(); //trả về gi&aacute; trị của mẫu số.\r\n void settu(int); //c&agrave; đặt gi&aacute; trị cho tử v&agrave; mẫu\r\n void setmau(int);\r\n void nhapphanso();\r\n void xuatphanso();\r\n int rutgon();\r\n // c&aacute;c phương thức t&iacute;nh tổng, hiệu, t&iacute;ch, thương của ph&acirc;n số \r\n//ta đang viết class với ph&acirc;n số kh&aacute;c\r\n //cũng l&agrave; ph&acirc;n số thuộc đối tượng phanso nhưng n&oacute; nằm ngo&agrave;i phạm vi hoạt \r\n//động của class ta đang x&acirc;y dựng n&ecirc;n phải c&oacute; c&aacute;c phương thức get,\r\n//set như tr&ecirc;n để giao tiếp với n&oacute;\r\n void tinhtong(phanso);\r\n void tinhtich(phanso);\r\n void tinhhieu(phanso);\r\n void tinhthuong(phanso);\r\n};\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong><em>PHANSO.CPP</em></strong></p>\r\n\r\n<pre class="brush:cpp;">\r\n#include &quot;phanso.h&quot;\r\nphanso::phanso(void) //khởi tạo đối tượng mặ định.\r\n{\r\n //nếu biến trong private l&agrave; kiểu con trỏ th&igrave; \r\n//cấp ph&aacute;t v&ugrave;ng nhớ khởi tạo cho n&oacute; ở đ&acirc;y.\r\n}\r\nphanso::~phanso(void)//kết th&uacute;c nội đối tượng\r\n{\r\n //nếu biến trong private l&agrave; cấp ph&aacute;t động th&igrave; delete n&oacute; ở đ&acirc;y.\r\n}\r\nvoid phanso::nhapphanso()\r\n{\r\n char s[100],a[100];\r\n int i,j,k;\r\n do{\r\n  k=0;\r\n  cout&lt;&lt;&quot;\nnhap vao phan so dang a/b: &quot;;\r\n  fflush(stdin); gets(s);\r\n  //ph&acirc;n số nhập v&agrave;o đảm bảo phải chứa 1 dấu &#39;/&#39; v&agrave; số,\r\n// nếu sai th&igrave; nhập kh&ocirc;ng đ&uacute;ng định dạng y&ecirc;u cầu nhập lại.\r\n  int dem=0,d=0;\r\n  for(i=0;i&lt;strlen(s);i++)\r\n  {\r\n   if((s[i]&gt;=&#39;0&#39; &amp;&amp; s[i]&lt;=&#39;9&#39;)|| s[i]==&#39;/&#39;) dem++;\r\n   if(s[i]==&#39;/&#39;) d++; //đếm số dấu &#39;/&#39;, nếu c&oacute; 2 dấu trở l&ecirc;n th&igrave; nhập sai.\r\n  }\r\n  if(dem!=strlen(s) || d!=1) // c&oacute; nghĩa l&agrave; đ&atilde; xuất hiện\r\n// k&yacute; tự kh&ocirc;ng đ&uacute;ng y&ecirc;u cầu, c&oacute; thể l&agrave; chữ, k&iacute; hiệu đặc biệt,...\r\n  {\r\n   cout&lt;&lt;&quot;\nban da nhap khong dung dinh dang! nhap lai!&quot;;\r\n   k=1; // để lặp lại việc nhập ph&acirc;n số.\r\n  }\r\n }while(k);\r\n\r\n //lấy tử số l&agrave; c&aacute;c chữ số nằm trước dấu &#39;/&#39;.\r\n i=0;\r\n while(s[i]!=&#39;/&#39;)\r\n {\r\n  a[i]=s[i];\r\n  i++;\r\n }\r\n a[i]=&#39;\0&#39;;\r\n tu=atoi(a);\r\n k=0;\r\n for(j=i+1;j&lt;strlen(s);j++) a[k++]=s[j];\r\n a[k]=&#39;\0&#39;;\r\n mau=atoi(a);\r\n}\r\nvoid phanso::xuatphanso()\r\n{\r\n cout&lt;&lt;tu&lt;&lt;&quot;/&quot;&lt;&lt;mau;\r\n}\r\nint phanso::gettu()\r\n{\r\n return tu;\r\n}\r\nint phanso::getmau()\r\n{\r\n return mau;\r\n}\r\nvoid phanso::settu(int x)\r\n{\r\n tu=x;\r\n}\r\n void phanso::setmau(int x)\r\n{\r\n mau=x;\r\n}\r\nint phanso::rutgon()//r&uacute;t gọn phan số\r\n{\r\n //t&igrave;m UCLN rồi lấy tử v&agrave; mẫu chia cho UCLN để r&uacute;t gọn ph&acirc;n số.\r\n int a=abs(tu),b=abs(mau);\r\n while(a!=b)\r\n  if(a&gt;b)a-=b;\r\n  else b-=a;\r\n\r\n tu/=a;\r\n mau/=a;\r\n if(a!=1) return 1; //c&oacute; r&uacute;t gọn\r\n return 0;//kh&ocirc;ng xảy ra r&uacute;t gọn\r\n}\r\nvoid phanso::tinhtong(phanso x)\r\n{\r\n phanso kq;\r\n kq.settu(tu*x.getmau()+mau*x.gettu());// g&aacute;n gi&aacute; trị cho tử của phấn số\r\n// kết quả th&ocirc;ng qua phương thức settu đ&atilde; tạo ở tr&ecirc;n. tương tự cho mẫu.\r\n kq.setmau(mau*x.getmau());\r\n //in ket qua\r\n cout&lt;&lt;&quot;\n&quot;;xuatphanso();cout&lt;&lt;&quot; + &quot;;x.xuatphanso();cout&lt;&lt;&quot; = &quot;;kq.xuatphanso();\r\n //nếu c&oacute; r&uacute;t gọn th&igrave; in kết quả đ&atilde; r&uacute;t gọn ra\r\n if(kq.rutgon()) \r\n {\r\n  cout&lt;&lt;&quot; = &quot;;kq.xuatphanso();\r\n }\r\n cout&lt;&lt;&quot;\n&quot;;\r\n}\r\nvoid phanso::tinhhieu(phanso x)\r\n{\r\n phanso kq;\r\n kq.settu(tu*x.getmau()-mau*x.gettu());\r\n kq.setmau(mau*x.getmau());\r\n //in ket qua\r\n cout&lt;&lt;&quot;\n&quot;;xuatphanso();cout&lt;&lt;&quot; - &quot;;x.xuatphanso();cout&lt;&lt;&quot; = &quot;;kq.xuatphanso();\r\n //nếu c&oacute; r&uacute;t gọn th&igrave; in kết quả đ&atilde; r&uacute;t gọn ra\r\n if(kq.rutgon()) \r\n {\r\n  cout&lt;&lt;&quot; = &quot;;kq.xuatphanso();\r\n }\r\n cout&lt;&lt;&quot;\n&quot;;\r\n}\r\nvoid phanso::tinhtich(phanso x)\r\n{\r\n phanso kq;\r\n kq.settu(tu*x.gettu());\r\n kq.setmau(mau*x.getmau());\r\n //in ket qua\r\n cout&lt;&lt;&quot;\n&quot;;xuatphanso();cout&lt;&lt;&quot; x &quot;;x.xuatphanso();cout&lt;&lt;&quot; = &quot;;kq.xuatphanso();\r\n //nếu c&oacute; r&uacute;t gọn th&igrave; in kết quả đ&atilde; r&uacute;t gọn ra\r\n if(kq.rutgon()) \r\n {\r\n  cout&lt;&lt;&quot; = &quot;;kq.xuatphanso();\r\n }\r\n cout&lt;&lt;&quot;\n&quot;;\r\n}\r\nvoid phanso::tinhthuong(phanso x)\r\n{\r\n phanso kq;\r\n kq.settu(tu*x.getmau());\r\n kq.setmau(mau*x.gettu());\r\n //in ket qua\r\n cout&lt;&lt;&quot;\n&quot;;xuatphanso();cout&lt;&lt;&quot; : &quot;;x.xuatphanso();cout&lt;&lt;&quot; = &quot;;kq.xuatphanso();\r\n //nếu c&oacute; r&uacute;t gọn th&igrave; in kết quả đ&atilde; r&uacute;t gọn ra\r\n if(kq.rutgon()) \r\n {\r\n  cout&lt;&lt;&quot; = &quot;;kq.xuatphanso();\r\n }\r\n cout&lt;&lt;&quot;\n&quot;;\r\n\r\n}</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong><em>SOURCE.CPP</em></strong></p>\r\n\r\n<pre class="brush:cpp;">\r\n#include&quot;phanso.h&quot;\r\nvoid main()\r\n{\r\n phanso x,y;\r\n cout&lt;&lt;&quot;\n	*nhap phan so x*\n&quot;;\r\n x.nhapphanso();\r\n cout&lt;&lt;&quot;\n	*nhap phan so y*\n&quot;;\r\n y.nhapphanso();\r\n int k,kt;\r\n do{\r\n  do{\r\n   kt=0;\r\n   cout&lt;&lt;&quot;\n------------------MENU------------------&quot;;\r\n   cout&lt;&lt;&quot;\n1. tinh TONG 2 phan so x,y.&quot;;\r\n   cout&lt;&lt;&quot;\n2. tinh HIEU 2 phan so x,y.&quot;;\r\n   cout&lt;&lt;&quot;\n3. tinh TICH 2 phan so x,y.&quot;;\r\n   cout&lt;&lt;&quot;\n4. tinh THUONG 2 phan so x,y.&quot;;\r\n   cout&lt;&lt;&quot;\n0.ket thuc chuong trinh.&quot;;\r\n   cout&lt;&lt;&quot;\n-----------------------------------------&quot;;\r\n   cout&lt;&lt;&quot;\n-&gt;lua chon cua ban: &quot;;\r\n   cin&gt;&gt;k;\r\n   //kiểm tra lựa chọn c&oacute; hợp l&yacute; kh&ocirc;ng.\r\n   if(k!=0 &amp;&amp; k!=1 &amp;&amp; k!=2 &amp;&amp; k!=3 &amp;&amp; k!=4)\r\n   {\r\n    cout&lt;&lt;&quot;\nlua chon khong hop le! chon lai!!!\n&quot;;\r\n    kt=1;//để lặp lại việc nhập.\r\n   }\r\n  }while(kt);\r\n  //lựa chọn hợp l&yacute; th&igrave; tiến h&agrave;nh lựa chọn đ&oacute;.\r\n  if(k==1)\r\n  {\r\n   cout&lt;&lt;&quot;\n	*TONG*\n&quot;;\r\n   x.tinhtong(y);//gọi c&aacute;c phương th&uacute;c cần d&ugrave;ng ra.\r\n  }\r\n  if(k==2)\r\n  {\r\n   cout&lt;&lt;&quot;\n	*HIEU*\n&quot;;\r\n   x.tinhhieu(y);\r\n  }\r\n  if(k==3)\r\n  {\r\n   cout&lt;&lt;&quot;\n	*TICH*\n&quot;;\r\n   x.tinhtich(y);\r\n  }\r\n  if(k==4)\r\n  {\r\n   cout&lt;&lt;&quot;\n	*THUONG*\n&quot;;\r\n   x.tinhthuong(y);\r\n  }\r\n }while(k!=0);//dừng chương tr&igrave;nh khi k=0. lựa chọn \r\n//kết th&uacute;c trong menu ở tr&ecirc;n\r\n system(&quot;pause&quot;);\r\n\r\n}</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 3, 1, NULL),
(101, 'các thẻ HTML cơ bản', '<p>HTML gồm c&oacute; 3 phần cở bản: tag, element, property</p>\r\n\r\n<h2><br />\r\n1. Tag</h2>\r\n\r\n<p>thẻ mở &lt;t&ecirc;n thẻ&gt; , thẻ đ&oacute;ng &lt;/ten thẻ&gt;<br />\r\n- thẻ định dạng trang: &lt;body&gt;<br />\r\n- thẻ định dạng văn bản: &lt;font&gt;, &lt;p&gt;, &lt;i&gt;, &lt;u&gt;,...<br />\r\n- thẻ li&ecirc;n kết link: &lt;a&gt;<br />\r\n- thẻ định dạng danh s&aacute;ch: &lt;ul&gt;, &lt;li&gt;, &lt;ol&gt;<br />\r\n- thẻ định dạng h&igrave;nh ảnh: &lt;img&gt;<br />\r\n<br />\r\n<a name="more"></a><br />\r\n&nbsp;</p>\r\n\r\n<h2>2. element</h2>\r\n\r\n<p>c&oacute; thẻ bao gồm thẻ mở, thẻ đ&oacute;ng v&agrave; nội dung b&ecirc;n trong cặp thẻ</p>\r\n\r\n<h2><br />\r\n3. property</h2>\r\n\r\n<p>- mỗi thẻ c&oacute; thể c&oacute; 1 hay nhiều thuộc t&iacute;nh đi k&egrave;m, thuộc t&iacute;nh được nhập ngay trước ngoặc đ&oacute;ng &quot;&gt;&quot; của thẻ mở<br />\r\n- c&aacute;c thuộc t&iacute;nh ph&acirc;n c&aacute;ch nhau bằng khoảng trắng<br />\r\n- gi&aacute; trị của thuộc t&iacute;nh đăt trong dấu nh&aacute;y k&eacute;p hoặc nh&aacute;y đơn hoặc kh&ocirc;ng c&oacute;<br />\r\n- nếu gi&aacute; trị dạng chuỗi th&igrave; bắt buộc d&ugrave;ng nh&aacute;y k&eacute;p hoặc nh&aacute;y đơn để bao lại<br />\r\n<br />\r\n<strong>*một số thuộc t&iacute;nh thẻ &lt;body&gt;</strong><br />\r\n- thiết lập m&agrave;u nền cho trang web: bgcolor=&quot;color&quot;<br />\r\n- ảnh nền trang web: background=&quot;url&quot;<br />\r\n- thiết lập lề tr&aacute;i v&agrave; lề tr&ecirc;n cho trang web: leftmargin=&quot;number&quot; topmargin=&quot;number&quot;<br />\r\n- m&agrave;u chữ: text=&quot;color&quot;<br />\r\n- m&agrave;u sắc cho li&ecirc;n kết: alink=&quot;color&quot; vlink=&quot;color&quot; link=&quot;color&quot;<br />\r\n<br />\r\n<strong>*một số thẻ định dạng văn bản:</strong><br />\r\n- thiết lập font chữ: &lt;font face=&quot;fontname&quot; size=&quot;fontsize&quot; color=&quot;color&quot;&gt;<br />\r\n- định dạng đoạn văn bản: &lt;p align=&quot;?&quot;&gt; ?=&quot;left,right,center&quot;<br />\r\n- chữ in đậm: &lt;b&gt;<br />\r\n- chữ in nghi&ecirc;ng: &lt;i&gt;<br />\r\n- chữ c&oacute; gạch ch&acirc;n: &lt;u&gt;<br />\r\n- gạch ngang chữ: &lt;strike&gt;<br />\r\n- định dạng chỉ số tr&ecirc;n : &lt;sup&gt;<br />\r\n- định dạng chỉ số dưới: &lt;sub&gt;<br />\r\n- c&aacute;c thẻ ti&ecirc;u đề: &lt;h1&gt;, &lt;h2&gt;, &lt;h3&gt;, ..., &lt;h6&gt;<br />\r\n- bỏ qua định dạng html b&ecirc;n trong thẻ n&agrave;y: &lt;pre&gt;<br />\r\n- xuống d&ograve;ng: &lt;br&gt;<br />\r\n<br />\r\n<strong>*thẻ tạo li&ecirc;n kết:</strong><br />\r\n&lt;a href=&quot;url&quot;&gt; ti&ecirc;u đề/nh&atilde;n/h&igrave;nh ảnh &lt;/a&gt;<br />\r\n- nếu trang web qu&aacute; d&agrave;i th&igrave; c&oacute; thể tạo link bookmark để chuyển nhanh đến nội dung cụ thẻ n&agrave;o đ&oacute;, gồm 2 bước<br />\r\n+ tạo bookmark: &lt;a name=&quot;t&ecirc;n bookmark&quot;&gt; ti&ecirc;u đề&lt;/a&gt;<br />\r\n+ link đến bookmark: &lt;a href=&quot;#t&ecirc;n bookmark&quot;&gt; nh&atilde;n của li&ecirc;n kết&lt;/a&gt;<br />\r\n<br />\r\n- href=&quot;url&quot; : x&aacute;c định url cho li&ecirc;n kết<br />\r\n- target=&quot;_blank&quot; target=&quot;_seft&quot; : mở link trong tab mới (_blank) , mở link trong tab hiện tại (_seft)<br />\r\n- name=&quot;location&quot; : c&aacute;i n&agrave;y d&ugrave;ng trong bookmark<br />\r\n- tabindex=&quot;number&quot; : quy định thứ tự tab cho li&ecirc;n kết<br />\r\n- title=&quot;text&quot; : hiển thị chuỗi n&agrave;y l&ecirc;n khi di chuyển chuột l&ecirc;n link đ&oacute;<br />\r\n<br />\r\n<strong>*thẻ tạo danh s&aacute;ch:</strong><br />\r\n&lt;ul type=&quot;circle&quot;&gt;<br />\r\n&lt;li&gt;item 1&lt;/li&gt;<br />\r\n&lt;li&gt;item 2&lt;/li&gt;<br />\r\n&lt;/ul&gt;<br />\r\nthuộc t&iacute;nh type: định nghĩa h&igrave;nh dạng đ&aacute;nh dấu danh s&aacute;ch, c&oacute; c&aacute;c loại như circle , disc , square<br />\r\nta cũng kh&ocirc;ng cần khai b&aacute;o thuộc t&iacute;nh, khi muốn d&ugrave;ng mặc định<br />\r\nkết quả:<br />\r\n<br />\r\n* item 1<br />\r\n* item 2<br />\r\n<br />\r\nc&ograve;n c&aacute;ch thứ 2 như sau:<br />\r\n&lt;ol type=&quot;A&quot;&gt;<br />\r\n&lt;li&gt;item 1&lt;/li&gt;<br />\r\n&lt;li&gt;item 2&lt;/li&gt;<br />\r\n&lt;/ol&gt;<br />\r\n&nbsp;thuộc t&iacute;nh type trong danh s&aacute;ch n&agrave;y gồm c&oacute; c&aacute;c kiểu kh&aacute;c nhau như: A,a,chữ la m&atilde; IN : I, chữ la m&atilde; thường: i, v&agrave; mặc định kh&ocirc;ng khai b&aacute;o type th&igrave; n&oacute; l&agrave; kiểu số đếm 1,2,3,..<br />\r\nkết quả sẽ l&agrave;:<br />\r\n<br />\r\nA. item 1<br />\r\nB. item 2<br />\r\n<br />\r\n<strong>*thẻ h&igrave;nh ảnh v&agrave; c&aacute;c thuộc t&iacute;nh</strong><br />\r\n&lt;img src=&quot;url h&igrave;nh ảnh&quot;/&gt;<br />\r\nv&iacute; dụ : &lt;img src=&quot;images1.jpg&quot;/&gt;<br />\r\n- alt=&quot;text&quot; m&ocirc; tả h&igrave;nh ảnh<br />\r\n- width=&quot;num&quot; height=&quot;num&quot; : định k&iacute;ch thước cho h&igrave;nh ảnh khi hiển thị<br />\r\n- align=&quot;center&quot; : canh lề h&igrave;nh ảnh, c&ograve;n c&oacute; left v&agrave; right<br />\r\n- border=&quot;num&quot; : đường viền quanh h&igrave;nh ảnh<br />\r\n- hspace=&quot;num&quot; : khoảng trống xung quanh ảnh theo ph&iacute;a tr&aacute;i phải<br />\r\n- vspace=&quot;num&quot; : khoảng trống xung quanh ảnh theo hướng tr&ecirc;n dưới, num t&iacute;nh theo pixel</p>\r\n', '/admin/images_cm/html.png', 41, '2015-11-08', 1, 1, NULL),
(102, 'thiết kế bảng trong HTM', '<pre class="brush:xml;">\r\n&lt;table&gt;  \r\n&lt;tbody&gt;  \r\n&lt;tr&gt;  \r\n      &lt;th&gt;column 1&lt;/th&gt;  \r\n      &lt;th&gt;column 2&lt;/th&gt;  \r\n   &lt;/tr&gt;  \r\n&lt;tr&gt;  \r\n      &lt;td&gt;row 1,col 1&lt;/td&gt;  \r\n      &lt;td&gt;row 2,col 2&lt;/td&gt;  \r\n   &lt;/tr&gt;  \r\n&lt;tr&gt;  \r\n      &lt;td&gt;row 2, col 1&lt;/td&gt;  \r\n      &lt;td&gt;row 2, col 2&lt;/td&gt;  \r\n   &lt;/tr&gt;  \r\n&lt;/tbody&gt;&lt;/table&gt;  \r\n</pre>\r\n\r\n<p>kết quả sẽ như h&igrave;nh dưới<br />\r\n<a name="more"></a></p>\r\n\r\n<p><a href="http://2.bp.blogspot.com/-ETa5vDTQln4/VhPnTOtyEiI/AAAAAAAAAKg/cCSQ0IQt86E/s1600/Screenshot%2B%252820%2529.png"><img src="http://2.bp.blogspot.com/-ETa5vDTQln4/VhPnTOtyEiI/AAAAAAAAAKg/cCSQ0IQt86E/s320/Screenshot%2B%252820%2529.png" style="height:179px; width:320px" /></a></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&yacute; nghĩa của c&aacute;c thẻ mo tả trong h&igrave;nh dưới đ&acirc;y</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><a href="http://4.bp.blogspot.com/-Mj_ZEBIAtY8/VhPnj7Ya3SI/AAAAAAAAAKo/mfB7i2eRdIQ/s1600/Screenshot%2B%252819%2529.png"><img src="http://4.bp.blogspot.com/-Mj_ZEBIAtY8/VhPnj7Ya3SI/AAAAAAAAAKo/mfB7i2eRdIQ/s320/Screenshot%2B%252819%2529.png" style="height:179px; width:320px" /></a></p>\r\n\r\n<h2>c&aacute;c thuộc t&iacute;nh của thẻ table</h2>\r\n\r\n<p>- đặt m&agrave;u nền: bgcolor=&quot;color&quot;</p>\r\n\r\n<p>- đặt h&igrave;nh nền: background=&quot;url&quot;</p>\r\n\r\n<p>- độ d&agrave;y của đường viền: border=&quot;number&quot;</p>\r\n\r\n<p>- m&agrave;u đường viền: bordercolor=&quot;color&quot;</p>\r\n\r\n<p>- khoảng c&aacute;ch giữa nội dung v&agrave; đường viền: cellpadding=&quot;number&quot;</p>\r\n\r\n<p>- khoảng c&aacute;ch giữa c&aacute;c &ocirc;: cellspacing=&quot;number&quot;</p>\r\n\r\n<p>- k&iacute;ch thước chiều ngang v&agrave; chiều cao: width=&quot;number&quot; height=&quot;number&quot;</p>\r\n\r\n<p>- canh lề theo phướng ngang: align=&quot;center | justify | left | right&quot;</p>\r\n\r\n<p>- canh lề theo phương thẳng đứng: valign=&quot;bottom | middle | top&quot;</p>\r\n\r\n<p>- gộp nhiều row, nhiều col th&agrave;nh 1: rowspan=&quot;number&quot; colspan=&quot;number&quot;</p>\r\n\r\n<p><a href="http://3.bp.blogspot.com/-WgUKUjgA6jU/VhPqz-4wm8I/AAAAAAAAAK0/DTju2HnP1D4/s1600/Screenshot%2B%252821%2529.png"><img src="http://3.bp.blogspot.com/-WgUKUjgA6jU/VhPqz-4wm8I/AAAAAAAAAK0/DTju2HnP1D4/s640/Screenshot%2B%252821%2529.png" style="height:358px; width:640px" /></a></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<h2>d&ugrave;ng table để định dạng layout cho web&nbsp;</h2>\r\n\r\n<p><a href="http://4.bp.blogspot.com/-UWnTrC2VYxk/VhPrFBaxvRI/AAAAAAAAAK8/V9MPuT9F9pM/s1600/Screenshot%2B%252822%2529.png"><img src="http://4.bp.blogspot.com/-UWnTrC2VYxk/VhPrFBaxvRI/AAAAAAAAAK8/V9MPuT9F9pM/s640/Screenshot%2B%252822%2529.png" style="height:358px; width:640px" /></a></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><a href="http://3.bp.blogspot.com/-TS4XoPeILb8/VhPrdkfNpzI/AAAAAAAAALE/SvR9BitwXrY/s1600/Screenshot%2B%252823%2529.png"><img src="http://3.bp.blogspot.com/-TS4XoPeILb8/VhPrdkfNpzI/AAAAAAAAALE/SvR9BitwXrY/s640/Screenshot%2B%252823%2529.png" style="height:358px; width:640px" /></a></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><a href="http://2.bp.blogspot.com/-x7DsYEGGK_I/VhPrwgJLodI/AAAAAAAAALM/dkeuaBFo62I/s1600/Screenshot%2B%252824%2529.png"><img src="http://2.bp.blogspot.com/-x7DsYEGGK_I/VhPrwgJLodI/AAAAAAAAALM/dkeuaBFo62I/s640/Screenshot%2B%252824%2529.png" style="height:358px; width:640px" /></a></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/html.png', 41, '2015-11-08', 3, 1, NULL),
(103, 'tạo FORM trong HTML', '<p>&nbsp;</p>\r\n\r\n<p>- form d&ugrave;ng để nhận th&ocirc;ng tin từ người sử dụng hay phản hồi th&ocirc;ng tin về người d&ugrave;ng<br />\r\n- người d&ugrave;ng c&oacute; thể c&oacute; c&aacute;c y&ecirc;u cầu sau:<br />\r\n+ nhập v&agrave;o c&acirc;u trả lời, &yacute; kiến<br />\r\n+ chọn c&acirc;u trả lời từ danh s&aacute;ch<br />\r\n+ c&acirc;u trả lời từ 1 hay 1 số t&ugrave;y chọn<br />\r\n<br />\r\n- dữ liệu c&oacute; thể xử l&yacute; tại client hoặc xử l&yacute; tại server sau đ&oacute; kết quả trả về cho người d&ugrave;ng<br />\r\n- sử dụng tag &lt;form&gt; để tạo form<br />\r\n<br />\r\n<a name="more"></a><br />\r\n<br />\r\n*&nbsp;<strong>một số thuộc t&iacute;nh của tag FORM</strong><br />\r\n- action=&quot;url&quot; : địa chỉ web xử l&yacute; dữ liệu được nhập từ form<br />\r\n- method=&quot;get | post&quot; : phương thức gởi dữ liệu, mặc định &agrave; phương thức get<br />\r\n- name=&quot;t&ecirc;n form&quot;<br />\r\n- target=&quot;_blank | _self&quot; : cửa sổ hiển thị kết quả l&agrave; của sổ mới hay cửa sổ hiện tại<br />\r\n- type=&quot; text | password | submit | file | radio | checkbox&quot; : kiểu nhập liệu<br />\r\nngo&agrave;i ra c&ograve;n 1 số thuộc t&iacute;nh kh&aacute;c, để hiểu r&otilde; hơn về chức năng của c&aacute;c thuộc t&iacute;nh, xem qua c&aacute;c v&iacute; dụ<br />\r\n&nbsp;</p>\r\n\r\n<p><a href="http://3.bp.blogspot.com/-J7j4sFRoZzo/VhPxkrktLyI/AAAAAAAAALc/o-M2KhT41v0/s1600/Screenshot%2B%252825%2529.png"><img src="http://3.bp.blogspot.com/-J7j4sFRoZzo/VhPxkrktLyI/AAAAAAAAALc/o-M2KhT41v0/s640/Screenshot%2B%252825%2529.png" style="height:359px; width:640px" /></a></p>\r\n\r\n<p><a href="http://3.bp.blogspot.com/-yRY6E_PVNHY/VhPxvsMcwyI/AAAAAAAAALk/MfdjWrHbtRA/s1600/Screenshot%2B%252826%2529.png"><img src="http://3.bp.blogspot.com/-yRY6E_PVNHY/VhPxvsMcwyI/AAAAAAAAALk/MfdjWrHbtRA/s640/Screenshot%2B%252826%2529.png" style="height:358px; width:640px" /></a></p>\r\n\r\n<p><a href="http://1.bp.blogspot.com/-QpijSJA_BK4/VhPx09WUBXI/AAAAAAAAALs/_OJVRTzP_KQ/s1600/Screenshot%2B%252827%2529.png"><img src="http://1.bp.blogspot.com/-QpijSJA_BK4/VhPx09WUBXI/AAAAAAAAALs/_OJVRTzP_KQ/s640/Screenshot%2B%252827%2529.png" style="height:358px; width:640px" /></a></p>\r\n\r\n<p><a href="http://1.bp.blogspot.com/-HB-zgCoMW3s/VhPx5WWlO1I/AAAAAAAAAL0/bkKdzqPQM1c/s1600/Screenshot%2B%252828%2529.png"><img src="http://1.bp.blogspot.com/-HB-zgCoMW3s/VhPx5WWlO1I/AAAAAAAAAL0/bkKdzqPQM1c/s640/Screenshot%2B%252828%2529.png" style="height:358px; width:640px" /></a></p>\r\n', '/admin/images_cm/html.png', 41, '2015-11-08', 1, 1, NULL),
(104, 'tại sao nên sử dụng XHTML thay cho HTML?', '<p>- v&igrave; XHTML l&agrave; sự kết hợp giữa HTML v&agrave; XML do đ&oacute; t&agrave;i liệu XHTML ch&iacute;nh l&agrave; t&agrave;i liệu HTML nhưng được bổ sung th&ecirc;m sự chắc chẽ trong c&uacute; ph&aacute;p của XML, đảm bảo cấu tr&uacute;c của trang web lu&ocirc;n thỏa điều kiện well-formed<br />\r\n- tr&igrave;nh duyệt hiển thị XHTML nhanh hơn HTML v&igrave; kh&ocirc;ng mất thời gian kiểm tra v&agrave; sữa lỗi well-formed.<br />\r\n<a name="more"></a><br />\r\n<br />\r\n* v&agrave; well-formed l&agrave; g&igrave;? c&oacute; c&aacute;c quy định như thế n&agrave;o?<br />\r\n- đối với c&aacute;c phần tử c&oacute; chưa nội dung phải đầy đủ thẻ mở v&agrave; thẻ đ&oacute;ng<br />\r\n- c&aacute;c phần tử rỗng th&igrave; phải c&oacute; k&yacute; tự kết th&uacute;c &quot;/&quot;<br />\r\n- c&aacute;c thẻ chồng nhau phải đ&uacute;ng trật tự, kh&ocirc;ng chồng lấp l&ecirc;n nhau: v&iacute; dụ lồng gh&eacute;p như sau l&agrave; đ&uacute;ng trật tự: &lt;b&gt;&lt;i&gt; text&lt;/i&gt;&lt;/b&gt;<br />\r\n- c&aacute;c thẻ v&agrave; thuộc t&iacute;nh viết bằng chữ thường<br />\r\n- gi&aacute; trị c&aacute;c thuộc t&iacute;nh của tag phải đặt trong dấu nh&aacute;y k&eacute;p<br />\r\n- thuộc t&iacute;nh name được thay thế bằng id<br />\r\n- cấu tr&uacute;c tối thiểu của tập tin HTML</p>\r\n\r\n<p><a href="http://1.bp.blogspot.com/-Q9EHmyge0Y8/VhP1CovTDGI/AAAAAAAAAMA/mG4m0naXu9c/s1600/Screenshot%2B%252829%2529.png"><img src="http://1.bp.blogspot.com/-Q9EHmyge0Y8/VhP1CovTDGI/AAAAAAAAAMA/mG4m0naXu9c/s640/Screenshot%2B%252829%2529.png" style="height:358px; width:640px" /></a></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/html.png', 41, '2015-11-08', 25, 1, NULL),
(105, 'thuật toán sắp xếp radix sort', '<p>Radix Sort l&agrave; một thuật to&aacute;n tiếp cận theo một hướng ho&agrave;n to&agrave;n kh&aacute;c.<br />\r\nNếu như trong c&aacute;c thuật to&aacute;n kh&aacute;c, cơ sở để sắp xếp lu&ocirc;n l&agrave; việc so s&aacute;nh gi&aacute; trị của 2 phần tử th&igrave; Radix Sort lại dựa tr&ecirc;n nguy&ecirc;n tắc ph&acirc;n loại thư của bưu điện. V&igrave; l&yacute; do đ&oacute; Radix Sort c&ograve;n c&oacute; t&ecirc;n l&agrave; Postman&rsquo;s Sort.<br />\r\nRadix Sort kh&ocirc;ng hề quan t&acirc;m đến việc so s&aacute;nh gi&aacute; trị của phần tử m&agrave; bản th&acirc;n việc ph&acirc;n loại v&agrave; tr&igrave;nh tự ph&acirc;n loại sẽ tạo ra thứ tự cho c&aacute;c phần tử.<br />\r\nM&ocirc; phỏng lại qui tr&igrave;nh tr&ecirc;n, để sắp xếp d&atilde;y a1, a2, ..., an, giải thuật Radix Sort thực hiện như sau:<br />\r\nTrước ti&ecirc;n, ta c&oacute; thể giả sử mỗi phần tử ai trong d&atilde;y a1, a2, ..., an l&agrave; một số nguy&ecirc;n c&oacute; tối đa m chữ số.<br />\r\n<a name="more"></a><br />\r\nTa ph&acirc;n loại c&aacute;c phần tử lần lượt theo c&aacute;c chữ số h&agrave;ng đơn vị, h&agrave;ng chục, h&agrave;ng trăm, &hellip; tương tự việc ph&acirc;n loại thư theo tỉnh th&agrave;nh, quận huyện, phường x&atilde;, &hellip;.<br />\r\n<br />\r\nBước 1 :// k cho biết chữ số d&ugrave;ng để ph&acirc;n loại hiện h&agrave;nh<br />\r\nk = 0; // k = 0: h&agrave;ng đơn vị; k = 1: h&agrave;ng chục; &hellip;<br />\r\nBước 2 : //Tạo c&aacute;c l&ocirc; chứa c&aacute;c loại phần tử kh&aacute;c nhau<br />\r\nKhởi tạo 10 l&ocirc; B0, B1, &hellip;, B9 rỗng;<br />\r\nBước 3 :<br />\r\nFor i = 1 .. n do<br />\r\nĐặt ai v&agrave;o l&ocirc; Bt với t: chữ số thứ k của ai;<br />\r\nBước 4 :<br />\r\nNối B0, B1, &hellip;, B9 lại (theo đ&uacute;ng tr&igrave;nh tự) th&agrave;nh a.<br />\r\nBước 5 :<br />\r\nk = k+1;Nếu k &lt; m th&igrave; trở lại bước 2. Ngược lại: Dừng</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(106, 'thuật toán merge sort - sắp xếp trộn', '<p>Giải thuật Merge sort sắp xếp d&atilde;y a1, a2, ..., an dựa tr&ecirc;n nhận x&eacute;t sau:<br />\r\nMỗi d&atilde;y a1, a2, ..., an bất kỳ l&agrave; một tập hợp c&aacute;c d&atilde;y con li&ecirc;n tiếp m&agrave; mỗi d&atilde;y con đều đ&atilde; c&oacute; thứ tự.<br />\r\nV&iacute; dụ: d&atilde;y 12, 2, 8, 5, 1, 6, 4, 15 c&oacute; thể coi như gồm 5 d&atilde;y con kh&ocirc;ng giảm (12); (2, 8); (5); (1, 6); (4, 15).<br />\r\nD&atilde;y đ&atilde; c&oacute; thứ tự coi như c&oacute; 1 d&atilde;y con.<br />\r\nHướng tiếp cận: t&igrave;m c&aacute;ch l&agrave;m giảm số d&atilde;y con kh&ocirc;ng giảm của d&atilde;y ban đầu.<br />\r\nBước 1 : // Chuẩn bị<br />\r\nk = 1; // k l&agrave; chiều d&agrave;i của d&atilde;y con trong bước hiện h&agrave;nh<br />\r\nBước 2 :<br />\r\nT&aacute;ch d&atilde;y a0, a1, ., an-1 th&agrave;nh 2 d&atilde;y b, c theo nguy&ecirc;n tắc lu&acirc;n phi&ecirc;n từng nh&oacute;m k phần tử:<br />\r\nb = a0, ., ak, a2k, ., a3k, .<br />\r\nc = ak+1, ., a2k+1, a3k+1, .<br />\r\nBước 3 :<br />\r\n<a name="more"></a><br />\r\nTrộn từng cặp d&atilde;y con gồm k phần tử của 2 d&atilde;y b, c v&agrave;o a.<br />\r\nBước 4 :<br />\r\nk = k*2;<br />\r\nNếu k &lt; n th&igrave; trở lại bước 2.<br />\r\nNgược lại: Dừng<br />\r\nDữ liệu hỗ trợ: 2 mảng b, c:<br />\r\nint &nbsp;&nbsp;b[MAX], c[MAX], nb, nc;<br />\r\nC&aacute;c h&agrave;m cần c&agrave;i đặt:<br />\r\nvoid MergeSort(int a[], int N); : Sắp xếp mảng (a, N) tăng dần<br />\r\nvoid Distribute(int a[], int N, int &amp;nb, int &amp;nc, int k); Ph&acirc;n phối đều lu&acirc;n phi&ecirc;n c&aacute;c d&atilde;y con độ d&agrave;i k từ mảng a v&agrave;o hai mảng con b v&agrave; c<br />\r\nvoid Merge(int a[], int nb, int nc, int k); : Trộn mảng b v&agrave; mảng c v&agrave;o mảng a<br />\r\nvoid MergeSubarr(int a[], int nb, int nc, int &amp;pa, int &amp;pb, int &amp;pc, int k); : Trộn một cặp d&atilde;y con từ b v&agrave; c v&agrave;o a<br />\r\n&nbsp;</p>\r\n\r\n<pre class="brush:cpp;">\r\nint b[MAX], c[MAX], nb, nc;\r\n\r\nvoid MergeSort(int a[], int N)\r\n{  \r\n int k;\r\n for (k = 1; k &lt; N; k *= 2) \r\n {\r\n  Distribute(a, N, nb, nc, k);\r\n  Merge(a, nb, nc, k);\r\n }\r\n}\r\nvoid Distribute(int a[], int N, int &amp;nb, int &amp;nc, int k)\r\n{  \r\n int  i, pa, pb, pc;\r\n pa = pb = pc = 0;\r\n while (pa &lt; N)\r\n {\r\n  for (i=0; (pa&lt;N) &amp;&amp; (i&lt;k); i++, pa++, pb++)\r\n   b[pb] = a[pa];\r\n  for (i=0; (pa&lt;N) &amp;&amp; (i&lt;k); i++, pa++, pc++)\r\n   c[pc] = a[pa];\r\n }\r\n nb = pb; nc = pc;\r\n}\r\nvoid Merge(int a[],int nb, int nc,int k)\r\n{  int p, pb, pc, ib, ic, kb, kc;\r\n p=pb=pc=0; ib=ic=0;\r\n while((nb&gt;0)&amp;&amp;(nc&gt;0))\r\n { kb=min(k,nb); kc=min(k,nc);\r\n  if(b[pb+ib]&lt;=c[pc+ic])\r\n  { a[p++]=b[pb+ib]; ib++;\r\n   if(ib==kb)\r\n   {  for(;ic&lt;kc;ic++ a[p++]=c[pc+ic];\r\n    pb+=kb; pc+=kc; ib = ic=0;\r\n    nb-=kb; nc-=kc;\r\n   }\r\n  }  \r\n  else\r\n  { a[p++]=c[pc+ic]; ic++;\r\n   if(ic==kc)\r\n   {  \r\n    for(;ib&lt;kb;ib++) a[p++]=b[pb+ib];\r\n    pb+=kb;  pc+=kc; ib = ic=0;\r\n    nb-=kb; nc-=kc;\r\n   }\r\n  }\r\n }\r\n}\r\nint min(int a,int b)\r\n{\r\n if(a&gt;b) return b;\r\n else return a;\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 1, 1, NULL),
(107, 'thuật toán quick sort - sắp xếp nhanh', '<h2>Giải thuật QuickSort sắp xếp d&atilde;y a1, a2 ..., aN dựa tr&ecirc;n việc ph&acirc;n hoạch d&atilde;y ban đầu th&agrave;nh 3 phần :</h2>\r\n\r\n<p>Phần 1: Gồm c&aacute;c phần tử &nbsp;c&oacute; gi&aacute; trị b&eacute; hơn x<br />\r\nPhần 2: Gồm c&aacute;c phần tử &nbsp;c&oacute; gi&aacute; trị bằng &nbsp;x<br />\r\nPhần 3: Gồm c&aacute;c phần tử &nbsp;c&oacute; gi&aacute; trị lớn hơn x<br />\r\nvới x l&agrave; gi&aacute; trị của một phần tử &nbsp;t&ugrave;y &yacute; trong d&atilde;y ban đầu.<br />\r\nSau khi thực hiện ph&acirc;n hoạch, d&atilde;y ban đầu được ph&acirc;n th&agrave;nh 3 đoạn:<br />\r\n1. ak &nbsp;&le; x , với k = 1 .. j<br />\r\n2. ak &nbsp;= x , với k = &nbsp;j+1 .. i-1<br />\r\n3. ak &nbsp; x , với k = &nbsp;i..N<br />\r\n<br />\r\n<a name="more"></a><br />\r\n<br />\r\nĐoạn thứ 2 đ&atilde; c&oacute; thứ tự.<br />\r\nNếu c&aacute;c đoạn 1 v&agrave; 3 chỉ c&oacute; 1 phần tử &nbsp;: đ&atilde; c&oacute; thứ tự<br />\r\n khi đ&oacute; d&atilde;y con ban đầu đ&atilde; được sắp.<br />\r\nĐoạn thứ 2 đ&atilde; c&oacute; thứ tự.<br />\r\nNếu c&aacute;c đoạn 1 v&agrave; 3 &nbsp;c&oacute; nhiều hơn 1 phần tử &nbsp;th&igrave; d&atilde;y ban đầu chỉ c&oacute; thứ tự khi c&aacute;c đoạn 1, 3 được sắp.<br />\r\nĐể sắp xếp c&aacute;c đoạn 1 v&agrave; 3, ta lần lượt tiến h&agrave;nh việc ph&acirc;n hoạch từng d&atilde;y con theo c&ugrave;ng phương ph&aacute;p ph&acirc;n hoạch d&atilde;y ban đầu vừa tr&igrave;nh b&agrave;y &hellip;<br />\r\nBước 1: Nếu left &ge; right //d&atilde;y c&oacute; &iacute;t hơn 2 phần tử<br />\r\nKết th&uacute;c; //d&atilde;y đ&atilde; được sắp xếp<br />\r\nBước 2: Ph&acirc;n hoạch d&atilde;y aleft &hellip; aright th&agrave;nh c&aacute;c đoạn: aleft.. aj, aj+1.. ai-1, ai.. aright<br />\r\nĐoạn 1  x&nbsp;<br />\r\nĐoạn 2: aj+1.. ai-1 &nbsp;= x&nbsp;<br />\r\nĐoạn 3: ai.. aright &nbsp; x<br />\r\nBước 3: Sắp xếp đoạn 1: aleft.. aj<br />\r\nBước 4: Sắp xếp đoạn 3: ai.. aright<br />\r\n<br />\r\n<br />\r\nBước 1 : Chọn t&ugrave;y &yacute; một phần tử &nbsp;a[k] trong d&atilde;y l&agrave;&nbsp; gi&aacute; trị mốc ( l &le; k &le; r): &nbsp;&nbsp;<br />\r\nx = a[k]; &nbsp; i = l; &nbsp;j = r;<br />\r\nBước 2 : Ph&aacute;t hiện v&agrave; hiệu chỉnh cặp phần tử&nbsp;<br />\r\na[i], a[j] nằm sai chỗ :<br />\r\nBước 2a : Trong khi (a[i]&lt;x) i++;<br />\r\nBước 2b : Trong khi (a[j]&gt;x) j--;<br />\r\nBước 2c : Nếu &nbsp;i&lt; j Swap(a[i],a[j]);<br />\r\nBước 3 : Nếu &nbsp;i &lt; j: Lặp lại Bước 2. &nbsp;&nbsp; Ngược lại: Dừng</p>\r\n\r\n<pre class="brush:cpp;">\r\nvoid QuickSort(int a[], int left, int right)\r\n{ int i, j, x;\r\n x = a[(left+right)/2]; \r\n i = left; j = right;\r\n   do\r\n {\r\n       while(a[i] &lt; x) i++;\r\n       while(a[j] &gt; x) j--;\r\n       if(i &lt;= j)\r\n  { \r\n   Swap(a[i],a[j]);\r\n         i++ ; j--;\r\n   }\r\n } while(i &lt;= j);\r\n\r\n if(left&lt;j)\r\n  QuickSort(a, left, j);\r\n if(i&lt;right)\r\n  QuickSort(a, i, right);\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(108, 'thuật toán heap sort - sắp xếp vun đống', '<p>Heap Sort tận dụng được c&aacute;c ph&eacute;p so s&aacute;nh ở bước i-1 m&agrave; thuật to&aacute;n sắp xếp chọn trực tiếp kh&ocirc;ng tận dụng được<br />\r\nĐể l&agrave;m được điều n&agrave;y Heap sort thao t&aacute;c dựa tr&ecirc;n c&acirc;y.<br />\r\nỞ c&acirc;y tr&ecirc;n, phần tử ở mức i ch&iacute;nh l&agrave; phần tử lớn trong cặp phần tử ở mức i +1, do đ&oacute; phần tử ở n&uacute;t gốc l&agrave; phần tử lớn nhất.<br />\r\nNếu loại bỏ gốc ra khỏi c&acirc;y, th&igrave; việc cập &nbsp;nhật c&acirc;y chỉ xảy ra tr&ecirc;n những nh&aacute;nh li&ecirc;n quan đến phần tử mới loại bỏ, c&ograve;n c&aacute;c nh&aacute;nh kh&aacute;c th&igrave; bảo to&agrave;n.<br />\r\nBước kế tiếp c&oacute; thể sử dụng lại kết quả so s&aacute;nh của bước hiện tại.<br />\r\nV&igrave; thế độ phức tạp của thuật to&aacute;n O(nlog2n)<br />\r\n<a name="more"></a><br />\r\nGiai đoạn 1 : Hiệu chỉnh d&atilde;y số ban đầu th&agrave;nh heap<br />\r\nGiai đoạn 2: &nbsp;Sắp xếp d&atilde;y số dựa tr&ecirc;n heap:<br />\r\nBước 1:Đưa phần tử &nbsp;lớn &nbsp;nhất về vị tr&iacute; đ&uacute;ng ở cuối d&atilde;y: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r = n-1; &nbsp;Swap (a1 , ar );<br />\r\nBước 2: Loại bỏ phần tử lớn nhất ra khỏi heap: r = r-1; &nbsp; &nbsp; &nbsp; &nbsp;Hiệu chỉnh phần c&ograve;n lại của d&atilde;y từ &nbsp;a1 , a2 ... ar th&agrave;nh một heap.<br />\r\nBước 3:<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp;Nếu r&gt;1 (heap c&ograve;n phần tử ): Lặp lại Bước 2 &nbsp; Ngược lại : Dừng<br />\r\nHeap: L&agrave; một d&atilde;y c&aacute;c phần tử &nbsp;al, al+1 ,... , ar &nbsp;thoả c&aacute;c quan hệ với mọi i  [l, r]:<br />\r\nai  a2i+1<br />\r\nai  a2i+2 // (ai , a2i+1), (ai , a2i+2 ) l&agrave; c&aacute;c cặp phần tử li&ecirc;n đới<br />\r\nCho d&atilde;y số &nbsp;: 12 &nbsp; 2 &nbsp; 8 &nbsp; 5 &nbsp;1 &nbsp; 6 &nbsp; 4 &nbsp;15<br />\r\nGiai đoạn 1: Hiệu chỉnh d&atilde;y ban đầu th&agrave;nh Heap<br />\r\nGiai đoạn 2: Sắp xếp d&atilde;y số dựa tr&ecirc;n Heap</p>\r\n\r\n<pre class="brush:cpp;">\r\nvoid shift(int a[],int l,int r)\r\n{\r\n int x,i,j;\r\n i=l;\r\n j=2*i+1;\r\n x=a[i];\r\n while(j&lt;=r)\r\n {  if(j&lt;r)\r\n   if(a[j]&lt;a[j+1]) //tim phan tu lon nhat a[j] va a[j+1]\r\n  \r\n  j++; //luu chi so cua phan tu nho nhat trong hai phan tu \r\n  if(a[j]&lt;=x) return;\r\n  else\r\n  { a[i]=a[j];\r\n   a[j]=x;\r\n   i=j;\r\n   j=2*i+1;\r\n   x=a[i];\r\n   }\r\n}\r\n}\r\nvoid CreateHeap(int a[],int n)\r\n {  int l;\r\n   l=n/2-1;\r\n   while(l&gt;=0)\r\n   {\r\n   shift(a,l,n-1);\r\n   l=l-1;\r\n   }\r\n }\r\nvoid HeapSort(int a[],int n)\r\n { int r;\r\n  CreateHeap(a,n);\r\n  r=n-1;\r\n  while(r&gt;0)\r\n  {\r\n   Swap(a[0],a[r]);//a[0] la n&uacute;t gốc\r\n   r--;\r\n   if(r&gt;0)\r\n    shift(a,0,r);\r\n }\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(109, 'thuật toán shell sort - cải tiến của chèn trực tiếp', '<p>shell sort l&agrave; Cải tiến của phương ph&aacute;p ch&egrave;n trực tiếp<br />\r\n&Yacute; tưởng:<br />\r\nPh&acirc;n hoạch d&atilde;y th&agrave;nh c&aacute;c d&atilde;y con<br />\r\nSắp xếp c&aacute;c d&atilde;y con theo phương ph&aacute;p ch&egrave;n trực tiếp<br />\r\nD&ugrave;ng phương ph&aacute;p ch&egrave;n trực tiếp sắp xếp lại cả d&atilde;y.<br />\r\nPh&acirc;n chia d&atilde;y ban đầu th&agrave;nh những d&atilde;y con gồm c&aacute;c phần tử &nbsp;ở c&aacute;ch nhau h vị tr&iacute;<br />\r\nD&atilde;y ban đầu : a1, a2, ..., an được xem như sự xen kẽ của c&aacute;c d&atilde;y con sau :<br />\r\nD&atilde;y con thứ nhất : a1 ah+1 a2h+1 ...<br />\r\nD&atilde;y con thứ &nbsp;hai &nbsp;: a2 ah+2 a2h+2 ...<br />\r\n....<br />\r\n<a name="more"></a><br />\r\nD&atilde;y con thứ &nbsp;h &nbsp; &nbsp; : ah a2h a3h ...<br />\r\nTiến h&agrave;nh sắp xếp c&aacute;c phần tử trong c&ugrave;ng d&atilde;y con sẽ l&agrave;m cho c&aacute;c phần tử &nbsp;được đưa về vị tr&iacute; đ&uacute;ng tương đối<br />\r\nGiảm khoảng c&aacute;ch h để tạo th&agrave;nh c&aacute;c d&atilde;y con mới<br />\r\nDừng khi h=1<br />\r\nGiả sử quyết định sắp xếp k bước, c&aacute;c khoảng c&aacute;ch &nbsp;chọn phải thỏa điều kiện :<br />\r\nhi &nbsp;&gt; hi+1 &nbsp;v&agrave; hk = 1<br />\r\n&nbsp;hi &nbsp;= (hi-1 &nbsp;- 1)/3 v&agrave; hk = 1, k = log3n-1<br />\r\nV&iacute; dụ :127, 40, 13, 4, 1<br />\r\n&nbsp;hi &nbsp;= (hi-1 - 1)/2 v&agrave; hk = 1, k = log2n-1<br />\r\nV&iacute; dụ : 15, 7, 3, 1<br />\r\nh c&oacute; dạng 3i+1: 364, 121, 40, 13, 4, 1<br />\r\nD&atilde;y fibonaci: 34, 21, 13, 8, 5, 3, 2, 1<br />\r\nh l&agrave; d&atilde;y c&aacute;c số nguy&ecirc;n tố giảm dần đến 1: 13, 11, 7, 5, 3, 1.<br />\r\nBước 1: Chọn k khoảng c&aacute;ch h[1], h[2], ..., h[k];<br />\r\ni = 1;<br />\r\nBước 2: Ph&acirc;n chia d&atilde;y ban đầu th&agrave;nh c&aacute;c d&atilde;y con &nbsp; c&aacute;ch nhau h[i] khoảng c&aacute;ch.<br />\r\nSắp xếp từng d&atilde;y con bằng phương ph&aacute;p &nbsp; ch&egrave;n trực tiếp;<br />\r\nBước 3 : i = i+1; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;Nếu &nbsp;i &gt; k : Dừng &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;Ngược lại : Lặp lại Bước 2. &nbsp; &nbsp;&nbsp;<br />\r\nCho d&atilde;y số a:<br />\r\n12 &nbsp;&nbsp; 2 8 5 1 6 4 15<br />\r\n<br />\r\nGiả sử chọn c&aacute;c khoảng c&aacute;ch l&agrave; 5, 3, 1<br />\r\n&nbsp;</p>\r\n\r\n<pre class="brush:cpp;">\r\nvoid ShellSort(int a[],int n, int h[], int k)\r\n{ int step,i,j, x,len;\r\n for (step = 0 ; step &lt;k; step++)\r\n { len = h[step];\r\n  for (i = len; i&lt;n; i++)\r\n  { \r\n   x = a[i]; \r\n   j = i-len; // a[j] đứng kề trước a[i] trong c&ugrave;ng d&atilde;y con \r\n   while ((x&lt;a[j])&amp;&amp;(j&gt;=0)// sắp xếp d&atilde;y con chứa  x \r\n   {  // bằng phương ph&aacute;p ch&egrave;n trực tiếp \r\n    a[j+len]  = a[j];\r\n    j = j - len;\r\n   }\r\n   a[j+len] = x;\r\n  }\r\n }\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(110, 'thuật toán binary insertion sort - chèn nhị phân', '<pre class="brush:cpp;">\r\nvoid  BInsertionSort(int a[],int n )\r\n  { \r\n  int l,r,m,i;  \r\n  int x;//lưu gi&aacute; trị a[i] tr&aacute;nh bị ghi đ&egrave; khi dời chỗ c&aacute;c phần tử.  \r\n  for(int i=1 ; i&lt;n ; i++) \r\n  { \r\n   x = a[i]; l = 0;\r\n   r = i-1;  \r\n   while(l&lt;=r) // t&igrave;m vị tr&iacute; ch&egrave;n x \r\n   { \r\n    m = (l+r)/2;\r\n    // t&igrave;m vị tr&iacute; th&iacute;ch hợp m   \r\n    if(x &lt; a[m]) r = m-1;  \r\n    else l = m+1;   \r\n   }   \r\n   for(int j = i-1 ; j &gt;=l ; j--)   \r\n    a[j+1] = a[j];// dời c&aacute;c phần tử sẽ đứng sau x  \r\n   a[l] = x;  // ch&egrave;n x v&agrave;o d&atilde;y  }\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(111, 'thuật toán selection sort', '<pre class="brush:cpp;">\r\n/*thuật to&aacute;n selection sort\r\n&Yacute; tưởng:\r\nChọn phần tử nhỏ nhất trong N phần tử trong d&atilde;y hiện h&agrave;nh ban đầu.\r\nĐưa phần tử n&agrave;y về vị tr&iacute; đầu d&atilde;y hiện h&agrave;nh\r\nXem d&atilde;y hiện h&agrave;nh chỉ c&ograve;n N-1 phần tử của d&atilde;y hiện h&agrave;nh ban đầu\r\nBắt đầu từ vị tr&iacute; thứ 2;\r\nLặp lại qu&aacute; tr&igrave;nh tr&ecirc;n cho d&atilde;y hiện h&agrave;nh... đến khi d&atilde;y hiện h&agrave;nh chỉ c&ograve;n 1 phần tử\r\nBước 1:   i = 0;\r\nBước 2:  T&igrave;m phần tử a[min] nhỏ nhất trong      d&atilde;y hiện h&agrave;nh từ a[i] đến a[N]\r\nBước 3 :  Đổi chỗ a[min] v&agrave; a[i]\r\nBước 4 :  Nếu  i &lt; N-1 th&igrave;\r\ni = i+1; Lặp lại Bước 2;                Ngược lại: Dừng.\r\n\r\n*/\r\n#include&lt;iostream&gt;\r\nusing namespace std;\r\nvoid xep(int a[], int n)\r\n{\r\n int i, j, m,t;\r\n for (i = 0; i &lt; n - 1; i++)\r\n {\r\n  m = i;\r\n  for (j = i + 1; j &lt; n; j++) if (a[m]&gt;a[j]) m = j;\r\n  t = a[i]; a[i] = a[m]; a[m] = t;\r\n }\r\n}\r\nvoid main()\r\n{\r\n int a[10] = { 5, 4, 7, 8, 2, 3, 1, 9, 6, 10 };\r\n xep(a, 10);\r\n for (int i = 0; i &lt; 10; i++) cout &lt;&lt; &quot; &quot; &lt;&lt; a[i];\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 1, 1, NULL),
(112, 'thuật toán interchange sort', '<pre class="brush:cpp;">\r\n/*thuật to&aacute;n interchange sort\r\n&Yacute; tưởng: Xuất ph&aacute;t từ đầu d&atilde;y, t&igrave;m tất c&aacute;c c&aacute;c nghịch thế chứa phần tử n&agrave;y, triệt ti&ecirc;u ch&uacute;ng bằng c&aacute;ch đổi chỗ 2 phần tử trong cặp nghịch thế. Lặp lại xử l&yacute; tr&ecirc;n với phần tử kế trong d&atilde;y.\r\nBước 1: i = 0;  // bắt đầu từ đầu d&atilde;y\r\nBước 2: j = i+1; //t&igrave;m c&aacute;c nghịch thế với a[i]\r\nBước 3:\r\nTrong khi j &lt; N thực hiện\r\nNếu a[j]&lt;a[i] //x&eacute;t cặp a[i], a[j]\r\nSwap(a[i],a[j]);\r\nj = j+1;\r\nBước 4: i = i+1;\r\nNếu  i &lt; N-1: Lặp lại Bước 2.\r\nNgược lại:  Dừng.\r\n\r\n*/\r\n#include&lt;iostream&gt;\r\nusing namespace std;\r\nvoid xep(int a[], int n)\r\n{\r\n for (int i = 0; i &lt; n - 1;i++)\r\n for (int j = i + 1; j &lt; n;j++)\r\n if (a[i]&gt;a[j])\r\n {\r\n  a[i] += a[j]; a[j] = a[i] - a[j]; a[i] = a[i] - a[j];\r\n }\r\n}\r\nvoid main()\r\n{\r\n int a[10] = { 3, 7, 4, 1, 8, 9, 2, 5, 6, 10 };\r\n xep(a, 10);\r\n for (int i = 0; i &lt; 10; i++) cout &lt;&lt; &quot; &quot; &lt;&lt; a[i];\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(113, 'thuật toán bubble sort', '<pre class="brush:cpp;">\r\n/*thuật to&aacute;n bubble sort\r\n&Yacute; tưởng:\r\nXuất ph&aacute;t từ cuối d&atilde;y, đổi chỗ c&aacute;c cặp phần tử kế cận để đưa phần tử nhỏ hơn trong cặp phần tử đ&oacute; về vị tr&iacute; đ&uacute;ng đầu d&atilde;y hiện h&agrave;nh, sau đ&oacute; sẽ kh&ocirc;ng x&eacute;t đến n&oacute; ở bước tiếp theo, do vậy ở lần xử l&yacute; thứ i sẽ c&oacute; vị tr&iacute; đầu d&atilde;y l&agrave; i.\r\nLặp lại xử l&yacute; tr&ecirc;n cho đến khi kh&ocirc;ng c&ograve;n cặp phần tử n&agrave;o để x&eacute;t.\r\nBước 1 : i = 0; // lần xử l&yacute; đầu ti&ecirc;n\r\nBước 2 : j = N-1;//Duyệt từ cuối d&atilde;y ngược về vị tr&iacute; i\r\nTrong khi (j &gt; i) thực hiện:\r\nNếu a[j]&lt;a[j-1]\r\nDoicho(a[j],a[j-1]);\r\nj = j-1;\r\nBước 3 : i = i+1; // lần xử l&yacute; kế tiếp\r\nNếu  i =N: Hết d&atilde;y. Dừng\r\nNgược lại : Lặp lại Bước 2.\r\n\r\n*/\r\n#include&lt;iostream&gt;\r\nusing namespace std;\r\nvoid xep(int a[], int n)\r\n{\r\n int i, j, t;\r\n for (i = 0; i &lt; n - 1;i++)\r\n for (j = n - 1; j&gt;i;j--)\r\n if (a[j] &lt; a[j - 1])\r\n {\r\n  t = a[j]; a[j] = a[j - 1]; a[j - 1] = t;\r\n }\r\n}\r\nvoid main()\r\n{\r\n int a[10] = { 3, 4, 5, 2, 8, 7, 6, 1, 9, 10 };\r\n xep(a, 10);\r\n for (int i = 0; i &lt; 10; i++) cout &lt;&lt; &quot; &quot; &lt;&lt; a[i];\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(114, 'thuật toán sắp xếp shaker sort', '<pre class="brush:cpp;">\r\n/*thuật to&aacute;n sắp xếp shaker sort\r\nTrong mỗi lần sắp xếp, duyệt mảng theo 2 lượt từ 2 ph&iacute;a kh&aacute;c nhau:\r\nLượt đi: đẩy phần tử nhỏ về đầu mảng.\r\nLượt về: đẩy phần tử lớn về cuối mảng.\r\nGhi nhận lại những đoạn đ&atilde; sắp xếp nhằm tiết kiệm c&aacute;c ph&eacute;p so s&aacute;nh thừa.\r\nBước 1: l=0; r=n-1; //Đoạn l-&gt;r l&agrave; đoạn cần được sắp xếp\r\nk=n;  //ghi nhận vị tr&iacute; k xảy ra ho&aacute;n vị sau c&ugrave;ng\r\n// để l&agrave;m cơ sơ thu hẹp đoạn l-&gt;r\r\nBước 2:\r\nBước 2a:\r\nj=r; //đẩy phần tử nhỏ về đầu mảng\r\nTrong khi j&gt;l\r\nnếu a[j]&lt;a[j-1] th&igrave; {Doicho(a[j],a[j-1]): k=j;}\r\nj--;\r\nl=k; //loại phần tử đ&atilde; c&oacute; thứ tự ở đầu d&atilde;y\r\nBước 2b: j=l\r\nTrong khi j&lt;r\r\nnếu a[j]&gt;a[j+1] th&igrave; {Doicho(a[j],a[j+1]); k=j;}\r\nj++;\r\nr=k; //loại phần tử đ&atilde; c&oacute; thứ tự ở cuối d&atilde;y\r\nBước 3: Nếu l&lt;r lặp lại bước 2\r\nNgược lại: dừng\r\n\r\n*/\r\n#include&lt;iostream&gt;\r\nusing namespace std;\r\ninline void doi(int &amp;a, int &amp;b)\r\n{\r\n int t = a; a = b; b = t;\r\n}\r\nvoid xep(int a[], int n)\r\n{\r\n int left = 0, right = n - 1, k,i,j;\r\n while (left &lt; right)\r\n {\r\n  for (i = left; i &lt; right; i++) if (a[i]&gt;a[i + 1]) { doi(a[i], a[i + 1]); k = i; };\r\n  right = k;\r\n  for (j = right; j&gt;left; j--) if (a[j] &lt; a[j - 1]){ doi(a[j], a[j - 1]); k = j; }\r\n  left = k;\r\n }\r\n}\r\nvoid main()\r\n{\r\n int a[10] = { 2, 8, 9, 5, 6, 3, 4, 7, 1, 10 };\r\n xep(a, 10);\r\n for (int i = 0; i &lt; 10; i++) cout &lt;&lt; &quot; &quot; &lt;&lt; a[i];\r\n}</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 0, 1, NULL),
(115, 'thuật toán tìm kiếm tuyến tính cải tiến', '<pre class="brush:cpp;">\r\nthuật to&aacute;n t&igrave;m kiếm tuyến t&iacute;nh cải tiến tr&ecirc;n d&atilde;y đ&atilde; sắp xếp\r\n#include&lt;iostream&gt;\r\nusing namespace std;\r\nint tim(int *a,int n,int x)\r\n{\r\n int i=0;\r\n while(a[i]!=x &amp;&amp; i&lt;n) i++;\r\n if(i==n) return 0;\r\n return i;\r\n}\r\nint tim1(int *a,int n,int x)\r\n{\r\n int i=0;\r\n a[n]=x;\r\n while(a[i]!=x) i++;\r\n if(i==n) return 0;\r\n return i;\r\n\r\n\r\n}\r\nint tim2caitien(int *a,int n,int x)\r\n{\r\n int i=0;\r\n a[n]=x;\r\n while(a[i]&lt;x) i++;\r\n if(i&lt;n &amp;&amp; a[i]==x) return i;\r\n return 0;\r\n}\r\nvoid main()\r\n{\r\n int a[11]={1,3,6,7,10,11,13,24,45,46},x;\r\n cout&lt;&lt;&quot;tim so x=&quot;;\r\n cin&gt;&gt;x;\r\n if(int t=tim2caitien(a,10,x)) cout&lt;&lt;&quot;tim thay tai vi tri: &quot;&lt;&lt;t&lt;&lt;&quot;\n&quot;;\r\n else cout&lt;&lt;&quot;khong tim thay&quot;;\r\n\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 1, 1, NULL),
(116, 'thuật toán tìm kiếm nhị phân bằng đệ quy', '<pre class="brush:cpp;">\r\n//thuật to&aacute;n t&igrave;m kiếm nhị ph&acirc;n bằng đệ quy\r\n#include&lt;iostream&gt;\r\nusing namespace std;\r\nint tim(int *a,int left,int right,int x)\r\n{\r\n int m;\r\n if(left&gt;right) return 0;\r\n m=(left+right)/2;\r\n if(a[m]==x) return m;\r\n if(x&lt;a[m]) return tim(a,left,m-1,x);\r\n return tim(a,m+1,right,x);\r\n}\r\nvoid main()\r\n{\r\n int a[10]={1,2,3,4,5,6,7,8,9,10};\r\n int x;\r\n cout&lt;&lt;&quot;tim so: &quot;;cin&gt;&gt;x;\r\n if(int z=tim(a,0,9,x)) cout&lt;&lt;&quot;tim thay tai vi tri: &quot;&lt;&lt;z&lt;&lt;&quot;\n&quot;;\r\n else cout&lt;&lt;&quot;khong tim thay\n&quot;;\r\n\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 1, 1, NULL),
(117, 'thuật toán tìm kiếm nhị phân', '<pre class="brush:cpp;">\r\n/*thuật to&aacute;n t&igrave;m kiếm nhị ph&acirc;n\r\nĐược &aacute;p dụng tr&ecirc;n mảng đ&atilde; c&oacute; thứ tự.\r\n&Yacute; tưởng: .\r\nGiả xử ta x&eacute;t mảng c&oacute; thứ tự tăng, khi ấy ta c&oacute;\r\nai-1&lt;ai&lt;ai+1\r\nNếu X&gt;ai th&igrave; X chỉ c&oacute; thể xuất hiện trong đoạn [ai+1, an-1]\r\nNếu X&lt;ai th&igrave; X chỉ c&oacute; thể xuất hiện trong đoạn [a0,   ai-1]\r\n&Yacute; tưởng của giải thuật l&agrave; tại mỗi bước\r\n ta so s&aacute;nh X với phần tử đứng giữa trong \r\nd&atilde;y t&igrave;m kiếm hiện h&agrave;nh, dựa v&agrave;o kết quả \r\nso s&aacute;nh n&agrave;y m&agrave; ta quyết định giới hạn d&atilde;y\r\n t&igrave;m kiếm ở nữa dưới hay nữa tr&ecirc;n của d&atilde;y t&igrave;m kiếm hiện h&agrave;nh.\r\nGiả sử d&atilde;y t&igrave;m kiếm hiện h&agrave;nh bao gồm\r\n c&aacute;c phần tử nằm trong aleft, aright, c&aacute;c bước của giải thuật như sau:\r\nBước 1: left=0; right=N-1;\r\nBước 2:\r\nmid=(left+right)/2; //chỉ số phần tử giữa d&atilde;y hiện h&agrave;nh\r\nSo s&aacute;nh a[mid] với x. C&oacute; 3 khả năng\r\na[mid]= x: t&igrave;m thấy. Dừng\r\na[mid]&gt;x :  Right= mid-1;\r\na[mid]&lt;x : Left= mid+1;\r\nBước 3: Nếu Left &lt;=Right ; //  c&ograve;n phần tử trong d&atilde;y hiện      h&agrave;nh\r\n+ Lặp lại bước 2\r\nNgược lại : Dừng\r\nH&agrave;m trả về gi&aacute; trị 1 nếu t&igrave;m thấy, ngược lại h&agrave;m trả về gi&aacute; trị 0\r\n\r\n*/\r\n#include&lt;iostream&gt;\r\nusing namespace std;\r\nint tim(int a[], int left,int right, int x)\r\n{\r\n do\r\n {\r\n  if (x == a[(left + right) / 2]) return 1;\r\n  if (a[(left + right) / 2] &gt; x) right = (left + right) / 2 - 1;\r\n  else left = (left + right) / 2 + 1;\r\n } while (left &lt;= right);\r\n}\r\nvoid main()\r\n{\r\n int a[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\r\n cout &lt;&lt; tim(a, 0, 9, 1);\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 3, 1, NULL),
(118, 'thuật toán tìm kiếm tuyến tính', '<pre class="brush:cpp;">\r\n/*thuật to&aacute;n t&igrave;m kiếm tuyến t&iacute;nh\r\nCho danh s&aacute;ch c&oacute; n phần tử a0, a1, a2&hellip;, an-1.\r\nĐể đơn giản trong việc tr&igrave;nh b&agrave;y \r\ngiải thuật ta d&ugrave;ng mảng 1 chiều a để lưu\r\n danh s&aacute;ch c&aacute;c phần tử n&oacute;i tr&ecirc;n trong bộ nhớ ch&iacute;nh.\r\nT&igrave;m phần tử c&oacute; kho&aacute; bằng X trong mảng\r\nGiải thuật t&igrave;m kiếm tuyến t&iacute;nh (t&igrave;m tuần tự)\r\nGiải thuật t&igrave;m kiếm nhị ph&acirc;n\r\nLưu &yacute;: Trong qu&aacute; tr&igrave;nh tr&igrave;nh b&agrave;y thuật giải ta\r\n d&ugrave;ng ng&ocirc;n ngữ lập tr&igrave;nh C.\r\n&Yacute; tưởng : So s&aacute;nh X lần lượt với phần tử thứ 1\r\n, thứ 2,&hellip;của mảng a cho đến khi gặp được kh&oacute;a cần t&igrave;m,\r\n hoặc t&igrave;m hết mảng m&agrave; kh&ocirc;ng thấy.\r\nC&aacute;c bước tiến h&agrave;nh\r\nBước 1: Khởi g&aacute;n i=0;\r\nBước 2: So s&aacute;nh a[i] với gi&aacute; trị x cần t&igrave;m, c&oacute; 2 khả năng\r\n+ a[i] == x t&igrave;m thấy x. Dừng;\r\n+ a[i] != x sang bước 3;\r\nBước 3: i=i+1 // X&eacute;t tiếp phần tử kế tiếp trong mảng\r\nNếu i==N: Hết mảng. Dừng;\r\nNgược lại: Lặp lại bước 2;\r\nH&agrave;m trả về 1 nếu t&igrave;m thấy, ngược lại trả về 0:\r\nint LinearSearch(int a[],int n, int x)\r\n{\r\nint i=0;\r\nwhile((i&lt;n)&amp;&amp;(a[i]!=x))\r\ni++;\r\nif(i==n)\r\nreturn 0; //T&igrave;m kh&ocirc;ng thấy x\r\nelse\r\nreturn 1; //T&igrave;m thấy\r\n}Nhận x&eacute;t: Số ph&eacute;p so s&aacute;nh của thuật to&aacute;n\r\n trong trường hợp xấu nhất l&agrave; 2*n.\r\nĐể giảm thiểu số ph&eacute;p so s&aacute;nh trong v&ograve;ng lặp cho thuật to&aacute;n\r\n, ta th&ecirc;m phần tử &ldquo;l&iacute;nh canh&rdquo; v&agrave;o cuối d&atilde;y.\r\nint LinearSearch(int a[],int n, int x)\r\n{  int i=0; a[n]=x;   // a[n] l&agrave; phần tử &ldquo;l&iacute;nh canh&rdquo;\r\n  while(a[i]!=x)  \r\n   i++;\r\n  if(i==n)\r\n   return 0; // T&igrave;m kh&ocirc;ng thấy x\r\n  else \r\n   return 1; // T&igrave;m thấy\r\n}\r\n\r\n*/\r\n#include&lt;iostream&gt;\r\nusing namespace std;\r\nint tim(int a[], int n,int x)\r\n{\r\n for (int i = 0; i &lt; n;i++) if (x == a[i]) return i+1;\r\n return 0;\r\n}\r\nvoid main()\r\n{\r\n int a[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\r\n int x;\r\n cout &lt;&lt; &quot;nhap gia tri muon tim: &quot;;\r\n cin &gt;&gt; x;\r\n int vt = tim(a, 10, x);\r\n if (vt !=0) cout &lt;&lt; &quot;tim thay tai vi tri: &quot; &lt;&lt; vt &lt;&lt; &quot;\n&quot;;\r\n else cout &lt;&lt; &quot;khong tim thay\n&quot;;\r\n}\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 5, 1, NULL);
INSERT INTO `baiviet` (`idbv`, `subject`, `content`, `image_bv`, `parent`, `date_add`, `views`, `author`, `des`) VALUES
(119, 'danh sách liên kết đơn', '<p>Mỗi phần tử li&ecirc;n kết với phần tử đứng liền sau trong danh s&aacute;ch<br />\r\nMỗi phần tử trong danh s&aacute;ch li&ecirc;n kết đơn l&agrave; một cấu tr&uacute;c c&oacute; hai th&agrave;nh phần<br />\r\nTh&agrave;nh phần dữ liệu: Lưu trữ th&ocirc;ng tin về bản th&acirc;n phần tử<br />\r\nTh&agrave;nh phần li&ecirc;n kết: Lưu địa chỉ phần tử đứng sau trong danh s&aacute;ch hoặc bằng NULL nếu l&agrave; phần tử cuối danh s&aacute;ch.<br />\r\n<a name="more"></a><br />\r\nCấu tr&uacute;c dữ liệu của 1 n&uacute;t trong List đơn<br />\r\ntypedef &nbsp; struct &nbsp;tagNode&nbsp;<br />\r\n{ Data &nbsp; &nbsp;Info; &nbsp; // Lưu th&ocirc;ng tin bản th&acirc;n<br />\r\n&nbsp; struct &nbsp;tagNode &nbsp;*pNext; //Lưu địa chỉ của Node đứng sau<br />\r\n}Node;&nbsp;<br />\r\nCấu tr&uacute;c dữ liệu của DSLK đơn<br />\r\ntypedef &nbsp; struct &nbsp;tagList&nbsp;<br />\r\n{ Node &nbsp;*pHead;//Lưu địa chỉ Node đầu ti&ecirc;n trong List<br />\r\n&nbsp; Node &nbsp;*pTail; //Lưu địa chỉ của Node cuối c&ugrave;ng trong List<br />\r\n}LIST; &nbsp; &nbsp;// kiểu danh s&aacute;ch li&ecirc;n kết đơn<br />\r\n<br />\r\n*c&aacute;c thao t&aacute;c cơ bản tr&ecirc;n danh s&aacute;ch li&ecirc;n kết<br />\r\nTạo 1 danh s&aacute;ch li&ecirc;n kết đơn rỗng<br />\r\nTạo 1 n&uacute;t c&oacute; trường Infor bằng x<br />\r\nT&igrave;m một phần tử c&oacute; Info bằng x<br />\r\nTh&ecirc;m một phần tử c&oacute; kh&oacute;a x v&agrave;o danh s&aacute;ch<br />\r\nHủy một phần tử trong danh s&aacute;ch<br />\r\nDuyệt danh s&aacute;ch<br />\r\nSắp xếp danh s&aacute;ch li&ecirc;n kết đơn<br />\r\n<br />\r\n*khởi tạo danh &aacute;ch li&ecirc;n kết<br />\r\nĐịa chỉ của n&uacute;t đầu ti&ecirc;n, địa chỉ của n&uacute;t cuối c&ugrave;ng đều kh&ocirc;ng c&oacute;<br />\r\n&nbsp;&nbsp;void CreateList(List &amp;l)&nbsp;<br />\r\n&nbsp; { &nbsp;&nbsp;<br />\r\n&nbsp; &nbsp; l.pHead=NULL;<br />\r\n&nbsp; &nbsp; l.pTail=NULL;<br />\r\n&nbsp; }<br />\r\n*tạo 1 phần tử mới<br />\r\nH&agrave;m trả về địa chỉ phần tử mới tạo<br />\r\nNode* CreateNode(Data x) // trong b&agrave;i học l&agrave; int<br />\r\n{ Node *p;<br />\r\n&nbsp; p = new Node;//Cấp ph&aacute;t v&ugrave;ng nhớ cho phần tử<br />\r\n&nbsp; if ( p==NULL) &nbsp;exit(1);&nbsp;<br />\r\n&nbsp; p -&gt;Info = x; &nbsp; //g&aacute;n dữa liệu cho n&uacute;t<br />\r\n&nbsp; p-&gt;pNext = NULL;<br />\r\n&nbsp; return p;&nbsp;<br />\r\n&nbsp; &nbsp;}<br />\r\n*th&ecirc;m 1 phần tử v&agrave;o s&aacute;nh s&aacute;ch li&ecirc;n kết<br />\r\nNguy&ecirc;n tắc th&ecirc;m: Khi th&ecirc;m 1 phần tử v&agrave;o List th&igrave; c&oacute; l&agrave;m cho pHead, pTail thay đổi?<br />\r\nC&aacute;c vị tr&iacute; cần th&ecirc;m 1 phần tử v&agrave;o List:<br />\r\n+)Th&ecirc;m v&agrave;o đầu List đơn<br />\r\nTh&ecirc;m n&uacute;t p v&agrave;o đầu danh s&aacute;ch li&ecirc;n kết đơn<br />\r\n&nbsp; Bắt đầu:<br />\r\n&nbsp; &nbsp; Nếu List rỗng th&igrave;<br />\r\n&nbsp; &nbsp; &nbsp; + pHead = p;<br />\r\n&nbsp; &nbsp; &nbsp; + pTail = pHead;<br />\r\n&nbsp; &nbsp; Ngược lại<br />\r\n&nbsp; &nbsp; &nbsp; + p-&gt;pNext = pHead;<br />\r\n&nbsp; &nbsp; &nbsp; + pHead = p<br />\r\nvoid AddHead(LIST &amp;l, Node* p)<br />\r\n{<br />\r\n&nbsp; &nbsp; if (l.pHead==NULL)&nbsp;<br />\r\n&nbsp; &nbsp; {&nbsp;<br />\r\n&nbsp; &nbsp; &nbsp; l.pHead = p;&nbsp;<br />\r\n&nbsp; &nbsp; &nbsp; l.pTail = l.pHead;&nbsp;<br />\r\n&nbsp; &nbsp; }<br />\r\n&nbsp; &nbsp; else<br />\r\n&nbsp; &nbsp; {&nbsp;<br />\r\n&nbsp; &nbsp; &nbsp; p-&gt;pNext = l.pHead;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; l.pHead = p; &nbsp;<br />\r\n&nbsp; &nbsp; }<br />\r\n}<br />\r\n<br />\r\n+)Th&ecirc;m v&agrave;o cuối List<br />\r\nTa cần th&ecirc;m n&uacute;t p v&agrave;o cuối list đơn<br />\r\n&nbsp; Bắt đầu:<br />\r\n&nbsp; &nbsp; Nếu List rỗng th&igrave;<br />\r\n&nbsp; &nbsp; &nbsp; + pHead = p;<br />\r\n&nbsp; &nbsp; &nbsp; + pTail = pHead;<br />\r\n&nbsp; &nbsp; Ngược lại<br />\r\n&nbsp; &nbsp; &nbsp; + pTail-&gt;pNext=p;<br />\r\n&nbsp; &nbsp; &nbsp; + pTail=p<br />\r\n&nbsp;&nbsp;void AddTail(LIST &amp;l, Node *p)<br />\r\n&nbsp; {<br />\r\n&nbsp; &nbsp; if (l.pHead==NULL) &nbsp;<br />\r\n&nbsp; &nbsp; {&nbsp;<br />\r\n&nbsp; &nbsp; &nbsp; l.pHead = p;&nbsp;<br />\r\n&nbsp; &nbsp; &nbsp; l.pTail = l.pHead;&nbsp;<br />\r\n&nbsp; &nbsp; }<br />\r\n&nbsp; &nbsp; else<br />\r\n&nbsp; &nbsp; {&nbsp;<br />\r\n&nbsp; &nbsp; &nbsp; l.pTail-&gt;Next = p; &nbsp;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; l.pTail = p;&nbsp;<br />\r\n&nbsp; &nbsp; }<br />\r\n&nbsp; }<br />\r\n<br />\r\n+)Th&ecirc;m v&agrave;o sau 1 phần tử q trong list<br />\r\nTa cần th&ecirc;m n&uacute;t p v&agrave;o sau n&uacute;t q trong list đơn<br />\r\n&nbsp; Bắt đầu:<br />\r\n&nbsp; &nbsp; Nếu (q!=NULL) th&igrave;<br />\r\n&nbsp; &nbsp; &nbsp; B1: p-&gt;pNext = q-&gt;pNext<br />\r\n&nbsp; &nbsp; &nbsp; B2:<br />\r\n&nbsp; &nbsp; + q-&gt;pNext = p<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; + nếu q = pTail th&igrave;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pTail=p<br />\r\n<br />\r\n&nbsp;&nbsp;void InsertAfterQ(List &amp;l, Node *p, Node *q)<br />\r\n&nbsp; {<br />\r\n&nbsp; &nbsp; if(q!=NULL)<br />\r\n&nbsp; &nbsp; {<br />\r\n&nbsp; &nbsp; p-&gt;pNext=q-&gt;Next;<br />\r\n&nbsp; &nbsp; q-&gt;pNext=p;<br />\r\n&nbsp; &nbsp; if(l.pTail==q)&nbsp;<br />\r\n&nbsp; &nbsp; &nbsp; l.Tail=p;<br />\r\n&nbsp; &nbsp;}<br />\r\n&nbsp; &nbsp;else<br />\r\n&nbsp; &nbsp; AddHead(l,p);// th&ecirc;m q v&agrave;o đầu list<br />\r\n}<br />\r\n<br />\r\n*hủy phần tử trong sanh s&aacute;ch li&ecirc;n kết<br />\r\nNguy&ecirc;n tắc: Phải c&ocirc; lập phần tử cần hủy trước hủy.<br />\r\nC&aacute;c vị trị cần hủy<br />\r\nHủy phần tử đứng đầu List<br />\r\nHủy phần tử c&oacute; kho&aacute; bằng x<br />\r\nHuỷ phần tử đứng sau q trong danh s&aacute;ch li&ecirc;n kết đơn<br />\r\nỞ phần tr&ecirc;n, c&aacute;c phần tử trong DSLK đơn được cấp ph&aacute;t v&ugrave;ng nhớ động bằng h&agrave;m new, th&igrave; sẽ được giải ph&oacute;ng v&ugrave;ng nhớ bằng h&agrave;m delete.<br />\r\n&nbsp;Bắt đầu:<br />\r\nNếu (pHead!=NULL) th&igrave;<br />\r\nB1: p=pHead<br />\r\nB2:<br />\r\n+ pHead = pHead-&gt;pNext<br />\r\n+ delete (p)<br />\r\nB3:<br />\r\n&nbsp;Nếu pHead==NULL th&igrave; pTail=NULL<br />\r\n<br />\r\nHủy được h&agrave;m trả về 1, ngược lại h&agrave;m trả về 0<br />\r\n&nbsp; int &nbsp; RemoveHead(List &amp;l, int &amp;x)<br />\r\n&nbsp; { Node *p;<br />\r\n&nbsp; &nbsp; if(l.pHead!=NULL)<br />\r\n&nbsp; &nbsp; { p=l.pHead;&nbsp;<br />\r\n&nbsp; &nbsp; &nbsp; x=p-&gt;Info; //lưu Data của n&uacute;t cần hủy&nbsp;<br />\r\n&nbsp; &nbsp; &nbsp; l.pHead=l.pHead-&gt;pNext;<br />\r\n&nbsp; &nbsp; &nbsp; delete p;<br />\r\n&nbsp; &nbsp; &nbsp; if(l.pHead==NULL)<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; l.pTail=NULL;<br />\r\n&nbsp; &nbsp; &nbsp; return 1;<br />\r\n&nbsp; &nbsp; }<br />\r\n&nbsp; &nbsp; return 0;<br />\r\n&nbsp; }<br />\r\nHủy phần tử sau phần tử q trong List<br />\r\nBắt đầu<br />\r\nNếu (q!=NULL) th&igrave; //q tồn tại trong List<br />\r\nB1: p=q-&gt;pNext;// p l&agrave; phần tử cần hủy<br />\r\nB2: Nếu (p!=NULL) th&igrave; // q kh&ocirc;ng phải l&agrave; phần tử cuối<br />\r\n&nbsp; &nbsp; &nbsp; + q-&gt;pNext=p-&gt;pNext;// t&aacute;ch p ra khỏi x&acirc;u<br />\r\n&nbsp; &nbsp; &nbsp; + nếu (p== pTail) // n&uacute;t cần hủy l&agrave; n&uacute;t cuối<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; pTail=q;<br />\r\n&nbsp; &nbsp; &nbsp; + delete p;// hủy p<br />\r\n&nbsp; &nbsp; &nbsp;&nbsp;<br />\r\n&nbsp; int RemoveAfterQ(List &amp;l, Node *q, int &amp;x)<br />\r\n&nbsp; { Node *p;<br />\r\n&nbsp; &nbsp; if(q!=NULL)<br />\r\n&nbsp; &nbsp; { p=q-&gt;pNext; //p l&agrave; n&uacute;t cần xo&aacute;<br />\r\n&nbsp; &nbsp; &nbsp; if(p!=NULL) // q kh&ocirc;ng ph&agrave;i l&agrave; n&uacute;t cuối<br />\r\n&nbsp; &nbsp; &nbsp; { if(p==l.pTail) //n&uacute;t cần xo&aacute; l&agrave; n&uacute;t cuối c&ugrave;ng&nbsp;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l.pTail=q;// cập nhật lạ pTail<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; q-&gt;pNext=p-&gt;pNext; x=p-&gt;Info;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; delete p;<br />\r\n&nbsp; &nbsp; &nbsp; }<br />\r\n&nbsp; &nbsp; &nbsp; return 1;<br />\r\n&nbsp; &nbsp; }<br />\r\n&nbsp; &nbsp; else&nbsp;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return 0; &nbsp;}<br />\r\nThuật to&aacute;n hủy phần tử c&oacute; kho&aacute; x<br />\r\nBước 1:<br />\r\n&nbsp; &nbsp; T&igrave;m phần tử p c&oacute; kho&aacute; bằng x, v&agrave; q đứng trước p<br />\r\nBước 2:<br />\r\n&nbsp; &nbsp; Nếu (p!=NULL) th&igrave; //t&igrave;m thấy phần tử c&oacute; kho&aacute; bằng x<br />\r\n&nbsp; &nbsp; &nbsp; Hủy p ra khỏi List bằng c&aacute;ch hủy phần tử &nbsp; &nbsp;đứng sau q<br />\r\n&nbsp; &nbsp; Ngược lại<br />\r\n&nbsp; &nbsp; &nbsp; B&aacute;o kh&ocirc;ng t&igrave;m thấy phần tử c&oacute; kho&aacute;<br />\r\nint RemoveX(List &amp;l, int x)<br />\r\n{ Node *p,*q = NULL; p=l.Head;<br />\r\n&nbsp; while((p!=NULL)&amp;&amp;(p-&gt;Info!=x)) //t&igrave;m<br />\r\n&nbsp; { q=p;<br />\r\n&nbsp; &nbsp; p=p-&gt;Next;<br />\r\n&nbsp; }<br />\r\n&nbsp; if(p==NULL) //kh&ocirc;ng t&igrave;m thấy phần tử c&oacute; kho&aacute; bằng x<br />\r\n&nbsp; &nbsp; return 0;<br />\r\n&nbsp; if(q!=NULL)//t&igrave;m thấy phần tử c&oacute; kho&aacute; bằng x<br />\r\n&nbsp; &nbsp; DeleteAfterQ(l,q,x);<br />\r\n&nbsp; else //phần tử cần xo&aacute; nằm đầu List&nbsp;<br />\r\n&nbsp; &nbsp; RemoveHead(l,x);<br />\r\n&nbsp; return 1;<br />\r\n}<br />\r\nH&agrave;m t&igrave;m 1 phần tử trong DSLK đơn<br />\r\n&nbsp; H&agrave;m t&igrave;m phần tử c&oacute; Info = x, h&agrave;m trả về địa chỉ của n&uacute;t c&oacute; Info = x, ngược lại h&agrave;m trả về NULL<br />\r\nNode *Search(LIST l, Data &nbsp;x)&nbsp;<br />\r\n{&nbsp;<br />\r\n&nbsp; &nbsp; Node &nbsp; &nbsp;*p;<br />\r\n&nbsp; &nbsp; p = l.pHead;<br />\r\n&nbsp; &nbsp; while((p!= NULL)&amp;&amp;(p-&gt;Info != x))&nbsp;<br />\r\n&nbsp; &nbsp; &nbsp; p = p-&gt;pNext;<br />\r\n&nbsp; &nbsp;return p;<br />\r\n}<br />\r\nDuyệt danh s&aacute;ch<br />\r\nDuyệt danh s&aacute;ch l&agrave; thao t&aacute;c thường được thực hiện khi c&oacute; nhu cầu cần xử l&yacute; c&aacute;c phần tử trong danh s&aacute;ch như:<br />\r\nĐếm c&aacute;c phần tử trong danh s&aacute;ch<br />\r\nT&igrave;m tất cả c&aacute;c phần tử trong danh s&aacute;ch thảo điều kiện<br />\r\nHủy to&agrave;n bộ danh s&aacute;ch<br />\r\n<br />\r\nBước 1:<br />\r\np = pHead;// p lưu địa chỉ của phần tử đầu trong List<br />\r\nBước 2:<br />\r\nTrong khi (danh s&aacute;ch chưa hết) thực hiện<br />\r\n&nbsp; &nbsp; + xử l&yacute; phần tử p<br />\r\n&nbsp; &nbsp; + p=p-&gt;pNext;// qua phần tử kế<br />\r\n<br />\r\n&nbsp; void PrintList(List l)<br />\r\n&nbsp; {<br />\r\n&nbsp; &nbsp; Node *p;<br />\r\n&nbsp; &nbsp; p=l.pHead;<br />\r\n&nbsp; &nbsp; while(p!=NULL)<br />\r\n&nbsp; &nbsp; { printf(&ldquo;%d &nbsp; &nbsp; &rdquo;, p-&gt;Info);<br />\r\n&nbsp; &nbsp; &nbsp; p=p-&gt;pNext;<br />\r\n&nbsp; &nbsp; }<br />\r\n&nbsp; }<br />\r\nHủy&nbsp;danh s&aacute;ch li&ecirc;n kết đơn<br />\r\nBước 1:<br />\r\nTrong khi (danh s&aacute;ch chưa hết) thực hiện<br />\r\nB11:<br />\r\n&nbsp; p = pHead;<br />\r\n&nbsp; pHead = pHead-&gt;pNext;// cập nhật pHead<br />\r\nB12:<br />\r\nHủy p<br />\r\nBước 2:<br />\r\n&nbsp; pTail = NULL;// bảo to&agrave;n t&iacute;nh nhất qu&aacute;n khi x&acirc;u rỗng<br />\r\n<br />\r\n&nbsp;&nbsp;void RemoveList(List &amp;l)<br />\r\n&nbsp; {&nbsp;<br />\r\n&nbsp; &nbsp; Node *p;<br />\r\n&nbsp; &nbsp; while(l.pHead!=NULL)//c&ograve;n phần tử trong List<br />\r\n&nbsp; &nbsp; {<br />\r\n&nbsp; &nbsp; &nbsp; p = l.pHead;<br />\r\n&nbsp; &nbsp; &nbsp; l.pHead = p-&gt;pNext;<br />\r\n&nbsp; &nbsp; &nbsp; delete p;<br />\r\n&nbsp; &nbsp; }<br />\r\n&nbsp; }&nbsp;<br />\r\nSắp xếp danh s&aacute;ch<br />\r\nC&oacute; hai c&aacute;ch tiếp cận<br />\r\nC&aacute;ch 1: Thay đổi th&agrave;nh phần Info<br />\r\n<br />\r\nC&aacute;ch 2: Thay đổi th&agrave;nh phần pNext (thay đổi tr&igrave;nh tự m&oacute;c nối của c&aacute;c phần tử sao cho tạo lập n&ecirc;n được thứ tự mong muốn)<br />\r\nThay đổi th&agrave;nh phần Info (dữ liệu)<br />\r\nƯu: C&agrave;i đặt đơn giản, tương tự như sắp xếp mảng<br />\r\nNhược:<br />\r\nĐ&ograve;i hỏi th&ecirc;m v&ugrave;ng nhớ khi ho&aacute;n vị nội dung của 2 phần tử -&gt; chỉ ph&ugrave; hợp với những x&acirc;u c&oacute; k&iacute;ch thước Info nhỏ<br />\r\nKhi k&iacute;ch thước Info (dữ liệu) lớn chi ph&iacute; cho việc ho&aacute;n vị th&agrave;nh phần Info lớn<br />\r\nL&agrave;m cho thao t&aacute;c sắp xếp chậm<br />\r\nThay đổi th&agrave;nh phần pNext<br />\r\nƯu:<br />\r\nK&iacute;ch thước của trường n&agrave;y kh&ocirc;ng thay đổi, do đ&oacute; kh&ocirc;ng phụ thuộc v&agrave;o k&iacute;ch thước bản chất dữ liệu lưu tại mỗi n&uacute;t.<br />\r\nThao t&aacute;c sắp xếp nhanh<br />\r\nNhược: C&agrave;i đặt phức tạp<br />\r\nvoid SelectionSort(LIST &amp;l)<br />\r\n{<br />\r\n&nbsp; &nbsp; Node *p,*q,*min;<br />\r\n&nbsp; &nbsp; p=l.pHead;<br />\r\n&nbsp; &nbsp; while(p!=l.pTail)<br />\r\n&nbsp; &nbsp;{<br />\r\n&nbsp; min=p;<br />\r\n&nbsp; q=p-&gt;pNext;<br />\r\n&nbsp; --------------------------------------<br />\r\n&nbsp; while(q!=NULL)<br />\r\n&nbsp; {&nbsp;<br />\r\n&nbsp; if(q-&gt;Info&lt;p-&gt;Info)<br />\r\n&nbsp; &nbsp; min=q;<br />\r\n&nbsp; q=q-&gt;pNext;<br />\r\n&nbsp; }<br />\r\n&nbsp; HV(min-&gt;Info,p-&gt;Info);<br />\r\n&nbsp; p=p-&gt;pNext;<br />\r\n&nbsp; }<br />\r\n&nbsp; &nbsp; }<br />\r\n<br />\r\n&nbsp; &nbsp; C&aacute;c thuật to&aacute;n sắp xếp hiệu quả tr&ecirc;n List<br />\r\nC&aacute;c thuật to&aacute;n sắp xếp x&acirc;u (List) bằng c&aacute;c thay đổi th&agrave;nh phần pNext (th&agrave;nh phần li&ecirc;n kết) c&oacute; hiệu quả cao như:<br />\r\nThuật to&aacute;n sắp xếp Quick Sort<br />\r\nThuật to&aacute;n sắp xếp Merge Sort<br />\r\nThuật to&aacute;n sắp xếp Radix Sort<br />\r\n<br />\r\nThuật to&aacute;n sắp xếp Quick Sort<br />\r\nBước 1:<br />\r\nChọn X l&agrave; phần tử đầu x&acirc;u L l&agrave;m phần tử cầm canh<br />\r\nLoại X ra khỏi L<br />\r\nBước 2:<br />\r\nT&aacute;ch x&acirc;u L ra l&agrave;m 2 x&acirc;u L1(gồm c&aacute;c phần tử nhỏ hơn hoặc bằng x) v&agrave; L2 (gồm c&aacute;c phần tử lớn hơn X)<br />\r\nBước 3: Nếu (L1 !=NULL) th&igrave; QuickSort(L1)<br />\r\nBước 4: Nếu (L2!=NULL) th&igrave; QuickSort(L2)<br />\r\nBước 5: Nối L1, X, L2 lại theo thứ tự ta c&oacute; x&acirc;u L đ&atilde; được sắp xếp<br />\r\nSắp xếp L1<br />\r\nSắp xếp L2<br />\r\nChọn x=6 cầm canh, v&agrave; t&aacute;ch L2 th&agrave;nh L21 v&agrave; L22<br />\r\nvoid QuickSort(List &amp;l)<br />\r\n{ Node *p,*X;//X lưu địa chỉ của phần tử cầm canh<br />\r\n&nbsp; List l1,l2;<br />\r\n&nbsp; if(l.pHead==l.pTail) return;//đ&atilde; c&oacute; thứ tự<br />\r\n&nbsp; CreateList(l1);<br />\r\n&nbsp; CreateList(l2);<br />\r\n&nbsp; X=l.pHead;<br />\r\n&nbsp; l.pHead=X-&gt;pNext;<br />\r\n&nbsp; while(l.pHead!=NULL)//t&aacute;ch L = L1 va L2<br />\r\n&nbsp; { p=l.pHead;<br />\r\n&nbsp; &nbsp; l.pHead=p-&gt;pNext;<br />\r\n&nbsp; &nbsp; p-&gt;pNext=NULL;<br />\r\n&nbsp; &nbsp; if(p-&gt;Info&lt;=X-&gt;Info)<br />\r\n&nbsp; &nbsp; &nbsp; AddHead(l1,p);<br />\r\n&nbsp; &nbsp; else<br />\r\n&nbsp; &nbsp; &nbsp; AddHead(l2,p);<br />\r\n&nbsp; }<br />\r\n&nbsp; QuickSort(l1);//Gọi đệ quy sắp xếp L1<br />\r\n&nbsp; QuickSort(l2);//Gọi đệ quy sắp xếp L2<br />\r\n&nbsp; if(l1.pHead!=NULL)//nối l1, l2 va X vao l<br />\r\n&nbsp; {<br />\r\n&nbsp; &nbsp; l.pHead=l1.pHead;<br />\r\n&nbsp; &nbsp; l1.pTail-&gt;pNext=X;//nối X v&agrave;o<br />\r\n&nbsp; }<br />\r\n&nbsp; else<br />\r\n&nbsp; &nbsp; l.pHead=X;<br />\r\n&nbsp; X-&gt;pNext=l2.pHead;<br />\r\n&nbsp; if(l2.pHead!=NULL) //l2 c&oacute; tr&ecirc;n một phần tử<br />\r\n&nbsp; &nbsp; l.pTail=l2.pTail;<br />\r\n&nbsp; else &nbsp;//l2 kh&ocirc;ng c&oacute; phần tử n&agrave;o&nbsp;<br />\r\n&nbsp; &nbsp; l.pTail=X;<br />\r\n}<br />\r\n<br />\r\n<br />\r\nThuật tốn sắp xếp Merge Sort<br />\r\nBước 1: Ph&acirc;n phối lu&acirc;n phi&ecirc;n từng đường chạy của x&acirc;u L v&agrave;o 2 x&acirc;u con L1 v&agrave; L2.<br />\r\nBước 2: Nếu L1 != NULL th&igrave; Merge Sort (L1).<br />\r\nBước 3: Nếu L2 != NULL th&igrave; Merge Sort (L2).<br />\r\nBước 4: Trộn L1 v&agrave; L2 đ&atilde; sắp xếp lại ta c&oacute; x&acirc;u L &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;đ&atilde; được sắp xếp.<br />\r\nKh&ocirc;ng tốn th&ecirc;m kh&ocirc;ng gian lưu trữ cho c&aacute;c d&atilde;y phụ<br />\r\n<br />\r\n<br />\r\nC&agrave;i đặt h&agrave;m main()<br />\r\nY&ecirc;u cầu: Viết chương tr&igrave;nh th&agrave;nh lập 1 x&acirc;u đơn, trong đ&oacute; th&agrave;nh phần dữ liệu của mỗi n&uacute;t l&agrave; 1 số nguy&ecirc;n dương.<br />\r\nLiệt k&ecirc; tất th&agrave;nh phần dữ liệu của tất cả c&aacute;c n&uacute;t trong x&acirc;u<br />\r\nT&igrave;m 1 phần tử c&oacute; kho&aacute; bằng x trong x&acirc;u.<br />\r\nXo&aacute; 1 phần tử đầu x&acirc;u<br />\r\nXo&aacute; 1 phần tử c&oacute; kho&aacute; bằng x trong x&acirc;u<br />\r\nSắp xếp x&acirc;u tăng dần theo th&agrave;nh phần dữ liệu (Info)<br />\r\nCh&egrave;n 1 phần tử v&agrave;o x&acirc;u, sao cho sau khi ch&egrave;n x&acirc;u vẫn tăng dần theo trường dữ liệu<br />\r\n..vv<br />\r\n&nbsp;&nbsp;void main()<br />\r\n&nbsp; { &nbsp; LIST &nbsp;l1; Node *p; int x;<br />\r\n&nbsp; &nbsp; CreateList(l1);<br />\r\n&nbsp; &nbsp; do{<br />\r\n&nbsp; &nbsp; &nbsp; printf(&ldquo;nhap x=&rdquo;); scanf(&ldquo;%d&rdquo;,&amp;x);<br />\r\n&nbsp; &nbsp; &nbsp; if(x&gt;0) &nbsp;<br />\r\n&nbsp; &nbsp; &nbsp; { &nbsp; p = CreateNode(x);<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; AddHead(l1,x);<br />\r\n&nbsp; &nbsp; &nbsp; }&nbsp;<br />\r\n&nbsp; &nbsp; }while(x&gt;0);<br />\r\n&nbsp; &nbsp; printf(&ldquo;Danh s&aacute;ch mới th&agrave;nh lập l&agrave;\n&rdquo;);<br />\r\n&nbsp; &nbsp; PrintList(l1);<br />\r\n&nbsp; &nbsp; printf(&ldquo;nhập x cần t&igrave;m x=&rdquo;); scanf(&ldquo;%d&rdquo;,&amp;x);<br />\r\n&nbsp;&nbsp;<br />\r\n&nbsp; &nbsp; p = Search(l1,x);<br />\r\n&nbsp; &nbsp; if(p==NULL) printf(&ldquo;kh&ocirc;ng t&igrave;m thấy&rdquo;);<br />\r\n&nbsp; &nbsp; else printf(&ldquo;t&igrave;m thấy&rdquo;);&nbsp;<br />\r\n&nbsp; &nbsp; RemoveHead(l1,x);<br />\r\n&nbsp; &nbsp; printf(&ldquo;danh s&aacute;ch sau khi x&oacute;a\n&rdquo;);<br />\r\n&nbsp; &nbsp; PrintList(l1);<br />\r\n&nbsp; &nbsp; printf(&ldquo;nhập kho&aacute; cần xo&aacute;\n&rdquo;);<br />\r\n&nbsp; &nbsp; scanf(&ldquo;%d&rdquo;,&amp;x);<br />\r\n&nbsp; &nbsp; RemoveX(l1,x);<br />\r\n<br />\r\n&nbsp; &nbsp; printf(&ldquo;danh s&aacute;ch sau khi xo&aacute;&rdquo;);<br />\r\n&nbsp; &nbsp; PrintfList(l1);<br />\r\n&nbsp; &nbsp; SelectionSort(l1);<br />\r\n&nbsp; &nbsp; printf(&ldquo;Danh s&aacute;ch sau khi sắp xếp&rdquo;);<br />\r\n&nbsp; &nbsp; PrintfList(l1);<br />\r\n&nbsp; &nbsp; RemoveList(l1);<br />\r\n}</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 4, 1, NULL),
(120, 'danh sách liên kết kép', '<pre class="brush:cpp;">\r\nCấu tr&uacute;c dữ liệu 1 n&uacute;t  \r\n typedef struct tagDnode  \r\n{   Data Info;  \r\n  struct tagDnode *pPre;  \r\n  struct tagDnode *pNext;  \r\n}DNode;  \r\n  \r\n  \r\nCấu tr&uacute;c List k&eacute;p  \r\nTypedef struct tagDList  \r\n{  DNode *pHead;  \r\n  DNode *pTail;  \r\n}DList;  \r\nvoid CreateDList(DList &amp;l)  \r\n{  \r\n  l.DHead=NULL;  \r\n  l.DTail=NULL;  \r\n}  \r\n  \r\n  \r\n  \r\nTạo 1 N&uacute;t C&oacute; Th&agrave;nh Phần Dữ Liệu = X  \r\nDNode *CreateDNode(int x)  \r\n{ DNode *tam;  \r\n tam=new DNode;  \r\n if(tam==NULL)  \r\n { printf(&quot;khong con du bo nho&quot;);  \r\n  exit(1);  \r\n }  \r\n else  \r\n { tam-&gt;Info=x;  \r\n  tam-&gt;pNext=NULL;  \r\n  tam-&gt;pPre=NULL;  \r\n  return tam;  \r\n }  \r\n}  \r\n  \r\n  \r\nC&agrave;i Đặt Th&ecirc;m 1 N&uacute;t V&agrave;o Đầu Danh S&aacute;ch  \r\nvoid AddFirst(DList &amp;l, DNode *tam)  \r\n{  \r\n if(l.pHead==NULL)//xau rong  \r\n {  \r\n  l.pHead=tam;  \r\n  l.pTail=l.pHead;  \r\n }  \r\n else  \r\n {  \r\n  tam-&gt;pNext=l.pHead;  \r\n  l.pHead-&gt;pPre=tam;  \r\n  l.pHead=tam;  \r\n }  \r\n}  \r\n  \r\n  \r\nC&agrave;i Đặt Th&ecirc;m 1 N&uacute;t V&agrave;o Cuối Danh S&aacute;ch  \r\nvoid AddEnd(DList &amp;l,DNode *tam)  \r\n{  \r\n if(l.pHead==NULL)  \r\n {  \r\n  l.pHead=tam;  \r\n  l.pTail=l.pHead;  \r\n }  \r\n else  \r\n {  \r\n  tam-&gt;pPre=l.pTail;  \r\n  l.pTail-&gt;pNext=tam;  \r\n  tam=l.pTail;  \r\n }  \r\n}  \r\n  \r\n  \r\nC&agrave;i Đặt Th&ecirc;m 1 N&uacute;t V&agrave;o Sau N&uacute;t Q  \r\nvoid AddLastQ(DList &amp;l,DNode *tam, DNode *q)  \r\n{  \r\n DNode *p;  \r\n p=q-&gt;pNext;  \r\n if(q!=NULL)//them vao duoc    \r\n {  \r\n  tam-&gt;pNext=p;  \r\n  tam-&gt;pPre=q;  \r\n  q-&gt;pNext=tam;  \r\n  if(p!=NULL)  \r\n   p-&gt;pPre=tam;  \r\n  if(q==l.pTail) //them vao sau danh sach lien ket.   \r\n   l.pTail=tam;  \r\n }  \r\n else  \r\n  AddFirst(l,tam);  \r\n}  \r\n  \r\n  \r\nC&agrave;i Đặt Th&ecirc;m 1 N&uacute;t V&agrave;o Trước N&uacute;t Q  \r\nvoid AddBeforeQ(DList &amp;l,DNode *tam,DNode *q)  \r\n{ DNode *p;  \r\n p=q-&gt;pPre;  \r\n if(q!=NULL)  \r\n {  \r\n  tam-&gt;pNext=q;  \r\n  q-&gt;pPre=tam;  \r\n  tam-&gt;pPre=p;  \r\n  if(p!=NULL)  \r\n   p-&gt;pNext=tam;  \r\n  if(q==l.pHead)  \r\n   l.pHead = tam;  \r\n }  \r\n else  \r\n  AddEnd(l,tam);  \r\n}  \r\n  \r\n  \r\nXo&aacute; Phần Tử Đầu Danh S&aacute;ch  \r\nvoid DeleteFirst(DList &amp;l)  \r\n{  \r\n DNode *p;  \r\n if(l.pHead!=NULL)  \r\n {  \r\n  p=l.pHead;  \r\n  l.pHead=l.pHead-&gt;pNext;  \r\n  l.pHead-&gt;pPre=NULL;  \r\n  delete p;  \r\n  if(l.pHead==NULL)  \r\n   l.pTail=NULL;  \r\n }  \r\n}  \r\n  \r\n  \r\nXo&aacute; 1 Phần Tử Cuối Danh S&aacute;ch  \r\nvoid DeleteEnd(DList &amp;l )  \r\n{  \r\n DNode *p;  \r\n if(l.pHead!=NULL) //tuc xau co hon mot phan tu    \r\n {  \r\n  p=l.pTail;  \r\n  l.pTail=l.pTail-&gt;Pre;  \r\n  l.pTail-&gt;pNext=NULL;  \r\n  delete p;  \r\n  if(l.pTail==NULL)  \r\n   l.pHead=NULL;  \r\n }  \r\n}  \r\n  \r\n  \r\nHủy 1 N&uacute;t Sau N&uacute;t Q  \r\nvoid DeleteLastQ(DList &amp;l,DNode *q)  \r\n{  \r\n DNode *p;//luu node dung sau node q  \r\n if(q!=NULL)   \r\n {  \r\n  p=q-&gt;pNext;  \r\n  if(p!=NULL)  \r\n  {  \r\n   q-&gt;pNext=p-&gt;pNext;  \r\n   if(p==l.pTail)//xoa dung nu&#39;t cuoi   \r\n    l.pTail=q;  \r\n   else //Nut xoa khong phai nut cuoi  \r\n    p-&gt;pNext-&gt;pPre=q;  \r\n   delete p;  \r\n  }  \r\n }  \r\n else  \r\n  DeleteFirst(l);  \r\n}  \r\n  \r\n  \r\nHuỷ 1 N&uacute;t Đứng Trước N&uacute;t Q  \r\nvoid DeleteBeforeQ(DList &amp;l,DNode *q)  \r\n{  \r\n DNode *p;  \r\n if(q!=NULL) //tuc ton tai node q  \r\n {  \r\n  p=q-&gt;pPre;  \r\n  if(p!=NULL)  \r\n  {  \r\n   q-&gt;pPre=p-&gt;pPre;  \r\n   if(p==l.pHead)//p la Node dau cua danh sach  \r\n    l.pHead=q;  \r\n   else //p khong phai la node dau  \r\n    p-&gt;pPre-&gt;pNext=q;  \r\n   delete p;  \r\n  }  \r\n }  \r\n else  \r\n  DeleteEnd(l);  \r\n}  \r\n  \r\n  \r\nXo&aacute; 1 Phần Tử C&oacute; Kho&aacute; = X  \r\nint DeleteX(DList &amp;l,int x)  \r\n{  \r\n DNode *p;  \r\n DNode *q;  \r\n q=NULL;  \r\n p=l.pHead;  \r\n while(p!=NULL)  \r\n {  \r\n  if(p-&gt;Info==x)    \r\n   break;  \r\n  q=p;//q la Node co truong Info = x  \r\n  p=p-&gt;pNext;  \r\n }  \r\n if(q==NULL) return 0;//khong tim thay Node nao co truong Info =x  \r\n if(q!=NULL)   \r\n  DeleteLastQ(l,q);    \r\n else  \r\n  DeleteFirst(l);  \r\n return 1;  \r\n}  \r\n  \r\n  \r\nSắp Xếp  \r\nvoid DoiChoTrucTiep(DList &amp;l)  \r\n{ DNode *p,*q;  \r\n p=l.pHead;  \r\n while(p!=l.pTail)  \r\n {  \r\n  q=p-&gt;pNext;  \r\n  while(q!=NULL)  \r\n  {  \r\n   if(p-&gt;Info&gt;q-&gt;Info)  \r\n    HV(p,q);  \r\n   q=q-&gt;pNext;  \r\n  }  \r\n  p=p-&gt;pNext;  \r\n }}   </pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 2, 1, NULL),
(121, 'cộng trừ nhân chia đa thức bậc n bất kỳ', '<p>viết chương tr&igrave;nh c/c++ thực hiện định nghĩa đa thức bậ n bất kỳ v&agrave; cộng trừ nh&acirc;n chia tr&ecirc;n đa thức. c&aacute;ch l&agrave;m của To&agrave;n dưới đ&acirc;y l&agrave; d&ugrave;ng danh s&aacute;ch li&ecirc;n kết đ&ocirc;i để l&agrave;m. mỗi node sẽ lưu 1 số hạng gồm 2 th&ocirc;ng tin l&agrave; hệ số v&agrave; số mũ, ngo&agrave;i th&ocirc;ng tin c&ograve;n c&oacute; 2 con trỏ của danh s&aacute;ch li&ecirc;n kết. cộng trừ nh&acirc;n chia đa thức theo kiểu n&agrave;y g&acirc;y kh&oacute; khăn cho lập tr&igrave;nh nhưng chương tr&igrave;nh được tối ưu v&agrave; chạy nhanh.&nbsp;</p>\r\n\r\n<pre class="brush:cpp;">\r\n#include&lt;iostream&gt;  \r\nusing namespace std;  \r\ntypedef struct tagnode  \r\n{  \r\n    float heso,somu;  \r\n    struct tagnode *next,*pre;  \r\n}node;  \r\nnode *taonode(float heso,float somu)  \r\n{  \r\n    node *p=new node;  \r\n    if(p==NULL) exit(1);  \r\n    p-&gt;heso=heso;  \r\n    p-&gt;somu=somu;  \r\n    p-&gt;next=p-&gt;pre=NULL;  \r\n    return p;  \r\n}  \r\ntypedef struct tagdathuc  \r\n{  \r\n    node*dau,*cuoi;  \r\n}dathuc;  \r\nvoid taodathuc(dathuc &amp;l)  \r\n{  \r\n    l.dau=l.cuoi=NULL;  \r\n}  \r\nvoid themcuoi(dathuc &amp;l,node *p)  \r\n{  \r\n    if(l.dau==NULL) l.dau=l.cuoi=p;  \r\n    else  \r\n    {  \r\n        l.cuoi-&gt;next=p;  \r\n        p-&gt;pre=l.cuoi;  \r\n        l.cuoi=p;  \r\n    }  \r\n}  \r\nvoid nhap(dathuc &amp;l)  \r\n{  \r\n    node *p;  \r\n    float heso,somu;  \r\n    cout&lt;&lt;&quot;nhap so da thuc, ket thuc khi nhap he so = 0\n&quot;;  \r\n    do{  \r\n        cout&lt;&lt;&quot;he so = &quot;;cin&gt;&gt;heso;  \r\n        if(heso!=0)  \r\n        {  \r\n            cout&lt;&lt;&quot;so mu = &quot;;cin&gt;&gt;somu;  \r\n            p=taonode(heso,somu);  \r\n            themcuoi(l,p);  \r\n        }  \r\n        cout&lt;&lt;endl;  \r\n    }while(heso!=0);  \r\n}  \r\nvoid xuat(dathuc l)  \r\n{  \r\n    node *p=l.dau;  \r\n    if(p==NULL)  \r\n    {  \r\n        cout&lt;&lt;0;  \r\n        return;  \r\n    }  \r\n    while(p!=NULL)  \r\n    {  \r\n        if(p==l.dau)  \r\n        {  \r\n            if(p-&gt;somu==0)\r\n cout&lt;&lt;p-&gt;heso;  \r\n            else if(fabs(p-&gt;heso)!=1 &amp;&amp; p-&gt;somu!=1) \r\ncout&lt;&lt;p-&gt;heso&lt;&lt;&quot;X^&quot;&lt;&lt;p-&gt;somu;  \r\n            else if(fabs(p-&gt;heso)!=1 &amp;&amp; p-&gt;somu==1) \r\ncout&lt;&lt;p-&gt;heso&lt;&lt;&quot;X&quot;;  \r\n            else if(fabs(p-&gt;heso)==1 &amp;&amp; p-&gt;somu!=1)\r\n cout&lt;&lt;(p-&gt;heso==1?&quot;X^&quot;:&quot;-X^&quot;)&lt;&lt;p-&gt;somu;  \r\n            else cout&lt;&lt;(p-&gt;heso==1?&quot;X&quot;:&quot;-X&quot;);  \r\n        }  \r\n        else  \r\n        {  \r\n            if(p-&gt;somu==0)\r\n cout&lt;&lt;(p-&gt;heso&lt;0?&quot; - &quot;:&quot; + &quot;)&lt;&lt;fabs(p-&gt;heso);  \r\n            else if(fabs(p-&gt;heso)!=1 &amp;&amp; p-&gt;somu!=1) \r\ncout&lt;&lt;(p-&gt;heso&lt;0?&quot; - &quot;:&quot; + &quot;)&lt;&lt;fabs(p-&gt;heso)&lt;&lt;&quot;X^&quot;&lt;&lt;p-&gt;somu;  \r\n            else if(fabs(p-&gt;heso)!=1 &amp;&amp; p-&gt;somu==1) \r\ncout&lt;&lt;(p-&gt;heso&lt;0?&quot; - &quot;:&quot; + &quot;)&lt;&lt;fabs(p-&gt;heso)&lt;&lt;&quot;X&quot;;  \r\n            else if(fabs(p-&gt;heso)==1 &amp;&amp; p-&gt;somu!=1) \r\ncout&lt;&lt;(p-&gt;heso==1?&quot; + X^&quot;:&quot; - X^&quot;)&lt;&lt;p-&gt;somu;  \r\n            else cout&lt;&lt;(p-&gt;heso==1?&quot; + X&quot;:&quot; - X&quot;);  \r\n        }  \r\n        p=p-&gt;next;  \r\n    }  \r\n}  \r\nvoid sapxep(dathuc &amp;l)  \r\n{  \r\n    node *p1=l.dau,*p2;  \r\n    while(p1!=NULL)  \r\n    {  \r\n        p2=p1-&gt;next;  \r\n        while(p2!=NULL)  \r\n        {  \r\n            if(p2-&gt;somu&gt;p1-&gt;somu)  \r\n            {  \r\n                swap(p1-&gt;heso,p2-&gt;heso);  \r\n                swap(p1-&gt;somu,p2-&gt;somu);  \r\n            }  \r\n            p2=p2-&gt;next;  \r\n        }  \r\n        p1=p1-&gt;next;  \r\n    }  \r\n}  \r\nvoid xoatruocQ(dathuc &amp;l,node *Q)  \r\n{  \r\n    node *p;  \r\n    if(Q==NULL)  \r\n    {  \r\n        p=l.cuoi;  \r\n        if(l.dau==l.cuoi)  \r\n        {  \r\n            l.dau=l.cuoi=NULL;  \r\n            delete p;  \r\n        }  \r\n        else if(p!=NULL)  \r\n        {  \r\n            l.cuoi=l.cuoi-&gt;pre;  \r\n            l.cuoi-&gt;next=NULL;  \r\n            delete p;  \r\n        }  \r\n    }  \r\n    else  \r\n    {  \r\n        p=Q-&gt;pre;  \r\n        if(p!=NULL)  \r\n        {  \r\n            if(p==l.dau)  \r\n            {  \r\n                l.dau=l.dau-&gt;next;  \r\n                l.dau-&gt;pre=NULL;  \r\n                delete p;  \r\n            }  \r\n            else  \r\n            {  \r\n                p-&gt;pre-&gt;next=Q;  \r\n                Q-&gt;pre=p-&gt;pre;  \r\n                delete p;  \r\n            }  \r\n        }  \r\n    }  \r\n}  \r\nvoid rutgon(dathuc &amp;l)  \r\n{  \r\n    node *p1=l.dau,*p2;  \r\n    while(p1!=NULL)  \r\n    {  \r\n        p2=p1-&gt;next;  \r\n        while(p2!=NULL)  \r\n        {  \r\n            if(p2-&gt;somu==p1-&gt;somu)  \r\n            {  \r\n                p1-&gt;heso+=p2-&gt;heso;  \r\n                p2=p2-&gt;next;  \r\n                xoatruocQ(l,p2);  \r\n            }  \r\n            else p2=p2-&gt;next;  \r\n        }  \r\n        p1=p1-&gt;next;  \r\n    }  \r\n}  \r\nvoid themtruocQ(dathuc &amp;l,node *Q,node *p)  \r\n{  \r\n    if(Q==l.dau)  \r\n    {  \r\n        l.dau-&gt;pre=p;  \r\n        p-&gt;next=l.dau;  \r\n        l.dau=p;  \r\n    }  \r\n    else  \r\n    {  \r\n        p-&gt;pre=Q-&gt;pre;  \r\n        p-&gt;next=Q;  \r\n        Q-&gt;pre-&gt;next=p;  \r\n        Q-&gt;pre=p;  \r\n    }  \r\n}  \r\nvoid insert(dathuc &amp;l,node *p)  \r\n{  \r\n    node *p1=l.dau;  \r\n    while(p1!=NULL &amp;&amp; p1-&gt;somu &gt; p-&gt;somu) p1=p1-&gt;next;  \r\n    if(p1!=NULL)  \r\n    {  \r\n        if(p1-&gt;somu == p-&gt;somu) p1-&gt;heso += p-&gt;heso;  \r\n        else themtruocQ(l,p1,p);  \r\n    }  \r\n    else themcuoi(l,p);  \r\n}  \r\nvoid xuly(dathuc &amp;l)  \r\n{  \r\n    node *p=l.dau;  \r\n    while(p!=NULL)  \r\n    {  \r\n        if(p-&gt;heso==0)  \r\n        {  \r\n            p=p-&gt;next;  \r\n            xoatruocQ(l,p);  \r\n        }  \r\n        else p=p-&gt;next;  \r\n    }  \r\n}  \r\nint cong(dathuc l1,dathuc l2,dathuc &amp;l)  \r\n{  \r\n    node *p=l1.dau,*a;  \r\n    while(p!=NULL)  \r\n    {  \r\n        a=taonode(p-&gt;heso,p-&gt;somu);  \r\n        themcuoi(l,a);  \r\n        p=p-&gt;next;  \r\n    }  \r\n    p=l2.dau;  \r\n    while(p!=NULL)  \r\n    {  \r\n        a=taonode(p-&gt;heso,p-&gt;somu);  \r\n        insert(l,a);  \r\n        xuly(l);  \r\n        p=p-&gt;next;  \r\n    }  \r\n    xuly(l);  \r\n    if(l.dau==NULL) return 0;  \r\n    return 1;  \r\n}  \r\nint tru(dathuc l1,dathuc l2,dathuc &amp;l)  \r\n{  \r\n    node *p=l2.dau;  \r\n    while(p!=NULL)  \r\n    {  \r\n        p-&gt;heso=-p-&gt;heso;  \r\n        p=p-&gt;next;  \r\n    }  \r\n    cong(l1,l2,l);  \r\n    p=l2.dau;  \r\n    while(p!=NULL)  \r\n    {  \r\n        p-&gt;heso=-p-&gt;heso;  \r\n        p=p-&gt;next;  \r\n    }  \r\n    if(l.dau==NULL) return 0;  \r\n    return 1;  \r\n}  \r\nint nhan(dathuc l1,dathuc l2,dathuc &amp;l)  \r\n{  \r\n    node *p,*p1,*p2;  \r\n    p2=l2.dau;  \r\n    while(p2!=NULL)  \r\n    {  \r\n        p1=l1.dau;  \r\n        while(p1!=NULL)  \r\n        {  \r\n            p=taonode(p2-&gt;heso*p1-&gt;heso,p2-&gt;somu+p1-&gt;somu);  \r\n            insert(l,p);  \r\n            p1=p1-&gt;next;  \r\n        }  \r\n        p2=p2-&gt;next;  \r\n    }  \r\n    xuly(l);  \r\n    if(l.dau==NULL) return 0;  \r\n    return 1;  \r\n}  \r\nvoid xoacuoi(dathuc &amp;l)  \r\n{  \r\n    node *p=l.cuoi;  \r\n    if(p==NULL) exit(1);  \r\n    if(l.dau==l.cuoi)  \r\n    {  \r\n        l.dau=l.cuoi=NULL;  \r\n        delete p;  \r\n    }  \r\n    else  \r\n    {  \r\n        l.cuoi=p-&gt;pre;  \r\n        l.cuoi-&gt;next=NULL;  \r\n        delete p;  \r\n    }  \r\n}  \r\nvoid xoa(dathuc &amp;l)  \r\n{  \r\n    while(l.dau!=NULL) xoacuoi(l);  \r\n}  \r\nvoid chia(dathuc l1,dathuc l2)  \r\n{  \r\n    node *p,*p1;  \r\n    dathuc a,b,du;  \r\n    taodathuc(a);taodathuc(b);taodathuc(du);  \r\n    p1=l1.dau;  \r\n    while(p1!=NULL)  \r\n    {  \r\n        p=taonode(p1-&gt;heso,p1-&gt;somu);  \r\n        themcuoi(du,p);  \r\n        p1=p1-&gt;next;  \r\n    }  \r\n    while(du.dau!=NULL &amp;&amp; du.dau-&gt;somu &gt;= l2.dau-&gt;somu)  \r\n    {  \r\n        p=taonode(du.dau-&gt;heso / l2.dau-&gt;heso,du.dau-&gt;somu - l2.dau-&gt;somu);  \r\n        themcuoi(a,p);  \r\n        xoa(b);  \r\n        if(nhan(l2,a,b)==0) break;  \r\n        xoa(du);  \r\n        if(tru(l1,b,du)==0) break;  \r\n    }  \r\n    xuat(a);  \r\n    if(du.dau!=NULL)  \r\n    {  \r\n        cout&lt;&lt;&quot;\n du &quot;;  \r\n        xuat(du);  \r\n    }  \r\n}  \r\nvoid main()  \r\n{  \r\n    dathuc l1,l2,l;  \r\n    taodathuc(l1);taodathuc(l2);taodathuc(l);  \r\n    nhap(l1);nhap(l2);  \r\n    rutgon(l1);sapxep(l1);  \r\n    cout&lt;&lt;&quot;\nda thuc 1 = &quot;;xuat(l1);cout&lt;&lt;endl;  \r\n    rutgon(l2);sapxep(l2);  \r\n    cout&lt;&lt;&quot;\nda thuc 2 = &quot;;xuat(l2);cout&lt;&lt;endl;  \r\n    int k;  \r\n    cout&lt;&lt;&quot;\n\n1.cong da thuc 1+2&quot;  \r\n        &lt;&lt;&quot;\n2.tru da thuc 1-2&quot;  \r\n        &lt;&lt;&quot;\n3.nhan da thuc 1*2&quot;  \r\n        &lt;&lt;&quot;\n4.chia da thuc 1/2\n&quot;;  \r\n    cin&gt;&gt;k;  \r\n    cout&lt;&lt;&quot;ket qua = &quot;;  \r\n    switch(k)  \r\n    {  \r\n    case 1:cong(l1,l2,l);xuat(l);break;  \r\n    case 2:tru(l1,l2,l);xuat(l);break;  \r\n    case 3:nhan(l1,l2,l);xuat(l);break;  \r\n    case 4:chia(l1,l2);break;  \r\n    }  \r\n    cout&lt;&lt;endl;  \r\n    system(&quot;pause&quot;);  \r\n}  </pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 2, 1, NULL);
INSERT INTO `baiviet` (`idbv`, `subject`, `content`, `image_bv`, `parent`, `date_add`, `views`, `author`, `des`) VALUES
(122, 'cộng trừ nhân chia số nguyên lớn không giới hạn', '<p>viết chương tr&igrave;nh định nghĩa kiểu số nguy&ecirc;n lớn kh&ocirc;ng giới hạn, lập tr&igrave;nh thực hiện c&aacute;c ph&eacute;p to&aacute;n c&ocirc;ng (+) trừ (-) nh&acirc;n (*) chia (/) c&aacute;c số nguy&ecirc;n lớn đ&oacute;. th&ocirc;ng thường ta thấy c&aacute;c kiểu float, int c&oacute; giới hạn của n&oacute;, khi vượt qu&aacute; giớ hạn th&igrave; b&aacute;o lỗi hoặc cho kết quả sai, sau khi học qua danh s&aacute;ch li&ecirc;n kết th&igrave; t c&oacute; thực hiện b&agrave;i tập giải quyết số nguy&ecirc;n lớn kh&ocirc;ng giới hạn, định nghĩa v&agrave; thiết kế thuật to&aacute;n c&ocirc;ng trừ nh&acirc;n chia c&aacute;c số nguy&ecirc;n lớn đ&oacute;. dưới đ&acirc;y l&agrave; code của chương tr&igrave;nh đ&oacute;, tuy nhi&ecirc;n t kh&ocirc;ng viết ch&uacute; th&iacute;ch n&ecirc;n c&oacute; phần kh&oacute;. d&atilde; học qua danh s&aacute;ch li&ecirc;n kết v&agrave; năm r&otilde; về n&oacute; th&igrave; sẽ dễ đọc code hơn. mỗi node trong danh s&aacute;ch sẽ lưu 1 chữ s&oacute; của số nguy&ecirc;n lớn, 1 biến kiểu char trong danh s&aacute;ch để lưu dấu ccủa số l&agrave; dương hay &acirc;m. gi&aacute; trị của mỗi node trong danh s&aacute;ch theo thứ tự từ đầu đến cuối l&agrave; gi&aacute; trị c&aacute;c chữ số của số nguy&ecirc;n lớn. do đ&oacute; khi c&ocirc;ng trừ nh&acirc;n chia, ta duyệt từng node trong danh s&aacute;ch l&agrave; tiến h&agrave;nh t&iacute;nh to&aacute;n tr&ecirc;n đ&oacute;, cộng trừ nh&acirc;n th&igrave; thực hiện từ cuối l&ecirc;n đầu, c&ograve;n chia th&igrave; thực hiện duyệt từ đầu đến cuối&nbsp;</p>\r\n\r\n<pre class="brush:cpp;">\r\n#include&lt;iostream&gt;  \r\n#include&lt;string&gt;  \r\n#include&lt;Windows.h&gt;  \r\nusing namespace std;  \r\ntypedef struct tagnode  \r\n{  \r\n    int x;  \r\n    struct tagnode *next;  \r\n    struct tagnode *pre;  \r\n}node;  \r\ntypedef struct tagsolon  \r\n{  \r\n    char c;  \r\n    node *dau;  \r\n    node *cuoi;  \r\n}solon;  \r\nvoid xuat(solon n);  \r\nvoid taosolon(solon &amp;n);  \r\nnode *taonode(int x);  \r\nvoid themdau(solon &amp;n,node *p);  \r\nvoid nhap(solon &amp;n);  \r\nvoid cong(solon n1,solon n2,solon &amp;n);  \r\nvoid tru(solon n1,solon n2,solon &amp;n);  \r\nint sosanh(solon n1,solon n2);  \r\nvoid nhan(solon n1,solon n2,solon &amp;n);  \r\nvoid nhan1so(solon n1,int x,solon &amp;n);  \r\nvoid themcuoi(solon &amp;n,node *p);  \r\nvoid xoa(solon &amp;n);  \r\nvoid xoatruocQ(solon &amp;n,node *Q);  \r\nvoid xoacuoi(solon &amp;n);  \r\nvoid chia(solon n1,solon n2,solon &amp;n);  \r\nvoid xuly(solon &amp;n);  \r\n  \r\nvoid main()  \r\n{  \r\n    solon n,n1,n2;  \r\n    taosolon(n);taosolon(n1);taosolon(n2);  \r\n    cout&lt;&lt;&quot;nhap 2 so nguyen:\n&quot;;  \r\n    cout&lt;&lt;&quot;a=&quot;;nhap(n1);  \r\n    cout&lt;&lt;&quot;b=&quot;;nhap(n2);  \r\n    cout&lt;&lt;&quot;\n1.cong.&quot;  \r\n        &lt;&lt;&quot;\n2.tru.&quot;  \r\n        &lt;&lt;&quot;\n3.nhan.&quot;  \r\n        &lt;&lt;&quot;\n4.chia.\n\n&quot;;  \r\n    int k;  \r\n    cin&gt;&gt;k;  \r\n    switch(k)  \r\n    {  \r\n    case 1:cong(n1,n2,n);cout&lt;&lt;&quot;a+b = &quot;;xuat(n);cout&lt;&lt;endl;break;  \r\n    case 2:tru(n1,n2,n);cout&lt;&lt;&quot;a-b = &quot;;xuat(n);cout&lt;&lt;endl;break;  \r\n    case 3:nhan(n1,n2,n);cout&lt;&lt;&quot;a*b = &quot;;xuat(n);cout&lt;&lt;endl;break;  \r\n    case 4:chia(n1,n2,n);break;  \r\n    }  \r\n    system(&quot;pause&quot;);  \r\n}  \r\n  \r\n  \r\nvoid chia(solon n1,solon n2,solon &amp;n)  \r\n{  \r\n    if(n1.c==n2.c) n.c=&#39;+&#39;;  \r\n    else n.c=&#39;-&#39;;  \r\n    int q=sosanh(n1,n2);  \r\n    if(q&lt;0)  \r\n    {  \r\n        cout&lt;&lt;&quot;ket qua = 0 \ndu &quot;;xuat(n1);  \r\n    }  \r\n    else if(q==0) cout&lt;&lt;&quot;ket qua = 1&quot;;  \r\n    else  \r\n    {  \r\n        int i;  \r\n        solon a;taosolon(a);  \r\n        solon b;taosolon(b);  \r\n        solon c;taosolon(c);  \r\n        node *p,*p2,*p1;  \r\n        p1=n1.dau;  \r\n        p2=n2.dau;  \r\n        while(p2!=NULL)  \r\n        {  \r\n            p=taonode(p1-&gt;x);  \r\n            themcuoi(a,p);  \r\n            p1=p1-&gt;next;  \r\n            p2=p2-&gt;next;  \r\n        }  \r\n        while(p1!=NULL)  \r\n        {  \r\n            q=sosanh(a,n2);  \r\n            if(q&lt;0)  \r\n            {  \r\n                p=taonode(0);  \r\n                themcuoi(n,p);  \r\n                p=taonode(p1-&gt;x);  \r\n                themcuoi(a,p);  \r\n            }  \r\n            else if(q==0)  \r\n            {  \r\n                p=taonode(1);  \r\n                themcuoi(n,p);  \r\n                xoa(a);  \r\n                p=taonode(p1-&gt;x);  \r\n                themcuoi(a,p);  \r\n            }  \r\n            else  \r\n            {  \r\n                for(i=1;i&lt;=9;i++)  \r\n                {  \r\n                    xoa(b);  \r\n                    nhan1so(n2,i,b);  \r\n                    q=sosanh(a,b);  \r\n                    if(q&lt;0)  \r\n                    {  \r\n                        xoa(b);  \r\n                        nhan1so(n2,i-1,b);  \r\n                        break;  \r\n                    }  \r\n                }  \r\n                i--;  \r\n                p=taonode(i);  \r\n                themcuoi(n,p);  \r\n                xoa(c);  \r\n                tru(a,b,c);  \r\n                xoa(a);  \r\n                p2=c.dau;  \r\n                while(p2!=NULL)  \r\n                {  \r\n                    p=taonode(p2-&gt;x);  \r\n                    themcuoi(a,p);  \r\n                    p2=p2-&gt;next;  \r\n                }  \r\n                p=taonode(p1-&gt;x);  \r\n                themcuoi(a,p);  \r\n            }  \r\n            if(p1!=NULL)p1=p1-&gt;next;  \r\n        }  \r\n        // thuc hien 1 lan nua  \r\n        q=sosanh(a,n2);  \r\n        if(q&lt;0)  \r\n        {  \r\n            p=taonode(0);  \r\n            themcuoi(n,p);  \r\n        }  \r\n        else if(q==0)  \r\n        {  \r\n            p=taonode(1);  \r\n            themcuoi(n,p);  \r\n        }  \r\n        else  \r\n        {  \r\n            for(i=1;i&lt;=9;i++)  \r\n            {  \r\n                xoa(b);  \r\n                nhan1so(n2,i,b);  \r\n                q=sosanh(a,b);  \r\n                if(q&lt;0)  \r\n                {  \r\n                    xoa(b);  \r\n                    nhan1so(n2,i-1,b);  \r\n                    break;  \r\n                }  \r\n            }  \r\n            i--;  \r\n            p=taonode(i);  \r\n            themcuoi(n,p);  \r\n            xoa(c);  \r\n            tru(a,b,c);  \r\n            xoa(a);  \r\n            p2=c.dau;  \r\n            while(p2!=NULL)  \r\n            {  \r\n                p=taonode(p2-&gt;x);  \r\n                themcuoi(a,p);  \r\n                p2=p2-&gt;next;  \r\n            }  \r\n        }  \r\n        if(p1!=NULL)p1=p1-&gt;next;  \r\n        //end  \r\n        xuly(n);xuly(a);  \r\n        cout&lt;&lt;&quot;a/b = &quot;;xuat(n);cout&lt;&lt;endl;  \r\n        if(a.dau!=NULL)  \r\n        {  \r\n            cout&lt;&lt;&quot;du &quot;;  \r\n            xuat(a);  \r\n            cout&lt;&lt;endl;  \r\n        }  \r\n    }  \r\n}  \r\nvoid xoatruocQ(solon &amp;n,node *Q)  \r\n{  \r\n    if(Q==NULL) xoacuoi(n);  \r\n    else  \r\n    {  \r\n        node *p=Q-&gt;pre;  \r\n        if(p!=NULL)  \r\n        {  \r\n            if(p==n.dau)  \r\n            {  \r\n                n.dau=Q;  \r\n                n.dau-&gt;pre=NULL;  \r\n                delete p;  \r\n            }  \r\n            else  \r\n            {  \r\n                p-&gt;pre-&gt;next=Q;  \r\n                Q-&gt;pre=p-&gt;pre;  \r\n                delete p;  \r\n            }  \r\n        }  \r\n    }  \r\n}  \r\nvoid xuly(solon &amp;n)  \r\n{  \r\n    node *p=n.dau;  \r\n    while(p!=NULL &amp;&amp; p-&gt;x==0)  \r\n    {  \r\n        p=p-&gt;next;  \r\n        xoatruocQ(n,p);  \r\n    }  \r\n}  \r\nvoid nhan(solon n1,solon n2,solon &amp;n)  \r\n{  \r\n    node *p,*p1,*p2;  \r\n    long long i,dem=0;  \r\n    solon a;taosolon(a);  \r\n    solon b;taosolon(b);  \r\n    p=n2.cuoi;  \r\n    while(p!=NULL)  \r\n    {  \r\n        xoa(a);  \r\n        nhan1so(n1,p-&gt;x,a);  \r\n        for(i=0;i&lt;dem;i++)  \r\n        {  \r\n            p1=taonode(0);  \r\n            themcuoi(a,p1);  \r\n        }  \r\n        xoa(b);  \r\n        p2=n.cuoi;  \r\n        while(p2!=NULL)  \r\n        {  \r\n            p1=taonode(p2-&gt;x);  \r\n            themdau(b,p1);  \r\n            p2=p2-&gt;pre;  \r\n        }  \r\n        xoa(n);  \r\n        cong(a,b,n);  \r\n        p=p-&gt;pre;  \r\n        dem++;  \r\n    }  \r\n    if(n1.c==n2.c) n.c=&#39;+&#39;;  \r\n    else n.c=&#39;-&#39;;  \r\n    xuly(n);  \r\n}  \r\nvoid xoa(solon &amp;n)  \r\n{  \r\n    while(n.dau!=NULL) xoacuoi(n);  \r\n}  \r\nvoid xoacuoi(solon &amp;n)  \r\n{  \r\n    node *p=n.cuoi;  \r\n    if(p!=NULL)  \r\n    {  \r\n        if(n.dau==n.cuoi)  \r\n        {  \r\n            n.dau=n.cuoi=NULL;  \r\n            delete p;  \r\n        }  \r\n        else  \r\n        {  \r\n            n.cuoi=p-&gt;pre;  \r\n            n.cuoi-&gt;next=NULL;  \r\n            delete p;  \r\n        }  \r\n    }  \r\n}  \r\nvoid themcuoi(solon &amp;n,node *p)  \r\n{  \r\n    if(n.dau==NULL)n.dau=n.cuoi=p;  \r\n    else  \r\n    {  \r\n        n.cuoi-&gt;next=p;  \r\n        p-&gt;pre=n.cuoi;  \r\n        n.cuoi=p;  \r\n    }  \r\n}  \r\nvoid nhan1so(solon n1,int x,solon &amp;n)  \r\n{  \r\n    node *p1,*p;  \r\n    int k,m=0;  \r\n    p1=n1.cuoi;  \r\n    while(p1!=NULL)  \r\n    {  \r\n        k=p1-&gt;x*x+m;  \r\n        if(k&gt;=10)  \r\n        {  \r\n            m=k/10;  \r\n            k=k%10;  \r\n        }  \r\n        else m=0;  \r\n        p=taonode(k);  \r\n        themdau(n,p);  \r\n        p1=p1-&gt;pre;  \r\n    }  \r\n    if(m&gt;0)  \r\n    {  \r\n        p=taonode(m);  \r\n        themdau(n,p);  \r\n    }  \r\n}  \r\nvoid tru(solon n1,solon n2,solon &amp;n)  \r\n{  \r\n    int q=sosanh(n1,n2);  \r\n    int k,m;  \r\n    node *p,*p1,*p2;  \r\n    if(q==0) return;  \r\n    if(n1.c==&#39;+&#39; &amp;&amp; n2.c==&#39;+&#39;)  \r\n    {  \r\n        if(q&gt;0)  \r\n        {  \r\n            m=0;n.c=&#39;+&#39;;  \r\n            p1=n1.cuoi;p2=n2.cuoi;  \r\n            while(p1!=NULL &amp;&amp; p2!=NULL)  \r\n            {  \r\n                if(p1-&gt;x &lt; (p2-&gt;x + m))  \r\n                {  \r\n                    k=10+p1-&gt;x-p2-&gt;x-m;  \r\n                    m=1;  \r\n                }  \r\n                else  \r\n                {  \r\n                    k=p1-&gt;x-p2-&gt;x-m;  \r\n                    m=0;  \r\n                }  \r\n                p=taonode(k);  \r\n                themdau(n,p);  \r\n                p1=p1-&gt;pre;  \r\n                p2=p2-&gt;pre;  \r\n            }  \r\n            while(p1!=NULL)  \r\n            {  \r\n                if(p1-&gt;x &lt; m)  \r\n                {  \r\n                    k=10+p1-&gt;x-m;  \r\n                    m=1;  \r\n                }  \r\n                else  \r\n                {  \r\n                    k=p1-&gt;x-m;  \r\n                    m=0;  \r\n                }  \r\n                p=taonode(k);  \r\n                themdau(n,p);  \r\n                p1=p1-&gt;pre;  \r\n            }  \r\n        }  \r\n        else  \r\n        {  \r\n            m=0;n.c=&#39;-&#39;;  \r\n            p1=n1.cuoi;p2=n2.cuoi;  \r\n            while(p1!=NULL &amp;&amp; p2!=NULL)  \r\n            {  \r\n                if(p2-&gt;x &lt; (p1-&gt;x + m))  \r\n                {  \r\n                    k=10+p2-&gt;x-p1-&gt;x-m;  \r\n                    m=1;  \r\n                }  \r\n                else  \r\n                {  \r\n                    k=p2-&gt;x-p1-&gt;x-m;  \r\n                    m=0;  \r\n                }  \r\n                p=taonode(k);  \r\n                themdau(n,p);  \r\n                p2=p2-&gt;pre;  \r\n                p1=p1-&gt;pre;  \r\n            }  \r\n            while(p2!=NULL)  \r\n            {  \r\n                if(p2-&gt;x &lt; m)  \r\n                {  \r\n                    k=10+p2-&gt;x-m;  \r\n                    m=1;  \r\n                }  \r\n                else  \r\n                {  \r\n                    k=p2-&gt;x-m;  \r\n                    m=0;  \r\n                }  \r\n                p=taonode(k);  \r\n                themdau(n,p);  \r\n                p2=p2-&gt;pre;  \r\n            }  \r\n        }  \r\n    }  \r\n    else if(n1.c==&#39;-&#39; &amp;&amp; n2.c==&#39;-&#39;)  \r\n    {  \r\n        if(q&gt;0)  \r\n        {  \r\n            m=0;n.c=&#39;-&#39;;  \r\n            p1=n1.cuoi;p2=n2.cuoi;  \r\n            while(p1!=NULL &amp;&amp; p2!=NULL)  \r\n            {  \r\n                if(p1-&gt;x &lt; (p2-&gt;x + m))  \r\n                {  \r\n                    k=10+p1-&gt;x-p2-&gt;x-m;  \r\n                    m=1;  \r\n                }  \r\n                else  \r\n                {  \r\n                    k=p1-&gt;x-p2-&gt;x-m;  \r\n                    m=0;  \r\n                }  \r\n                p=taonode(k);  \r\n                themdau(n,p);  \r\n                p1=p1-&gt;pre;  \r\n                p2=p2-&gt;pre;  \r\n            }  \r\n            while(p1!=NULL)  \r\n            {  \r\n                if(p1-&gt;x &lt; m)  \r\n                {  \r\n                    k=10+p1-&gt;x-m;  \r\n                    m=1;  \r\n                }  \r\n                else  \r\n                {  \r\n                    k=p1-&gt;x-m;  \r\n                    m=0;  \r\n                }  \r\n                p=taonode(k);  \r\n                themdau(n,p);  \r\n                p1=p1-&gt;pre;  \r\n            }  \r\n        }  \r\n        else  \r\n        {  \r\n            m=0;n.c=&#39;+&#39;;  \r\n            p1=n1.cuoi;p2=n2.cuoi;  \r\n            while(p1!=NULL &amp;&amp; p2!=NULL)  \r\n            {  \r\n                if(p2-&gt;x &lt; (p1-&gt;x + m))  \r\n                {  \r\n                    k=10+p2-&gt;x-p1-&gt;x-m;  \r\n                    m=1;  \r\n                }  \r\n                else  \r\n                {  \r\n                    k=p2-&gt;x-p1-&gt;x-m;  \r\n                    m=0;  \r\n                }  \r\n                p=taonode(k);  \r\n                themdau(n,p);  \r\n                p2=p2-&gt;pre;  \r\n                p1=p1-&gt;pre;  \r\n            }  \r\n            while(p2!=NULL)  \r\n            {  \r\n                if(p2-&gt;x &lt; m)  \r\n                {  \r\n                    k=10+p2-&gt;x-m;  \r\n                    m=1;  \r\n                }  \r\n                else  \r\n                {  \r\n                    k=p2-&gt;x-m;  \r\n                    m=0;  \r\n                }  \r\n                p=taonode(k);  \r\n                themdau(n,p);  \r\n                p2=p2-&gt;pre;  \r\n            }  \r\n        }  \r\n    }  \r\n    else if(n1.c==&#39;+&#39; &amp;&amp; n2.c==&#39;-&#39;)  \r\n    {  \r\n        n2.c=&#39;+&#39;;  \r\n        cong(n1,n2,n);  \r\n    }  \r\n    else if(n1.c==&#39;-&#39; &amp;&amp; n2.c==&#39;+&#39;)  \r\n    {  \r\n        n2.c=&#39;-&#39;;  \r\n        cong(n1,n2,n);  \r\n    }  \r\n    xuly(n);  \r\n}  \r\nvoid cong(solon n1,solon n2,solon &amp;n)  \r\n{  \r\n    if(n1.c==n2.c)  \r\n    {  \r\n        n.c=n1.c;  \r\n        int k,m=0;  \r\n        node *p1=n1.cuoi,*p2=n2.cuoi,*p;  \r\n        while(p1!=NULL &amp;&amp; p2!=NULL)  \r\n        {  \r\n            k=p1-&gt;x+p2-&gt;x+m;  \r\n            if(k&gt;=10)  \r\n            {  \r\n                m=k/10;  \r\n                k=k%10;  \r\n            }  \r\n            else m=0;  \r\n            p=taonode(k);  \r\n            themdau(n,p);  \r\n            p1=p1-&gt;pre;  \r\n            p2=p2-&gt;pre;  \r\n        }  \r\n        while(p1!=NULL)  \r\n        {  \r\n            k=p1-&gt;x+m;  \r\n            if(k&gt;=10)  \r\n            {  \r\n                m=k/10;  \r\n                k=k%10;  \r\n            }  \r\n            else m=0;  \r\n            p=taonode(k);  \r\n            themdau(n,p);  \r\n            p1=p1-&gt;pre;  \r\n        }  \r\n        while(p1!=NULL)  \r\n        {  \r\n            k=p1-&gt;x+m;  \r\n            if(k&gt;=10)  \r\n            {  \r\n                m=k/10;  \r\n                k=k%10;  \r\n            }  \r\n            else m=0;  \r\n            p=taonode(k);  \r\n            themdau(n,p);  \r\n            p1=p1-&gt;pre;  \r\n        }  \r\n        if(m&gt;0)  \r\n        {  \r\n            p=taonode(m);  \r\n            themdau(n,p);  \r\n        }  \r\n  \r\n    }  \r\n    else if(n1.c==&#39;+&#39; &amp;&amp; n2.c==&#39;-&#39;)  \r\n    {  \r\n        n2.c=&#39;+&#39;;  \r\n        tru(n1,n2,n);  \r\n    }  \r\n    else  \r\n    {  \r\n        n1.c=&#39;+&#39;;  \r\n        tru(n2,n1,n);  \r\n    }  \r\n    xuly(n);  \r\n}  \r\nint sosanh(solon n1,solon n2)  \r\n{  \r\n    node *p1=n1.cuoi,*p2=n2.cuoi;  \r\n    while(p1!=NULL &amp;&amp; p2!=NULL)  \r\n    {  \r\n        p1=p1-&gt;pre;  \r\n        p2=p2-&gt;pre;  \r\n    }  \r\n    if(p1==NULL &amp;&amp; p2!=NULL) return -1;  \r\n    if(p1!=NULL &amp;&amp; p2==NULL) return 1;  \r\n    if(p1==NULL &amp;&amp; p2==NULL)  \r\n    {  \r\n        p1=n1.dau;  \r\n        p2=n2.dau;  \r\n        while(p1!=NULL &amp;&amp; p2!=NULL)  \r\n        {  \r\n            if(p1-&gt;x &gt; p2-&gt;x) return 1;  \r\n            if(p1-&gt;x &lt; p2-&gt;x) return -1;  \r\n            p1=p1-&gt;next;  \r\n            p2=p2-&gt;next;  \r\n        }  \r\n        return 0;  \r\n    }  \r\n}  \r\nvoid xuat(solon n)  \r\n{  \r\n    node *p=n.dau;  \r\n    if(p==NULL)  \r\n    {  \r\n        cout&lt;&lt;0;  \r\n        return;  \r\n    }  \r\n    if(p!=NULL &amp;&amp; n.c==&#39;-&#39;) cout&lt;&lt;n.c;  \r\n    while(p!=NULL)  \r\n    {  \r\n        cout&lt;&lt;p-&gt;x;  \r\n        p=p-&gt;next;  \r\n    }  \r\n}  \r\nvoid taosolon(solon &amp;n)  \r\n{  \r\n    n.c=&#39;+&#39;;  \r\n    n.dau=n.cuoi=NULL;  \r\n}  \r\nnode *taonode(int x)  \r\n{  \r\n    node *p=new node;  \r\n    if(p==NULL) exit(1);  \r\n    p-&gt;x=x;  \r\n    p-&gt;next=p-&gt;pre=NULL;  \r\n    return p;  \r\n}  \r\nvoid themdau(solon &amp;n,node *p)  \r\n{  \r\n    if(n.dau==NULL) n.dau=n.cuoi=p;  \r\n    else  \r\n    {  \r\n        p-&gt;next=n.dau;  \r\n        n.dau-&gt;pre=p;  \r\n        n.dau=p;  \r\n    }  \r\n}  \r\nvoid nhap(solon &amp;n)  \r\n{  \r\n    string s;  \r\n    node *p;  \r\n    long long i,j=0;  \r\n    getline(cin,s);  \r\n    if(s[0]==&#39;-&#39;)  \r\n    {  \r\n        n.c=&#39;-&#39;;  \r\n        j=1;  \r\n    }  \r\n    else if(s[0]==&#39;+&#39;)  \r\n    {  \r\n        n.c=&#39;+&#39;;  \r\n        j=1;  \r\n    }  \r\n    else n.c=&#39;+&#39;;  \r\n    for(i=s.size()-1;i&gt;=j;i--)  \r\n    {  \r\n        switch(s[i])  \r\n        {  \r\n        case &#39;0&#39;:p=taonode(0);break;  \r\n        case &#39;1&#39;:p=taonode(1);break;  \r\n        case &#39;2&#39;:p=taonode(2);break;  \r\n        case &#39;3&#39;:p=taonode(3);break;  \r\n        case &#39;4&#39;:p=taonode(4);break;  \r\n        case &#39;5&#39;:p=taonode(5);break;  \r\n        case &#39;6&#39;:p=taonode(6);break;  \r\n        case &#39;7&#39;:p=taonode(7);break;  \r\n        case &#39;8&#39;:p=taonode(8);break;  \r\n        case &#39;9&#39;:p=taonode(9);break;  \r\n        }  \r\n        themdau(n,p);  \r\n    }  \r\n}  </pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 3, 1, NULL),
(123, 'tính giá trị biểu thức bằng cây nhị phân', '<p>lập tr&igrave;nh c++ tr&iacute;nh&nbsp;<strong>gi&aacute; trị biểu thức</strong>&nbsp;to&aacute;n học gồm số nguy&ecirc;n, dấu ngoặc (), ph&eacute;p to&aacute;n +-*/ bằng phương ph&aacute;p&nbsp;<strong>c&acirc;y nhị ph&acirc;n</strong>.&nbsp;</p>\r\n\r\n<pre class="brush:cpp;">\r\n#include&lt;iostream&gt;  \r\n#include&lt;string&gt;  \r\nusing namespace std;  \r\ntypedef struct tagnode  \r\n{  \r\n     string s;  \r\n     struct tagnode *left;  \r\n     struct tagnode *right;  \r\n}node;  \r\nnode *taonode(string s)  \r\n{  \r\n     node *p=new node;  \r\n     if(p==NULL)  \r\n     {  \r\n          cout&lt;&lt;&quot;khong du bo nho&quot;;  \r\n          system(&quot;pause&quot;);  \r\n          exit(1);  \r\n     }  \r\n     p-&gt;s=s;  \r\n     p-&gt;left=p-&gt;right=NULL;  \r\n     return p;  \r\n}  \r\ntypedef node *cay;  \r\nvoid taocay(cay &amp;t)  \r\n{  \r\n     t=NULL;  \r\n}  \r\nint vitridau(string s,int j)  \r\n{  \r\n     for(int i=j+1;i&lt;s.size();i++)  \r\n          if(s[i]==&#39;+&#39; || s[i]==&#39;-&#39; || s[i]==&#39;*&#39; || s[i]==&#39;/&#39; || s[i]==&#39;(&#39;)  \r\n               return i;  \r\n     return -1;  \r\n}  \r\nint timngoac(string s,int i)  \r\n{  \r\n     int j,dem=1;  \r\n     for(j=i+1;j&lt;s.size();j++)  \r\n     {  \r\n          if(s[j]==&#39;(&#39;) dem++;  \r\n          else if(s[j]==&#39;)&#39;) dem--;  \r\n          if(dem==0) return j;  \r\n     }  \r\n     return -1;  \r\n}  \r\nvoid xulyngoac(string &amp;s)  \r\n{  \r\n     if(s[0]==&#39;(&#39;)  \r\n     {  \r\n          int i=timngoac(s,0);  \r\n          if(i==s.size()-1)  \r\n          {  \r\n               s.erase(0,1);  \r\n               s.erase(s.size()-1,1);  \r\n          }  \r\n     }  \r\n}  \r\nvoid doidau(string &amp;c)  \r\n{  \r\n     int x=0;  \r\n     do{  \r\n          x=vitridau(c,x);  \r\n          if(x!=-1)  \r\n          {  \r\n               if(c[x]==&#39;(&#39;) x=timngoac(c,x);  \r\n               else if(c[x]==&#39;-&#39; &amp;&amp; c[x-1]!=&#39;*&#39; &amp;&amp; c[x-1]!=&#39;/&#39;) c[x]=&#39;+&#39;;  \r\n               else if(c[x]==&#39;+&#39; &amp;&amp; c[x-1]!=&#39;*&#39; &amp;&amp; c[x-1]!=&#39;/&#39;) c[x]=&#39;-&#39;;  \r\n               //chỉ đổi dấu + th&agrave;nh - v&agrave; dấu - \r\n//th&agrave;nh cộng khi n&oacute; l&agrave; dấu của 1 số hạng  \r\n               //nếu n&oacute; dấu của 1 thừa số th&igrave; dữ nguy&ecirc;n \r\n//kh&ocirc;ng thay đổi g&igrave; cả mặc d&ugrave;  \r\n               //dấu của node của c&acirc;y tức s[i] l&agrave;\r\n// dấu - v&igrave; dấu của thừa số kh&ocirc;ng li&ecirc;n quan đến số hạng  \r\n          }  \r\n     }while(x!=-1);  \r\n}  \r\nnode *setcay(string s)  \r\n{  \r\n     xulyngoac(s);  \r\n     node *p;  \r\n     int k,j,x;  \r\n     string a,b,c;  \r\n     int i=vitridau(s,0);//t&igrave;m vị tr&iacute; dấu đầu ti&ecirc;n \r\n//trong biểu thức, c&oacute; 2 trường hợp, c&oacute; dấu v&agrave; kh&ocirc;ng c&oacute; dấu  \r\n     if(s[0]==&#39;(&#39;) i=0;  \r\n     if(i==-1)// trường hợp kh&ocirc;ng c&oacute; dấu  \r\n     {  \r\n          p=taonode(s);  \r\n          return p;  \r\n     }  \r\n     else//trường hợp c&oacute; dấu, c&oacute; 3 trường hợp nhỏ  \r\n     {  \r\n          if(s[i]==&#39;+&#39; || s[i]==&#39;-&#39;)// dấu + hoặc -  \r\n          {  \r\n               a=s[i];  \r\n               p=taonode(a);  \r\n               b=s.substr(0,i);  \r\n               xulyngoac(b);  \r\n               c=s.substr(i+1,s.size()-i-1);  \r\n               xulyngoac(c);  \r\n               //đổi dấu c&aacute;c số hạng ph&iacute;a sau nếu s[i] l&agrave; dấu -  \r\n               if(s[i]==&#39;-&#39;) doidau(c);  \r\n               p-&gt;left=setcay(b);  \r\n               p-&gt;right=setcay(c);  \r\n          }  \r\n          else if(s[i]==&#39;*&#39; || s[i]==&#39;/&#39;)//dấu * hoặc /  \r\n          {  \r\n               k=i;  \r\n               //t&igrave;m vị tr&iacute; dấu + hoặc - ph&iacute;a sau dấu\r\n//ngoặc nhưng nằm ngo&agrave;i dấu ngoặc  \r\n               do{  \r\n                    k=vitridau(s,k);  \r\n                    if(k!=-1)  \r\n                    {  \r\n                         if(s[k]==&#39;(&#39;) k=timngoac(s,k);  \r\n                         if(k&gt;0 &amp;&amp; (s[k]==&#39;+&#39; || s[k]==&#39;-&#39;) &amp;&amp; (s[k-1]!=&#39;*&#39; &amp;&amp; s[k-1]!=&#39;/&#39;)) break;  \r\n                    }  \r\n               }while(k!=-1);  \r\n               if(k==-1)//nếu kh&ocirc;ng c&oacute; th&igrave; node sẽ\r\n// l&agrave; dấu * hoặc / tại vị tr&iacute; i ban đầu  \r\n               {  \r\n                    a=s[i];  \r\n                    p=taonode(a);  \r\n                    b=s.substr(0,i);  \r\n                    xulyngoac(b);  \r\n                    c=s.substr(i+1,s.size()-i-1);  \r\n                    xulyngoac(c);  \r\n                    p-&gt;left=setcay(b);  \r\n                    p-&gt;right=setcay(c);  \r\n               }  \r\n               else//nếu t&igrave;m thấy th&igrave; node l&agrave; dấu t&igrave;m thấy  \r\n               {  \r\n                    a=s[k];  \r\n                    p=taonode(a);  \r\n                    b=s.substr(0,k);  \r\n                    xulyngoac(b);  \r\n                    c=s.substr(k+1,s.size()-k-1);  \r\n                    xulyngoac(c);  \r\n                    //doi dau +-  \r\n                    if(s[k]==&#39;-&#39;) doidau(c);  \r\n                    p-&gt;left=setcay(b);  \r\n                    p-&gt;right=setcay(c);  \r\n               }  \r\n          }  \r\n          else if(s[i]==&#39;(&#39;)//dấu mở ngoặc (  \r\n          {  \r\n               j=timngoac(s,i);//t&igrave;m vị tr&iacute; dấu đ&oacute;ng ngoặc  \r\n                 \r\n               if(s[j+1]==&#39;+&#39; || s[j+1]==&#39;-&#39;)//sau dấu đ&oacute;ng ngoặc\r\n// l&agrave; dấu + hoặc - th&igrave; node l&agrave; dấu + hoặc -  \r\n               {  \r\n                    a=s[j+1];  \r\n                    p=taonode(a);  \r\n                    b=s.substr(0,j+1);  \r\n                    xulyngoac(b);  \r\n                    c=s.substr(j+2,s.size()-j-2);  \r\n                    xulyngoac(c);  \r\n                    //doi dau +-  \r\n                    if(s[j+1]==&#39;-&#39;) doidau(c);  \r\n                    p-&gt;left=setcay(b);  \r\n                    p-&gt;right=setcay(c);  \r\n               }  \r\n               else if(s[j+1]==&#39;*&#39; || s[j+1]==&#39;/&#39;)//nếu sau đ&oacute;ng ngoặc l&agrave; * hoặc /  \r\n               {  \r\n                    k=j+1;  \r\n                    //tiếp tục t&igrave;m dấu + - ph&iacute;a sau n&oacute; m&agrave; \r\n//nằm ngo&agrave;i tất cả dấu ngoặc  \r\n                    do{  \r\n                         k=vitridau(s,k);  \r\n                         if(k!=-1)  \r\n                         {  \r\n                              if(s[k]==&#39;(&#39;) k=timngoac(s,k);  \r\n                              if(k&gt;0 &amp;&amp; (s[k]==&#39;+&#39; || s[k]==&#39;-&#39;) &amp;&amp; (s[k-1]!=&#39;*&#39; &amp;&amp; s[k-1]!=&#39;/&#39;))\r\nbreak;  \r\n                         }  \r\n                    }while(k!=-1);  \r\n                    if(k==-1)//nếu kh&ocirc;ng t&igrave;m thấy th&igrave;\r\n// node l&agrave; dấu */ tại tr&iacute; j+1  \r\n                    {  \r\n                         a=s[j+1];  \r\n                         p=taonode(a);  \r\n                         b=s.substr(0,j+1);  \r\n                         xulyngoac(b);  \r\n                         c=s.substr(j+2,s.size()-j-2);  \r\n                         xulyngoac(c);  \r\n                         p-&gt;left=setcay(b);  \r\n                         p-&gt;right=setcay(c);  \r\n                    }  \r\n                    else//nếu t&igrave;m thấy th&igrave; node l&agrave; dấu t&igrave;m thấy  \r\n                    {  \r\n                         a=s[k];  \r\n                         p=taonode(a);  \r\n                         b=s.substr(0,k);  \r\n                         xulyngoac(b);  \r\n                         c=s.substr(k+1,s.size()-k-1);  \r\n                         xulyngoac(c);  \r\n                         //doi dau +-  \r\n                         if(s[j+1]==&#39;-&#39;) doidau(c);  \r\n                         p-&gt;left=setcay(b);  \r\n                         p-&gt;right=setcay(c);  \r\n                    }  \r\n               }  \r\n          }  \r\n     }  \r\n     return p;  \r\n}  \r\nlong atol(string s)  \r\n{  \r\n     long x=0,d=1;  \r\n     int j=0,k=0;  \r\n     if(s[0]==&#39;+&#39; || s[0]==&#39;-&#39;)  \r\n     {  \r\n          j=1;  \r\n          if(s[0]==&#39;-&#39;) k=1;  \r\n     }  \r\n     for(int i=s.size()-1;i&gt;=j;i--)  \r\n     {  \r\n          switch(s[i])  \r\n          {  \r\n          case &#39;0&#39;:x+=0*d;break;  \r\n          case &#39;1&#39;:x+=1*d;break;  \r\n          case &#39;2&#39;:x+=2*d;break;  \r\n          case &#39;3&#39;:x+=3*d;break;  \r\n          case &#39;4&#39;:x+=4*d;break;  \r\n          case &#39;5&#39;:x+=5*d;break;  \r\n          case &#39;6&#39;:x+=6*d;break;  \r\n          case &#39;7&#39;:x+=7*d;break;  \r\n          case &#39;8&#39;:x+=8*d;break;  \r\n          case &#39;9&#39;:x+=9*d;break;  \r\n          }  \r\n          d*=10;  \r\n     }  \r\n     if(k==0)return x;  \r\n     return -x;  \r\n}  \r\nlong tinh(cay t)  \r\n{  \r\n     long x;  \r\n     if(t)  \r\n     {  \r\n          if(t-&gt;s==&quot;+&quot;) return tinh(t-&gt;left)+tinh(t-&gt;right);  \r\n          else if(t-&gt;s==&quot;-&quot;) return tinh(t-&gt;left)-tinh(t-&gt;right);  \r\n          else if(t-&gt;s==&quot;*&quot;) return tinh(t-&gt;left)*tinh(t-&gt;right);  \r\n          else if(t-&gt;s==&quot;/&quot;) return tinh(t-&gt;left)/tinh(t-&gt;right);  \r\n          else return atol(t-&gt;s);  \r\n     }  \r\n     return 0;  \r\n}  \r\nvoid main()  \r\n{  \r\n     cay t;  \r\n     taocay(t);  \r\n     string s;  \r\n     cout&lt;&lt;&quot;nhap bieu thuc toan hoc cua cac so nguyen duong:\n&quot;;  \r\n     getline(cin,s);  \r\n     t=setcay(s);  \r\n     cout&lt;&lt;&quot;gia tri bieu thuc = &quot;&lt;&lt;tinh(t)&lt;&lt;endl;  \r\n     system(&quot;pause&quot;);  \r\n}  </pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 1, 1, NULL),
(124, 'cấu trúc cây trong lập trình c/c++', '<p><em><strong>cấu tr&uacute;c c&acirc;y trong lập tr&igrave;nh c/c++, cấu tr&uacute;c c&acirc;y rất quan trọng trong&nbsp;lập&nbsp;tr&igrave;nh quản l&yacute; dữ liệu</strong></em></p>\r\n\r\n<h3><br />\r\nĐịnh Nghĩa C&acirc;y</h3>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>C&acirc;y l&agrave; một tập hợp T c&aacute;c phần tử (gọi l&agrave; n&uacute;t của c&acirc;y), trong đ&oacute; c&oacute; một n&uacute;t đặc biệt gọi l&agrave; n&uacute;t gốc, c&aacute;c n&uacute;t c&ograve;n lại được chia th&agrave;nh những tập rời nhau T1, T2, &hellip;,Tn theo quan hệ ph&acirc;n cấp, trong đ&oacute; Ti cũng l&agrave; 1 c&acirc;y. Mỗi n&uacute;t ở cấp i sẽ quản l&yacute; một số n&uacute;t ở cấp i+1. Quan hệ n&agrave;y người ta gọi l&agrave; quan hệ cha &ndash; con.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<h3>Một Số Kh&aacute;i Niệm</h3>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Bậc của một n&uacute;t: l&agrave; số c&acirc;y con của n&uacute;t đ&oacute; .</p>\r\n\r\n<p>Bậc của một c&acirc;y: l&agrave; bậc lớn nhất của c&aacute;c n&uacute;t trong c&acirc;y&nbsp;</p>\r\n\r\n<p>N&uacute;t gốc: l&agrave; n&uacute;t kh&ocirc;ng c&oacute; n&uacute;t cha.</p>\r\n\r\n<p>N&uacute;t l&aacute;: l&agrave; n&uacute;t c&oacute; bậc bằng 0 .</p>\r\n\r\n<p>Mức của một n&uacute;t:</p>\r\n\r\n<p>Mức (gốc (T) ) = 0.</p>\r\n\r\n<p>Gọi T1, T2, T3, ... , Tn l&agrave; c&aacute;c c&acirc;y con của T0 : Mức (T1) = Mức (T2) = . . . &nbsp;= Mức (Tn) = Mức (T0) + 1.</p>\r\n\r\n<p>Độ d&agrave;i đường đi từ gốc đến n&uacute;t x: l&agrave; số nh&aacute;nh cần đi qua kể từ gốc đến x.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<h3>Một Số T&iacute;nh Chất Của C&acirc;y Nhị Ph&acirc;n</h3>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Số n&uacute;t nằm ở mức i  2i.</p>\r\n\r\n<p>Số n&uacute;t l&aacute;  2h-1, với h l&agrave; chiều cao của c&acirc;y.</p>\r\n\r\n<p>Chiều cao của c&acirc;y h  log2(N)</p>\r\n\r\n<p>N = số n&uacute;t trong c&acirc;y</p>\r\n\r\n<p>Số n&uacute;t trong c&acirc;y  2h-1.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<h3>Cấu Tr&uacute;c Dữ Liệu Của C&acirc;y Nhị Ph&acirc;n</h3>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>typedef struct tagTNode</p>\r\n\r\n<p>{</p>\r\n\r\n<p>Data Key;&nbsp;</p>\r\n\r\n<p>struct tagTNode *pLeft; struct tagTNode *pRight;&nbsp;</p>\r\n\r\n<p>}TNode;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>typedef TNode *TREE;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<h3>Duyệt C&acirc;y Nhị Ph&acirc;n&nbsp;</h3>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;C&oacute; 3 tr&igrave;nh tự thăm gốc :</p>\r\n\r\n<p>&nbsp;Duyệt trước</p>\r\n\r\n<p>&nbsp;Duyệt giữa</p>\r\n\r\n<p>&nbsp;Duyệt sau</p>\r\n\r\n<p>&nbsp; Độ phức tạp O (log2(h))</p>\r\n\r\n<p>&nbsp; &nbsp; Trong đ&oacute; h l&agrave; chiều cao c&acirc;y</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Duyệt Trước&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>void NLR(TREE Root)</p>\r\n\r\n<p>{</p>\r\n\r\n<p>if (Root != NULL)</p>\r\n\r\n<p>{</p>\r\n\r\n<p>; //Xử l&yacute; tương ứng theo nhu cầu NLR(Root-&gt;pLeft);</p>\r\n\r\n<p>NLR(Root-&gt;pRight);</p>\r\n\r\n<p>}</p>\r\n\r\n<p>}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Duyệt Giữa</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>void LNR(TREE Root)</p>\r\n\r\n<p>{</p>\r\n\r\n<p>if (Root != NULL)</p>\r\n\r\n<p>{</p>\r\n\r\n<p>LNR(Root-&gt;pLeft);</p>\r\n\r\n<p>; // Xử l&yacute; tương ứng theo nhu&nbsp; cầu&nbsp;</p>\r\n\r\n<p>LNR(Root-&gt;pRight);</p>\r\n\r\n<p>}</p>\r\n\r\n<p>}</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Duyệt Sau</strong></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>void LRN(TREE Root)</p>\r\n\r\n<p>{</p>\r\n\r\n<p>if (Root != NULL)</p>\r\n\r\n<p>{</p>\r\n\r\n<p>LRN(Root-&gt;pLeft);</p>\r\n\r\n<p>LRN(Root-&gt;pRight);</p>\r\n\r\n<p>; // Xử l&yacute; tương ứng theo nhu&nbsp; cầu&nbsp;</p>\r\n\r\n<p>}</p>\r\n\r\n<p>}</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 12, 1, 'Cây là một tập hợp T các phần tử (gọi là nút của cây), trong đó có một nút đặc biệt gọi là nút gốc, các nút còn lại được chia thành những tập rời nhau T1, T2, …,Tn theo quan hệ phân cấp, trong đó Ti cũng là 1 cây. Mỗi nút ở cấp i sẽ quản lý một số nút ở cấp i+1. Quan hệ này người ta gọi là quan hệ cha – con.'),
(125, 'cấu trúc cây nhị phân tìm kiếm', '<p>cấu tr&uacute;c c&acirc;y nhị ph&acirc;n t&igrave;m kiếm v&agrave; c&aacute;c thao t&aacute;c tr&ecirc;n c&acirc;y. định nghĩa, v&agrave; c&aacute;c thao th&aacute;o cần thiết phải c&oacute; khi c&agrave;i đặt 1 cay nhị ph&acirc;n t&igrave;m kiếm<br />\r\n&nbsp;</p>\r\n\r\n<h3>&ETH;ịnh nghĩa&nbsp;<a href="http://www.laptrinh321.tk/2015/05/cau-truc-cay-nhi-phan-tim-kiem-va-cac.html">c&acirc;y</a>&nbsp;nhị ph&acirc;n t&igrave;m kiếm</h3>\r\n\r\n<p><br />\r\nC&acirc;y nhị ph&acirc;n<br />\r\nBảo đảm nguy&ecirc;n tắc bố tr&iacute; kho&aacute; tại mỗi n&uacute;t:<br />\r\nC&aacute;c n&uacute;t trong c&acirc;y tr&aacute;i nhỏ hơn n&uacute;t hiện h&agrave;nh<br />\r\nC&aacute;c n&uacute;t trong c&acirc;y phải lớn hơn n&uacute;t hiện h&agrave;nh</p>\r\n\r\n<h3><br />\r\nƯu điểm của c&acirc;y nhị ph&acirc;n t&igrave;m kiếm</h3>\r\n\r\n<p><br />\r\nNhờ trật tự bố tr&iacute; kh&oacute;a tr&ecirc;n c&acirc;y :<br />\r\nĐịnh hướng được khi t&igrave;m kiếm<br />\r\nC&acirc;y gồm N phần tử :<br />\r\nTrường hợp tốt nhất h = log2N<br />\r\nTrường hợp xấu nhất h = Ln<br />\r\nT&igrave;nh huống xảy ra trường hợp xấu nhất ?<br />\r\n<br />\r\n&nbsp;</p>\r\n\r\n<h3>Cấu tr&uacute;c dữ liệu của c&acirc;y nhị ph&acirc;n t&igrave;m kiếm</h3>\r\n\r\n<p><br />\r\nCấu tr&uacute;c dữ liệu của 1 n&uacute;t<br />\r\n&nbsp; &nbsp; typedef struct tagTNode<br />\r\n&nbsp; &nbsp; { &nbsp;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; int Key; //trường dữ liệu l&agrave; 1 số nguy&ecirc;n<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; struct tagTNode *pLeft;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; struct tagTNode *pRight;<br />\r\n&nbsp; &nbsp; }TNode;<br />\r\nCấu tr&uacute;c dữ liệu của c&acirc;y<br />\r\n&nbsp; &nbsp; typedef TNode *TREE;<br />\r\n&nbsp;</p>\r\n\r\n<h3>C&aacute;c thao t&aacute;c tr&ecirc;n c&acirc;y nhị ph&acirc;n t&igrave;m kiếm</h3>\r\n\r\n<p><br />\r\n<br />\r\nTạo 1 c&acirc;y rỗng<br />\r\nTạo 1 n&uacute;t c&oacute; trường Key bằng x<br />\r\nTh&ecirc;m 1 n&uacute;t v&agrave;o c&acirc;y nhị ph&acirc;n t&igrave;m kiếm<br />\r\nXo&aacute; 1 n&uacute;t c&oacute; Key bằng x tr&ecirc;n c&acirc;y<br />\r\nT&igrave;m 1 n&uacute;t c&oacute; kho&aacute; bằng x tr&ecirc;n c&acirc;y</p>\r\n\r\n<h3><br />\r\nTạo c&acirc;y rỗng</h3>\r\n\r\n<p><br />\r\nC&acirc;y rỗng -&gt; địa chỉ n&uacute;t gốc bằng NULL<br />\r\n&nbsp; &nbsp; void CreateTree(TREE &amp;T)<br />\r\n&nbsp; &nbsp; {<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; T=NULL;<br />\r\n&nbsp; &nbsp; }<br />\r\n&nbsp;</p>\r\n\r\n<h3>Tạo 1 n&uacute;t c&oacute; Key bằng x</h3>\r\n\r\n<p><br />\r\nTNode *CreateTNode(int x)<br />\r\n{<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; TNode *p;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; p = new TNode; //cấp ph&aacute;t v&ugrave;ng nhớ động<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; if(p==NULL)<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit(1); // tho&aacute;t<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; else<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; {<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p-&gt;key = x; //g&aacute;n trường dữ liệu của n&uacute;t = x<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p-&gt;pLeft = NULL;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p-&gt;pRight = NULL;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; }<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; return p;<br />\r\n}</p>\r\n\r\n<h3><br />\r\nTh&ecirc;m một n&uacute;t x</h3>\r\n\r\n<p><br />\r\nRằng buộc: Sau khi th&ecirc;m c&acirc;y đảm bảo l&agrave; c&acirc;y nhị ph&acirc;n t&igrave;m kiếm.<br />\r\nint insertNode(TREE &amp;T, Data X)<br />\r\n{ &nbsp; if(T)<br />\r\n&nbsp; &nbsp; { &nbsp; if(T-&gt;Key == X) return 0;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; if(T-&gt;Key &gt; X) return insertNode(T-&gt;pLeft, X);<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; else &nbsp; &nbsp;return insertNode(T-&gt;pRight, X);}<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; T &nbsp; = new TNode;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; if(T == NULL) &nbsp; return -1;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; T-&gt;Key &nbsp;= X;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; T-&gt;pLeft =T-&gt;pRight = NULL;<br />\r\n&nbsp; &nbsp; return 1;&nbsp;<br />\r\n}<br />\r\n&nbsp;</p>\r\n\r\n<h3>T&igrave;m n&uacute;t c&oacute; kho&aacute; bằng x (kh&ocirc;ng d&ugrave;ng đệ quy)</h3>\r\n\r\n<p><br />\r\nTNode * searchNode(TREE Root, &nbsp;Data x)<br />\r\n{ &nbsp; &nbsp; &nbsp; Node *p = Root;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; while (p != NULL)<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; if(x == p-&gt;Key) return p;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else &nbsp;&nbsp;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(x &lt; p-&gt;Key) &nbsp;p = p-&gt;pLeft;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else &nbsp; &nbsp;p = p-&gt;pRight;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; }<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; return NULL;<br />\r\n}<br />\r\n&nbsp;</p>\r\n\r\n<h3>T&igrave;m n&uacute;t c&oacute; kho&aacute; bằng x (d&ugrave;ng đệ quy)</h3>\r\n\r\n<p><br />\r\nTNode *SearchTNode(TREE T, int x)<br />\r\n{<br />\r\n&nbsp; &nbsp; if(T!=NULL)<br />\r\n&nbsp; &nbsp; {<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; if(T-&gt;key==x)<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return T;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; else<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(x&gt;T-&gt;key)<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return SearchTNode(T-&gt;pRight,x);<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return SearchTNode(T-&gt;pLeft,x);<br />\r\n&nbsp; &nbsp; }<br />\r\n&nbsp; &nbsp; return NULL;<br />\r\n}<br />\r\n&nbsp;</p>\r\n\r\n<h3>Hủy 1 n&uacute;t c&oacute; kho&aacute; bằng X tr&ecirc;n c&acirc;y</h3>\r\n\r\n<p><br />\r\nHủy 1 phần tử tr&ecirc;n c&acirc;y phải đảm bảo điều kiện r&agrave;ng buộc của C&acirc;y nhị ph&acirc;n t&igrave;m kiếm<br />\r\nC&oacute; 3 trường hợp khi hủy 1 n&uacute;t tr&ecirc;n c&acirc;y<br />\r\nTH1: X l&agrave; n&uacute;t l&aacute;<br />\r\nTH2: X chỉ c&oacute; 1 c&acirc;y con (c&acirc;y con tr&aacute;i hoặc c&acirc;y con phải)<br />\r\nTH3: X c&oacute; đầy đủ 2 c&acirc;y con<br />\r\nTH1: Ta xo&aacute; n&uacute;t l&aacute; m&agrave; kh&ocirc;ng &agrave;nh hưởng đến c&aacute;c n&uacute;t kh&aacute;c ttr&ecirc;n c&acirc;y<br />\r\nTH2: Trước khi xo&aacute; x ta m&oacute;c nối cha của X với con duy nhất c&ugrave;a X.<br />\r\nTH3: Ta d&ugrave;ng c&aacute;ch xo&aacute; gi&aacute;n tiếp<br />\r\n&nbsp;</p>\r\n\r\n<h3>Hủy 1 n&uacute;t c&oacute; 2 c&acirc;y con</h3>\r\n\r\n<p><br />\r\nTa d&ugrave;ng c&aacute;ch hủy gi&aacute;n tiếp, do X c&oacute; 2 c&acirc;y con<br />\r\nThay v&igrave; hủy X ta t&igrave;m phần tử thế mạng Y. N&uacute;t Y c&oacute; tối đa 1 c&acirc;y con.<br />\r\nTh&ocirc;ng tin lưu tại n&uacute;t Y sẽ được chuyển l&ecirc;n lưu tại X.<br />\r\nTa tiến h&agrave;nh xo&aacute; hủy n&uacute;t Y (xo&aacute; Y giống 2 trường hợp đầu)<br />\r\nC&aacute;ch t&igrave;m n&uacute;t thế mạng Y cho X: C&oacute; 2 c&aacute;ch<br />\r\n&nbsp;C1: N&uacute;t Y l&agrave; n&uacute;t c&oacute; kho&aacute; nhỏ nhất (tr&aacute;i nhất) b&ecirc;n c&acirc;y con phải X<br />\r\nC2: N&uacute;t Y l&agrave; n&uacute;t c&oacute; kho&aacute; lớn nhất (phải nhất) b&ecirc;n c&acirc;y con tr&aacute;i của X<br />\r\n&nbsp;</p>\r\n\r\n<h3>C&agrave;i đặt thao t&aacute;c xo&aacute; n&uacute;t c&oacute; trường Key = x</h3>\r\n\r\n<p><br />\r\nvoid DeleteNodeX1(TREE &amp;T,int x)<br />\r\n{<br />\r\n&nbsp; &nbsp; if(T!=NULL)<br />\r\n&nbsp; &nbsp; {<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; if(T-&gt;Key&lt;x) &nbsp; &nbsp;DeleteNodeX1(T-&gt;Right,x);<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; else<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; {<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(T-&gt;Key&gt;x) &nbsp; &nbsp;DeleteNodeX1(T-&gt;Left,x);<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else &nbsp;//tim thấy &nbsp;Node c&oacute; trường dữ liệu = x<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; TNode *p; &nbsp;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p=T;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (T-&gt;Left==NULL) &nbsp;T = T-&gt;Right;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { &nbsp; if(T-&gt;Right==NULL) &nbsp;T=T-&gt;Left;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else &nbsp; &nbsp;ThayThe1(p, T-&gt;Right);// t&igrave;m b&ecirc;n c&acirc;y con phải<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete p;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; }<br />\r\n&nbsp; &nbsp; }<br />\r\n&nbsp; &nbsp; else &nbsp; &nbsp;printf(&quot;Khong tim thay phan can xoa tu&quot;);<br />\r\n}<br />\r\n&nbsp;</p>\r\n\r\n<h3>H&agrave;m t&igrave;m phần tử thế mạng&nbsp;</h3>\r\n\r\n<p><br />\r\nvoid ThayThe1(TREE &amp;p, TREE &amp;T)<br />\r\n{ &nbsp; &nbsp;if(T-&gt;Left!=NULL)<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; ThayThe1(p,T-&gt;Left);<br />\r\nelse<br />\r\n&nbsp; &nbsp; &nbsp;{<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; p-&gt;Key = T-&gt;Key;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; p=T;<br />\r\n&nbsp; &nbsp; &nbsp; &nbsp; T=T-&gt;Right;<br />\r\n&nbsp; &nbsp; }<br />\r\n}<br />\r\n&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 4, 1, NULL),
(126, 'hàm xóa node trong cây nhị phân tìm kiếm', '<pre class="brush:cpp;">\r\nvoid thaythe(tree &amp;t,node *p)  \r\n{  \r\n    if(t-&gt;left) thaythe(t-&gt;left,p);  \r\n    //nếu nh&aacute;nh b&ecirc;n tr&aacute;i c&ograve;n tức l&agrave; kh&aacute;c NULL \r\n//th&igrave; tiếp tực nhảy đến nh&aacute;nh bến tr&aacute;i  \r\n    //cho đến khi n&agrave;o n&oacute; l&agrave; cực tr&aacute;i th&igrave; th&ocirc;i  \r\n    else//n&oacute; đ&atilde; l&agrave; node cực tr&aacute;i  \r\n    {  \r\n        p-&gt;key=t-&gt;key;  \r\n        //p l&agrave; con trỏ truyền v&agrave;o, mọi thay đỏi về bộ nhớ, \r\n//&ocirc; nhớ hay gi&aacute; trị đều thay đỏi tr&ecirc;n  \r\n        //h&agrave;m xoa(tree &amp;t,int x) đ&atilde; gọi n&oacute;.  \r\n        //l&uacute;c n&agrave;y p l&agrave; node cần x&oacute;a ở h&agrave;m x&oacute;a,\r\n// ta kh&ocirc;ng x&oacute;a node m&agrave; thay thế gi&aacute; trị cho n&oacute;  \r\n        //rồi chuyển n&oacute; đến 1 &ocirc; nhớ kh&aacute;c,   \r\n        //&ocirc; nhớ m&agrave; t đang t&igrave;m để thay thế \r\n//để h&agrave;m xoa() gọi delete n&oacute;.  \r\n        p=t;//node t l&agrave; node ta đ&atilde; t&igrave;m ra để thay thế   \r\n        //n&ecirc;n p=t; tức l&agrave; sẽ x&oacute;a T thay cho p ban đầu  \r\n        //n&ecirc;n p(node sẽ x&oacute;a ở h&agrave;m ngo&agrave;i) \r\n//nhảy đến &ocirc; nhớ của node thay thế l&agrave; node T , p=t;  \r\n        t=t-&gt;right;  \r\n        //v&igrave; t sẽ bị x&oacute;a th&ocirc;ng qua p n&ecirc;n \r\n//t phải nhay đến nh&aacute;nh b&ecirc;n phải   \r\n        //để l&agrave;m liến mạch li&ecirc;n kết với \r\n//cha như đ&atilde; l&yacute; giải ở h&agrave;m x&oacute;a  \r\n        //v&igrave; sao lại trỏ right l&agrave; kh&ocirc;ng phải trỏ left?  \r\n        //v&igrave; T l&agrave; node thay thế, l&agrave; node cực tr&aacute;i,   \r\n        //tức nh&aacute;nh tr&aacute;i = NULL\r\n// c&ograve;n nh&aacute;nh phải c&oacute; thể kh&aacute;c NULL  \r\n        //hoắc bằng NULL, t kh&ocirc;ng cần x&aacute;c định, chỉ cần   \r\n        //trỏ t-&gt;right để l&agrave;m liền mạch li&ecirc;n kết\r\n// đến node cha đ&atilde; gọi đến n&oacute;  \r\n        //l&agrave; ok.  \r\n    }  \r\n}  \r\nvoid xoa(tree &amp;t,int x)//h&agrave;m x&oacute;a node trong c&acirc;y nhị ph&acirc;n t&igrave;m kiếm  \r\n{  \r\n    if(t)//nếu c&acirc;y t!=NULL  \r\n    {  \r\n        if(x&lt;t-&gt;key) xoa(t-&gt;left,x);//nếu x &lt; key x&oacute;a b&ecirc;n tr&aacute;i  \r\n        else if(x&gt;t-&gt;key) xoa(t-&gt;right,x);//x&oacute;a b&ecirc;n phải  \r\n        else//đ&atilde; t&igrave;m thấy node cần x&oacute;a  \r\n        {  \r\n            node *p=t;//g&aacute;n node cần x&oacute;a cho p  \r\n            if(t-&gt;left==NULL) t=t-&gt;right;  \r\n            //nếu node cần x&oacute;a c&oacute; 1 c&acirc;y con b&ecirc;n phải  \r\n            else if(t-&gt;right==NULL) t=t-&gt;left;  \r\n            //hoặc 1 c&acirc;y con b&ecirc;n tr&aacute;i  \r\n            //th&igrave; T được truyền v&agrave;o trong đối số h&agrave;m \r\n//nhảy sang tr&aacute;i hoăc sang phải như tr&ecirc;n  \r\n            //v&igrave; sao n&oacute; li&ecirc;n kết được với node cha??  \r\n            //v&igrave; node cha đang trỏ đến con trỏ t (tree &amp;t)   \r\n            //ở dạng tham chiếu lu&ocirc;n n&ecirc;n mọi thay đổi tr&ecirc;n t  \r\n            //th&igrave; đều thay đổi tr&ecirc;n cấu tr&uacute;c của node cha,\r\n// node gọi đến h&agrave;m n&agrave;y  \r\n            //v&igrave; thế node cha của node cần x&oacute;a hiện tại   \r\n            //sẽ trỏ đến t, v&agrave; khi t=t-&gt;right; th&igrave;  \r\n            //node cha của node cần t cần x&oacute;a vẫn đang trỏ   \r\n            //đến t với gi&aacute; trị l&agrave; &ocirc; địa chỉ mới t-&gt;right;  \r\n            else thaythe(t-&gt;right,p);  \r\n            //nếu ndoe t cần x&oacute;a c&oacute; 2 nh&aacute;nh con th&igrave;\r\n// t&igrave;m node cực tr&aacute;i của nh&aacute;nh phải  \r\n            //hoặc ngược lại cũng c&oacute; thể được  \r\n            delete p;  \r\n        }  \r\n    }  \r\n    //lưu &yacute; cần nhớ.  \r\n    //khi đối số của h&agrave;m l&agrave; c&ograve;n trỏ hoặc tham chiếu   \r\n    //th&igrave; mọi thay đổi tr&ecirc;n n&oacute; đều thay đổi \r\n//đến biến của h&agrave;m đ&atilde; gọi n&oacute;,   \r\n    //thay đổi đến cụ diện chung của biến, \r\n//của h&agrave;m đ&atilde; gọi n&oacute;.  \r\n}  </pre>\r\n\r\n<p>&nbsp;</p>\r\n', '/admin/images_cm/c.png', 37, '2015-11-08', 33, 1, NULL),
(128, 'chuyển đổi hệ đếm nhị phân, bát phân, thập lục phân', '<!--###tools###chuyen_doi_he_so_dem.php###-->', '/admin/images_cm/0_Tools.png', 42, '2015-11-24', 87, 1, 'chuyển đổi giữa các hệ số đếm, thập phân, nhị phân, bát phân, thập lục phân'),
(129, 'check một số có phải số nguyên tố hay không', '<!--###tools###so_nguyen_to.php###-->', '/admin/images_cm/0_Tools.png', 42, '2015-11-26', 16, 1, 'check một số có phải số nguyên tố hay không? tools kiểm tra nhanh chóng 1 số, tối đa 10 chữ');

-- --------------------------------------------------------

--
-- Table structure for table `chuyenmuc`
--

CREATE TABLE IF NOT EXISTS `chuyenmuc` (
  `id` int(10) unsigned NOT NULL,
  `title` text COLLATE utf8_unicode_ci,
  `image` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL
) ENGINE=InnoDB AUTO_INCREMENT=44 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

--
-- Dumping data for table `chuyenmuc`
--

INSERT INTO `chuyenmuc` (`id`, `title`, `image`) VALUES
(37, 'C/C++', '/admin/images_cm/c.png'),
(39, 'PHP', '/admin/images_cm/php.png'),
(41, 'HTML', '/admin/images_cm/html.png'),
(42, 'TOOLS', '/admin/images_cm/0_Tools.png'),
(43, 'Câu Hỏi', '/admin/images_cm/0_cau_hoi.png');

-- --------------------------------------------------------

--
-- Table structure for table `comment`
--

CREATE TABLE IF NOT EXISTS `comment` (
  `cmt_id` int(11) NOT NULL,
  `cmt_idbv` int(11) DEFAULT NULL,
  `cmt_uid` int(11) DEFAULT NULL,
  `cmt_content` longtext COLLATE utf8_unicode_ci
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

-- --------------------------------------------------------

--
-- Table structure for table `menu_tren`
--

CREATE TABLE IF NOT EXISTS `menu_tren` (
  `title` text COLLATE utf8_unicode_ci,
  `link` text COLLATE utf8_unicode_ci,
  `id` int(11) NOT NULL
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

--
-- Dumping data for table `menu_tren`
--

INSERT INTO `menu_tren` (`title`, `link`, `id`) VALUES
('Home', 'http://laptrinh321.dev:8080', 3);

-- --------------------------------------------------------

--
-- Table structure for table `options`
--

CREATE TABLE IF NOT EXISTS `options` (
  `footer` text COLLATE utf8_unicode_ci,
  `maxpage` int(11) DEFAULT NULL,
  `maxpage_cmt` int(11) DEFAULT NULL,
  `facebook` text COLLATE utf8_unicode_ci,
  `google` text COLLATE utf8_unicode_ci,
  `youtube` text COLLATE utf8_unicode_ci
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

--
-- Dumping data for table `options`
--

INSERT INTO `options` (`footer`, `maxpage`, `maxpage_cmt`, `facebook`, `google`, `youtube`) VALUES
('<p>&copy; 2015</p>\r\n\r\n<p>Trần Kh&aacute;nh To&agrave;n - Lập Tr&igrave;nh 321 (<em>beta</em>)</p>\r\n', 10, 10, 'https://www.facebook.com/profile.php?id=100004106050082', 'https://plus.google.com/u/0/114746573387722844751', 'https://www.youtube.com/channel/UCrFM-cnqnpRUe5Os96xTwuA');

-- --------------------------------------------------------

--
-- Table structure for table `theo_doi`
--

CREATE TABLE IF NOT EXISTS `theo_doi` (
  `td_uid` int(11) NOT NULL,
  `td_idbv` int(11) NOT NULL,
  `thong_bao` int(11) NOT NULL DEFAULT '0'
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

--
-- Dumping data for table `theo_doi`
--

INSERT INTO `theo_doi` (`td_uid`, `td_idbv`, `thong_bao`) VALUES
(1, 132, 0),
(3, 128, 0),
(3, 130, 0);

-- --------------------------------------------------------

--
-- Table structure for table `users`
--

CREATE TABLE IF NOT EXISTS `users` (
  `uid` int(10) unsigned NOT NULL,
  `username` varchar(255) COLLATE utf8_unicode_ci NOT NULL,
  `pass` varchar(255) COLLATE utf8_unicode_ci NOT NULL,
  `email` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `birthday` date DEFAULT NULL,
  `checkmail` int(11) DEFAULT '0',
  `lastlogin` int(15) DEFAULT NULL,
  `avatar` text COLLATE utf8_unicode_ci,
  `gender` text COLLATE utf8_unicode_ci
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

--
-- Dumping data for table `users`
--

INSERT INTO `users` (`uid`, `username`, `pass`, `email`, `birthday`, `checkmail`, `lastlogin`, `avatar`, `gender`) VALUES
(1, 'admin', 'e10adc3949ba59abbe56e057f20f883e', 'trankhanhtoan321@gmail.com', '1996-10-29', 1, 1448545826, 'uploads/avatar/0_user_male.png', 'male'),
(3, 'trankhanhtoan96', '18a0b00fcc0dcaa0b852a61fa58f438f', 'trankhanhtoan96@gmail.com', '1996-10-29', 1, 1448693657, 'uploads/avatar/user_male.png', 'male');

--
-- Indexes for dumped tables
--

--
-- Indexes for table `baiviet`
--
ALTER TABLE `baiviet`
  ADD PRIMARY KEY (`idbv`);

--
-- Indexes for table `chuyenmuc`
--
ALTER TABLE `chuyenmuc`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `comment`
--
ALTER TABLE `comment`
  ADD PRIMARY KEY (`cmt_id`);

--
-- Indexes for table `menu_tren`
--
ALTER TABLE `menu_tren`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `theo_doi`
--
ALTER TABLE `theo_doi`
  ADD PRIMARY KEY (`td_uid`,`td_idbv`);

--
-- Indexes for table `users`
--
ALTER TABLE `users`
  ADD PRIMARY KEY (`uid`);

--
-- AUTO_INCREMENT for dumped tables
--

--
-- AUTO_INCREMENT for table `baiviet`
--
ALTER TABLE `baiviet`
  MODIFY `idbv` int(10) unsigned NOT NULL AUTO_INCREMENT,AUTO_INCREMENT=130;
--
-- AUTO_INCREMENT for table `chuyenmuc`
--
ALTER TABLE `chuyenmuc`
  MODIFY `id` int(10) unsigned NOT NULL AUTO_INCREMENT,AUTO_INCREMENT=44;
--
-- AUTO_INCREMENT for table `comment`
--
ALTER TABLE `comment`
  MODIFY `cmt_id` int(11) NOT NULL AUTO_INCREMENT,AUTO_INCREMENT=2;
--
-- AUTO_INCREMENT for table `menu_tren`
--
ALTER TABLE `menu_tren`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT,AUTO_INCREMENT=4;
--
-- AUTO_INCREMENT for table `users`
--
ALTER TABLE `users`
  MODIFY `uid` int(10) unsigned NOT NULL AUTO_INCREMENT,AUTO_INCREMENT=4;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
